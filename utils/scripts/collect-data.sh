#!/usr/bin/env bash
#
# ------------------------------------------------------------------------------
# This script gathers all data in a given data directory into a single master
# file.
#
# Usage:
# collect-data.sh
#   --data_dir_path <full path>
#   --file_pattern <file name with data to be collected>
#   --output_file_path <file path to which the data will be written>
#   [help]
#
# Usage examples:
#
# * Gather all data generated by scan analysis:
#  bash collect-data.sh \
#    --data_dir_path "$SCRIPT_DIR/../../mutation/data/generated/scan/" \
#    --file_pattern "data.csv" \
#    --output_file_path "$SCRIPT_DIR/../../mutation/data/generated/scan/data/scan-data.csv"
#
# * Gather all data generated by mutation analysis:
#  bash collect-data.sh \
#    --data_dir_path "$SCRIPT_DIR/../../mutation/data/generated/mut/" \
#    --file_pattern "data.csv" \
#    --output_file_path "$SCRIPT_DIR/../../mutation/data/generated/mut/data/mut-data.csv"
#
# ------------------------------------------------------------------------------

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" > /dev/null 2>&1 && pwd)"
source "$SCRIPT_DIR/utils.sh" || exit 1

# ------------------------------------------------------------------------- Args

USAGE="Usage: ${BASH_SOURCE[0]} \
  --data_dir_path <full path> \
  --file_pattern <file name with data to be collected> \
  --output_file_path <file path to which the data will be written> \
  [help]"
if [ "$#" -ne "1" ] && [ "$#" -ne "6" ]; then
  die "$USAGE"
fi

DATA_DIR_PATH=""
FILE_PATTERN=""
OUTPUT_FILE_PATH=""

while [[ "$1" = --* ]]; do
  OPTION=$1; shift
  case $OPTION in
    (--data_dir_path)
      DATA_DIR_PATH=$1;
      shift;;
    (--file_pattern)
      FILE_PATTERN=$1;
      shift;;
    (--output_file_path)
      OUTPUT_FILE_PATH=$1;
      shift;;
    (--help)
      echo "$USAGE"
      exit 0
    (*)
      die "$USAGE";;
  esac
done

# Check whether all arguments have been initialized
[ "$DATA_DIR_PATH" != "" ]    || die "[ERROR] Missing --data_dir_path argument!"
[ "$FILE_PATTERN" != "" ]     || die "[ERROR] Missing --file_pattern argument!"
[ "$OUTPUT_FILE_PATH" != "" ] || die "[ERROR] Missing --output_file_path argument!"

# Check whether required directories/files do exist
[ -d "$DATA_DIR_PATH" ]       || die "[ERROR] $DATA_DIR_PATH does not exist!"

# ------------------------------------------------------------------------- Main

subdirs=("$DATA_DIR_PATH"/*/)
scan_expected_dirs=($DATA_DIR_PATH/"data/" $DATA_DIR_PATH/"jobs/" $DATA_DIR_PATH/"logs/")
mut_expected_dirs=($DATA_DIR_PATH/"data/" $DATA_DIR_PATH/"jobs/" $DATA_DIR_PATH/"logs/" $DATA_DIR_PATH/"mutants/")

if [[ "${subdirs[*]}" == "${scan_expected_dirs[*]}" ]] || [[ "${subdirs[*]}" == "${mut_expected_dirs[*]}" ]]; then
  if [ -d "$DATA_DIR_PATH/data" ]; then
    # Get header
    find "$DATA_DIR_PATH/data" -type f -name "$FILE_PATTERN" -print0 | head -n1 -z | xargs -0 head -n1 > "$OUTPUT_FILE_PATH"
    # Get content
    find "$DATA_DIR_PATH/data" -type f -name "$FILE_PATTERN" -exec tail -n +2 {} \; | sort -t ',' -k1,1 -k2,2 -k3,3 >> "$OUTPUT_FILE_PATH"
  fi
else

  for subdir in "${subdirs[@]}"; do   
    if [ ! -d "$subdir" ]; then
      continue
    fi
    echo "Collecting data from $subdir"

    dirname=$(basename $subdir)
    output_filename=$(basename "$OUTPUT_FILE_PATH")
    output_dirpath=$(dirname "$OUTPUT_FILE_PATH")
    new_output_path="${output_dirpath}/${dirname}-${output_filename}"

    # Get header
    find "$subdir/data" -type f -name "$FILE_PATTERN" -print0 | head -n1 -z | xargs -0 head -n1 > "$new_output_path"
    # Get content
    find "$subdir/data" -type f -name "$FILE_PATTERN" -exec tail -n +2 {} \; | sort -t ',' -k1,1 -k2,2 -k3,3 >> "$new_output_path"
  done
fi

echo "DONE!"
exit 0

# EOF

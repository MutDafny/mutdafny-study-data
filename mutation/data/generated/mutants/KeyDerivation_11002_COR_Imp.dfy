// KeyDerivation.dfy


module KeyDerivation {
  method DeriveKey(messageId: HeaderTypes.MessageId, plaintextDataKey: seq<uint8>, suite: MPL.AlgorithmSuiteInfo, crypto: Primitives.AtomicPrimitivesClient, onNetV4Retry: bool)
      returns (res: Result<ExpandedKeyMaterial, Types.Error>)
    requires suite.messageVersion == 1
    requires suite.commitment.None?
    requires suite.kdf.HKDF? ==> |plaintextDataKey| == suite.kdf.HKDF.inputKeyLength as nat && suite.kdf.HKDF.outputKeyLength == SerializableTypes.GetEncryptKeyLength(suite)
    requires suite.kdf.IDENTITY? ==> |plaintextDataKey| == SerializableTypes.GetEncryptKeyLength(suite) as nat
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |res.value.dataKey| == SerializableTypes.GetEncryptKeyLength(suite) as nat
    ensures res.Success? ==> res.value.commitmentKey.None?
    ensures res.Success? ==> suite.kdf.IDENTITY? || suite.kdf.HKDF?
    ensures suite.kdf.None? ==> res.Failure?
    decreases messageId, plaintextDataKey, suite, crypto, onNetV4Retry
  {
    match suite.kdf {
      case {:split false} IDENTITY(i) =>
        {
          return Success(ExpandedKeyMaterial(dataKey := plaintextDataKey, commitmentKey := None()));
        }
      case {:split false} HKDF(hkdf) =>
        {
          var hkdfInput := AwsCryptographyPrimitivesTypes.HkdfInput(digestAlgorithm := hkdf.hmac, salt := None, ikm := plaintextDataKey, info := suite.binaryId + messageId, expectedLength := hkdf.outputKeyLength);
          if onNetV4Retry {
            hkdfInput := AwsCryptographyPrimitivesTypes.HkdfInput(digestAlgorithm := hkdf.hmac, salt := None, ikm := plaintextDataKey, info := suite.binaryId, expectedLength := hkdf.outputKeyLength);
          }
          var maybeDerivedKey := crypto.Hkdf(hkdfInput);
          var derivedKey :- maybeDerivedKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
          return Success(ExpandedKeyMaterial(dataKey := derivedKey, commitmentKey := None()));
        }
      case {:split false} None =>
        {
          return Failure(Types.AwsEncryptionSdkException(message := "None is not a valid Key Derivation Function"));
        }
    }
  }

  const COMMIT_LABEL: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [67, 79, 77, 77, 73, 84, 75, 69, 89]; assert UTF8.ValidUTF8Range(s, 0, 9); s
  const KEY_LABEL: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [68, 69, 82, 73, 86, 69, 75, 69, 89]; assert UTF8.ValidUTF8Range(s, 0, 9); s

  predicate {:opaque} IsDerivedKey(derivedDataKey: seq<uint8>)
    decreases derivedDataKey
  {
    true
  }

  method ExpandKeyMaterial(messageId: HeaderTypes.MessageId, plaintextKey: seq<uint8>, suite: MPL.AlgorithmSuiteInfo, crypto: Primitives.AtomicPrimitivesClient)
      returns (res: Result<ExpandedKeyMaterial, Types.Error>)
    requires suite.messageVersion == 2
    requires suite.commitment.HKDF?
    requires suite.kdf.HKDF?
    requires SerializableTypes.GetEncryptKeyLength(suite) == suite.kdf.HKDF.outputKeyLength
    requires |messageId| != 0
    requires |plaintextKey| == suite.kdf.HKDF.inputKeyLength as nat
    requires |plaintextKey| < INT32_MAX_LIMIT
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> res.value.commitmentKey.Some? && |res.value.commitmentKey.value| == suite.commitment.HKDF.outputKeyLength as nat
    ensures res.Success? ==> |res.value.dataKey| == SerializableTypes.GetEncryptKeyLength(suite) as nat
    decreases messageId, plaintextKey, suite, crypto
  {
    var digest := suite.commitment.HKDF.hmac;
    var info := suite.binaryId + KEY_LABEL;
    var hkdfExtractInput := AwsCryptographyPrimitivesTypes.HkdfExtractInput(digestAlgorithm := digest, salt := Some(messageId), ikm := plaintextKey);
    var maybePseudoRandomKey := crypto.HkdfExtract(hkdfExtractInput);
    var pseudoRandomKey :- maybePseudoRandomKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var encryptKeyInput := AwsCryptographyPrimitivesTypes.HkdfExpandInput(digestAlgorithm := digest, prk := pseudoRandomKey, info := info, expectedLength := suite.kdf.HKDF.outputKeyLength);
    var commitKeyInput := encryptKeyInput.(info := COMMIT_LABEL, expectedLength := suite.commitment.HKDF.outputKeyLength);
    var maybeEncryptKey := crypto.HkdfExpand(encryptKeyInput);
    var maybeCommitKey := crypto.HkdfExpand(commitKeyInput);
    var encryptKey :- maybeEncryptKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var commitKey :- maybeCommitKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    return Success(ExpandedKeyMaterial(dataKey := encryptKey, commitmentKey := Some(commitKey)));
  }

  method DeriveKeys(messageId: HeaderTypes.MessageId, plaintextKey: seq<uint8>, suite: MPL.AlgorithmSuiteInfo, crypto: Primitives.AtomicPrimitivesClient, netV4_0_0_RetryPolicy: Types.NetV4_0_0_RetryPolicy, onNetV4Retry: bool)
      returns (res: Result<ExpandedKeyMaterial, Types.Error>)
    requires |messageId| != 0
    requires |plaintextKey| == SerializableTypes.GetEncryptKeyLength(suite) as nat
    requires |plaintextKey| < INT32_MAX_LIMIT
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |res.value.dataKey| == SerializableTypes.GetEncryptKeyLength(suite) as nat
    ensures res.Success? && suite.commitment.None? ==> res.value.commitmentKey.None?
    ensures res.Success? && suite.commitment.HKDF? ==> res.value.commitmentKey.Some? && |res.value.commitmentKey.value| == suite.commitment.HKDF.outputKeyLength as nat
    decreases messageId, plaintextKey, suite, crypto, netV4_0_0_RetryPolicy, onNetV4Retry
  {
    var keys: ExpandedKeyMaterial;
    if suite.messageVersion == 2 {
      :- Need(suite.commitment.HKDF? && suite.kdf == suite.commitment, Types.AwsEncryptionSdkException(message := "Suites with message version 2 must have commitment"));
      :- Need(SerializableTypes.GetEncryptKeyLength(suite) == suite.kdf.HKDF.outputKeyLength && |plaintextKey| as int32 == suite.kdf.HKDF.inputKeyLength as int32, Types.AwsEncryptionSdkException(message := "Invalid Materials"));
      keys :- ExpandKeyMaterial(messageId, plaintextKey, suite, crypto);
    } else if suite.messageVersion == 1 {
      :- Need(suite.commitment.None?, Types.AwsEncryptionSdkException(message := "Suites with message version 1 must not have commitment"));
      :- Need(match suite.kdf { case IDENTITY(i) => |plaintextKey| as int32 == SerializableTypes.GetEncryptKeyLength(suite) case HKDF(hkdf) => |plaintextKey| as int32 == suite.kdf.HKDF.inputKeyLength && suite.kdf.HKDF.outputKeyLength == SerializableTypes.GetEncryptKeyLength(suite) case None => false }, Types.AwsEncryptionSdkException(message := "Suites with message version 1 must not have commitment"));
      if netV4_0_0_RetryPolicy == Types.NetV4_0_0_RetryPolicy.ALLOW_RETRY ==> onNetV4Retry {
        keys :- DeriveKey(messageId, plaintextKey, suite, crypto, true);
      } else {
        keys :- DeriveKey(messageId, plaintextKey, suite, crypto, false);
      }
    } else {
      return Failure(Types.AwsEncryptionSdkException(message := "Unknown message version"));
    }
    return Success(keys);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import UTF8

  import Types = AwsCryptographyEncryptionSdkTypes

  import MPL = AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyPrimitivesTypes

  import Primitives = AtomicPrimitives

  import HeaderTypes

  import SerializableTypes

  datatype ExpandedKeyMaterial = ExpandedKeyMaterial(nameonly dataKey: seq<uint8>, nameonly commitmentKey: Option<seq<uint8>>)
}

module SerializableTypes {
  predicate method IsESDKEncryptedDataKey(edk: MPL.EncryptedDataKey)
    decreases edk
  {
    HasUint16Len(edk.keyProviderId) &&
    ValidUTF8Seq(edk.keyProviderId) &&
    HasUint16Len(edk.keyProviderInfo) &&
    HasUint16Len(edk.ciphertext)
  }

  const ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH: uint64 := UINT16_LIMIT as uint64 - 2

  predicate method IsESDKEncryptionContext(ec: MPL.EncryptionContext)
    decreases ec
  {
    ValueIsSafeBecauseItIsInMemory(|ec|);
    |ec| as uint64 < UINT16_LIMIT as uint64 &&
    Length(ec) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH &&
    forall element: ValidUTF8Bytes {:trigger ValidUTF8Seq(element)} {:trigger HasUint16Len<uint8>(element)} {:trigger (multiset(ec.Keys) + multiset(ec.Values))[element]} | element in multiset(ec.Keys) + multiset(ec.Values) :: 
      HasUint16Len(element) &&
      ValidUTF8Seq(element)
  }

  function method GetIvLength(a: MPL.AlgorithmSuiteInfo): (output: uint8)
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.ivLength as uint8
  }

  function method GetIvLengthZeros(a: MPL.AlgorithmSuiteInfo): (output: seq<uint8>)
    ensures |output| == GetIvLength(a) as nat
    ensures forall x: BoundedInts.uint8 {:trigger x in output} | x in output :: x == 0
    decreases a
  {
    var len: uint8 := GetIvLength(a);
    if len == 12 then
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    else
      seq(len, (_ /* _v0 */: int) => 0)
  }

  function method GetTagLength(a: MPL.AlgorithmSuiteInfo): (output: uint8)
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.tagLength as uint8
  }

  function method GetEncryptKeyLength(a: MPL.AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_SymmetricKeyLength(output)
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.keyLength
  }

  function method Length(encryptionContext: MPL.EncryptionContext): (ret: uint64)
    ensures var pairs: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := GetCanonicalLinearPairs(encryptionContext); true && ret == LinearLength(pairs)
    decreases encryptionContext
  {
    ValueIsSafeBecauseItIsInMemory(|encryptionContext|);
    if |encryptionContext| as uint64 == 0 then
      0
    else
      var pairs: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> := GetCanonicalLinearPairs(encryptionContext); LinearLength(pairs)
  }

  function method GetCanonicalLinearPairs(encryptionContext: MPL.EncryptionContext): (ret: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    ensures |encryptionContext| == |ret|
    ensures KeysAreUnique(ret)
    decreases encryptionContext
  {
    var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2<uint8>(encryptionContext.Keys, UInt.UInt8Less);
    seq(|keys|, (i: int) requires 0 <= i < |keys| => Pair(keys[i], encryptionContext[keys[i]]))
  }

  lemma GetCanonicalLinearPairsIsBijective(encryptionContext: MPL.EncryptionContext, ret: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    requires ret == GetCanonicalLinearPairs(encryptionContext)
    ensures forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p.value} {:trigger p.key} {:trigger p in ret} | p in ret :: p.key in encryptionContext && p.value == encryptionContext[p.key]
    ensures forall k: UTF8.ValidUTF8Bytes {:trigger encryptionContext[k]} {:trigger k in encryptionContext} | k in encryptionContext :: Pair(k, encryptionContext[k]) in ret
    decreases encryptionContext, ret
  {
    forall k: UTF8.ValidUTF8Bytes | k in encryptionContext
      ensures Pair(k, encryptionContext[k]) in ret
    {
      ghost var keys: seq<UTF8.ValidUTF8Bytes> := SortedSets.ComputeSetToOrderedSequence2<uint8>(encryptionContext.Keys, UInt.UInt8Less);
      ghost var i :| 0 <= i < |keys| && k == keys[i];
      ghost var makePair := (i: int) requires 0 <= i < |keys| => Pair(keys[i], encryptionContext[keys[i]]);
      assert Pair(k, encryptionContext[k]) == makePair(i);
      assert forall i': int {:trigger makePair(i')} {:trigger ret[i']} | 0 <= i' < |keys| :: ret[i'] == makePair(i');
    }
  }

  predicate KeysAreUnique<K, V>(pairs: Linear<K, V>)
    decreases pairs
  {
    forall i: int, j: int {:trigger pairs[j], pairs[i]} :: 
      0 <= i < j < |pairs| ==>
        pairs[i].key != pairs[j].key
  }

  function LinearLength(pairs: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>): (ret: uint64)
    ensures |pairs| == 0 ==> ret == 0
    ensures |pairs| != 0 ==> ret as nat == LinearLength(Seq.DropLast(pairs)) as nat + PairLength(Seq.Last(pairs)) as nat
    decreases pairs
  {
    if |pairs| == 0 then
      0
    else
      Add(LinearLength(Seq.DropLast(pairs)), PairLength(Seq.Last(pairs)))
  } by method {
    var result: uint64 := 0;
    SequenceIsSafeBecauseItIsInMemory(pairs);
    for i: uint64 := 0 to |pairs| as uint64
      invariant result == LinearLength(pairs[..i])
    {
      result := Add(result, PairLength(pairs[i]));
      assert result == LinearLength(pairs[..i]) + PairLength(pairs[i]);
      assert Seq.DropLast(pairs[..i + 1]) == pairs[..i];
      assert result == LinearLength(Seq.DropLast(pairs[..i + 1])) + PairLength(Seq.Last(pairs[..i + 1]));
      assert result == LinearLength(pairs[..i + 1]);
    }
    assert result == LinearLength(pairs[..|pairs|]);
    assert pairs == pairs[..|pairs|];
    assert result == LinearLength(pairs);
    return result;
  }

  function method PairLength(pair: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>): (ret: uint64)
    decreases pair
  {
    SequenceIsSafeBecauseItIsInMemory(pair.key);
    SequenceIsSafeBecauseItIsInMemory(pair.value);
    Add4(2, |pair.key| as uint64, 2, |pair.value| as uint64)
  }

  lemma /*{:_inductionTrigger Add(LinearLength(a), LinearLength(b))}*/ /*{:_inductionTrigger a + b}*/ /*{:_induction a, b}*/ LinearLengthIsDistributive(a: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>, b: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    ensures LinearLength(a + b) == Add(LinearLength(a), LinearLength(b))
    decreases a, b
  {
    if b == [] {
      assert a + b == a;
    } else {
      calc {
        LinearLength(a + b);
      ==
        if |a + b| == 0 then 0 else Add(LinearLength(Seq.DropLast(a + b)), PairLength(Seq.Last(a + b)));
      ==
        {
          assert |a + b| > 0;
        }
        Add(LinearLength(Seq.DropLast(a + b)), PairLength(Seq.Last(a + b)));
      ==
        {
          assert Seq.Last(a + b) == Seq.Last(b) && Seq.DropLast(a + b) == a + Seq.DropLast(b);
        }
        Add(LinearLength(a + Seq.DropLast(b)), PairLength(Seq.Last(b)));
      ==
        {
          LinearLengthIsDistributive(a, Seq.DropLast(b));
        }
        Add(Add(LinearLength(a), LinearLength(Seq.DropLast(b))), PairLength(Seq.Last(b)));
      ==
        Add(LinearLength(a), Add(LinearLength(Seq.DropLast(b)), PairLength(Seq.Last(b))));
      ==
        {
          assert LinearLength(Seq.DropLast(b)) + PairLength(Seq.Last(b)) == LinearLength(b);
        }
        Add(LinearLength(a), LinearLength(b));
      }
    }
  }

  import StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened MemoryMath = StandardLibrary.MemoryMath

  import MPL = AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyPrimitivesTypes

  import SortedSets

  import Seq

  type ShortUTF8Seq = s: ValidUTF8Bytes
    | HasUint16Len(s)

  datatype Pair<K, V> = Pair(key: K, value: V)

  type Linear<K, V> = seq<Pair<K, V>>

  type ESDKEncryptedDataKey = e: MPL.EncryptedDataKey
    | IsESDKEncryptedDataKey(e)
    witness *

  type ESDKEncryptedDataKeys = seq16<ESDKEncryptedDataKey>

  type ESDKEncryptionContext = ec: MPL.EncryptionContext
    | IsESDKEncryptionContext(ec)
    witness *
}

module {:extern "software.amazon.cryptography.encryptionsdk.internaldafny.types"} AwsCryptographyEncryptionSdkTypes {
  predicate method IsValid_CountingNumbers(x: int64)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_FrameLength(x: int64)
    decreases x
  {
    1 <= x <= 4294967296
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyMaterialProvidersTypes

  import AwsCryptographyPrimitivesTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  class IAwsEncryptionSdkClientCallHistory {
    ghost constructor ()
    {
      Encrypt := [];
      Decrypt := [];
    }

    ghost var Encrypt: seq<DafnyCallEvent<EncryptInput, Result<EncryptOutput, Error>>>
    ghost var Decrypt: seq<DafnyCallEvent<DecryptInput, Result<DecryptOutput, Error>>>
  }

  trait {:termination false} IAwsEncryptionSdkClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IAwsEncryptionSdkClientCallHistory

    predicate EncryptEnsuresPublicly(input: EncryptInput, output: Result<EncryptOutput, Error>)
      decreases input, output

    method Encrypt(input: EncryptInput) returns (output: Result<EncryptOutput, Error>)
      requires ValidState() && (input.materialsManager.Some? ==> input.materialsManager.value.ValidState() && input.materialsManager.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`Encrypt
      ensures true && ValidState()
      ensures EncryptEnsuresPublicly(input, output)
      ensures History.Encrypt == old(History.Encrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

    predicate DecryptEnsuresPublicly(input: DecryptInput, output: Result<DecryptOutput, Error>)
      decreases input, output

    method Decrypt(input: DecryptInput) returns (output: Result<DecryptOutput, Error>)
      requires ValidState() && (input.materialsManager.Some? ==> input.materialsManager.value.ValidState() && input.materialsManager.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`Decrypt
      ensures true && ValidState()
      ensures DecryptEnsuresPublicly(input, output)
      ensures History.Decrypt == old(History.Decrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
  }

  datatype AwsEncryptionSdkConfig = AwsEncryptionSdkConfig(nameonly commitmentPolicy: Option<AwsCryptographyMaterialProvidersTypes.ESDKCommitmentPolicy> := Option.None, nameonly maxEncryptedDataKeys: Option<CountingNumbers> := Option.None, nameonly netV4_0_0_RetryPolicy: Option<NetV4_0_0_RetryPolicy> := Option.None)

  type CountingNumbers = x: int64
    | IsValid_CountingNumbers(x)
    witness *

  datatype DecryptInput = DecryptInput(nameonly ciphertext: seq<uint8>, nameonly materialsManager: Option<AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager> := Option.None, nameonly keyring: Option<AwsCryptographyMaterialProvidersTypes.IKeyring> := Option.None, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None)

  datatype DecryptOutput = DecryptOutput(nameonly plaintext: seq<uint8>, nameonly encryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext, nameonly algorithmSuiteId: AwsCryptographyMaterialProvidersTypes.ESDKAlgorithmSuiteId)

  datatype EncryptInput = EncryptInput(nameonly plaintext: seq<uint8>, nameonly encryptionContext: Option<AwsCryptographyMaterialProvidersTypes.EncryptionContext> := Option.None, nameonly materialsManager: Option<AwsCryptographyMaterialProvidersTypes.ICryptographicMaterialsManager> := Option.None, nameonly keyring: Option<AwsCryptographyMaterialProvidersTypes.IKeyring> := Option.None, nameonly algorithmSuiteId: Option<AwsCryptographyMaterialProvidersTypes.ESDKAlgorithmSuiteId> := Option.None, nameonly frameLength: Option<FrameLength> := Option.None)

  datatype EncryptOutput = EncryptOutput(nameonly ciphertext: seq<uint8>, nameonly encryptionContext: AwsCryptographyMaterialProvidersTypes.EncryptionContext, nameonly algorithmSuiteId: AwsCryptographyMaterialProvidersTypes.ESDKAlgorithmSuiteId)

  type FrameLength = x: int64
    | IsValid_FrameLength(x)
    witness *

  datatype NetV4_0_0_RetryPolicy = FORBID_RETRY | ALLOW_RETRY

  datatype Error = AwsEncryptionSdkException(nameonly message: string) | AwsCryptographyMaterialProviders(AwsCryptographyMaterialProviders: AwsCryptographyMaterialProvidersTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyEncryptionSdkService {
  function method DefaultAwsEncryptionSdkConfig(): AwsEncryptionSdkConfig

  method ESDK(config: AwsEncryptionSdkConfig := DefaultAwsEncryptionSdkConfig()) returns (res: Result<ESDKClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IAwsEncryptionSdkClient): Result<IAwsEncryptionSdkClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IAwsEncryptionSdkClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyEncryptionSdkTypes

  import Operations : AbstractAwsCryptographyEncryptionSdkOperations

  class ESDKClient extends IAwsEncryptionSdkClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate EncryptEnsuresPublicly(input: EncryptInput, output: Result<EncryptOutput, Error>)
      decreases input, output
    {
      Operations.EncryptEnsuresPublicly(input, output)
    }

    method Encrypt(input: EncryptInput) returns (output: Result<EncryptOutput, Error>)
      requires ValidState() && (input.materialsManager.Some? ==> input.materialsManager.value.ValidState() && input.materialsManager.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`Encrypt
      ensures true && ValidState()
      ensures EncryptEnsuresPublicly(input, output)
      ensures History.Encrypt == old(History.Encrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.Encrypt(config, input);
      History.Encrypt := History.Encrypt + [DafnyCallEvent(input, output)];
    }

    predicate DecryptEnsuresPublicly(input: DecryptInput, output: Result<DecryptOutput, Error>)
      decreases input, output
    {
      Operations.DecryptEnsuresPublicly(input, output)
    }

    method Decrypt(input: DecryptInput) returns (output: Result<DecryptOutput, Error>)
      requires ValidState() && (input.materialsManager.Some? ==> input.materialsManager.value.ValidState() && input.materialsManager.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`Decrypt
      ensures true && ValidState()
      ensures DecryptEnsuresPublicly(input, output)
      ensures History.Decrypt == old(History.Decrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.Decrypt(config, input);
      History.Decrypt := History.Decrypt + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyEncryptionSdkOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate EncryptEnsuresPublicly(input: EncryptInput, output: Result<EncryptOutput, Error>)
    decreases input, output

  method Encrypt(config: InternalConfig, input: EncryptInput) returns (output: Result<EncryptOutput, Error>)
    requires ValidInternalConfig?(config) && (input.materialsManager.Some? ==> true && input.materialsManager.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures true && ValidInternalConfig?(config)
    ensures EncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

  predicate DecryptEnsuresPublicly(input: DecryptInput, output: Result<DecryptOutput, Error>)
    decreases input, output

  method Decrypt(config: InternalConfig, input: DecryptInput) returns (output: Result<DecryptOutput, Error>)
    requires ValidInternalConfig?(config) && (input.materialsManager.Some? ==> true && input.materialsManager.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures true && ValidInternalConfig?(config)
    ensures DecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.materialsManager.Some? then input.materialsManager.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyEncryptionSdkTypes

  type InternalConfig
}

module {:extern "software.amazon.cryptography.primitives.internaldafny"} AtomicPrimitives refines AbstractAwsCryptographyPrimitivesService {
  function method DefaultCryptoConfig(): CryptoConfig
  {
    CryptoConfig
  }

  method AtomicPrimitives(config: CryptoConfig := DefaultCryptoConfig()) returns (res: Result<AtomicPrimitivesClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    ensures res.Success? ==> true && res.value is AtomicPrimitivesClient
    decreases config
  {
    var client := new AtomicPrimitivesClient(Operations.Config);
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IAwsCryptographicPrimitivesClient): Result<IAwsCryptographicPrimitivesClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IAwsCryptographicPrimitivesClient, Error>
    decreases error
  {
    Failure(error)
  }

  import Operations = AwsCryptographyPrimitivesOperations

  class AtomicPrimitivesClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IAwsCryptographicPrimitivesClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate GenerateRandomBytesEnsuresPublicly(input: GenerateRandomBytesInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.GenerateRandomBytesEnsuresPublicly(input, output)
    }

    method GenerateRandomBytes(input: GenerateRandomBytesInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRandomBytes
      ensures true && ValidState()
      ensures GenerateRandomBytesEnsuresPublicly(input, output)
      ensures History.GenerateRandomBytes == old(History.GenerateRandomBytes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateRandomBytes(config, input);
      History.GenerateRandomBytes := History.GenerateRandomBytes + [DafnyCallEvent(input, output)];
    }

    predicate DigestEnsuresPublicly(input: DigestInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.DigestEnsuresPublicly(input, output)
    }

    method Digest(input: DigestInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Digest
      ensures true && ValidState()
      ensures DigestEnsuresPublicly(input, output)
      ensures History.Digest == old(History.Digest) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.Digest(config, input);
      History.Digest := History.Digest + [DafnyCallEvent(input, output)];
    }

    function method HMac(input: HMacInput): (output: Result<seq<uint8>, Error>)
      decreases input
    {
      Operations.HMac(config, input)
    }

    predicate HkdfExtractEnsuresPublicly(input: HkdfExtractInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfExtractEnsuresPublicly(input, output)
    }

    method HkdfExtract(input: HkdfExtractInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExtract
      ensures true && ValidState()
      ensures HkdfExtractEnsuresPublicly(input, output)
      ensures History.HkdfExtract == old(History.HkdfExtract) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.HkdfExtract(config, input);
      History.HkdfExtract := History.HkdfExtract + [DafnyCallEvent(input, output)];
    }

    predicate HkdfExpandEnsuresPublicly(input: HkdfExpandInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfExpandEnsuresPublicly(input, output)
    }

    method HkdfExpand(input: HkdfExpandInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExpand
      ensures true && ValidState()
      ensures HkdfExpandEnsuresPublicly(input, output)
      ensures History.HkdfExpand == old(History.HkdfExpand) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.HkdfExpand(config, input);
      History.HkdfExpand := History.HkdfExpand + [DafnyCallEvent(input, output)];
    }

    predicate HkdfEnsuresPublicly(input: HkdfInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfEnsuresPublicly(input, output)
    }

    method Hkdf(input: HkdfInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Hkdf
      ensures true && ValidState()
      ensures HkdfEnsuresPublicly(input, output)
      ensures History.Hkdf == old(History.Hkdf) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.Hkdf(config, input);
      History.Hkdf := History.Hkdf + [DafnyCallEvent(input, output)];
    }

    predicate KdfCounterModeEnsuresPublicly(input: KdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.KdfCounterModeEnsuresPublicly(input, output)
    }

    method KdfCounterMode(input: KdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`KdfCounterMode
      ensures true && ValidState()
      ensures KdfCounterModeEnsuresPublicly(input, output)
      ensures History.KdfCounterMode == old(History.KdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.KdfCounterMode(config, input);
      History.KdfCounterMode := History.KdfCounterMode + [DafnyCallEvent(input, output)];
    }

    predicate AesKdfCounterModeEnsuresPublicly(input: AesKdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.AesKdfCounterModeEnsuresPublicly(input, output)
    }

    method AesKdfCounterMode(input: AesKdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AesKdfCounterMode
      ensures true && ValidState()
      ensures AesKdfCounterModeEnsuresPublicly(input, output)
      ensures History.AesKdfCounterMode == old(History.AesKdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AesKdfCounterMode(config, input);
      History.AesKdfCounterMode := History.AesKdfCounterMode + [DafnyCallEvent(input, output)];
    }

    predicate AESEncryptEnsuresPublicly(input: AESEncryptInput, output: Result<AESEncryptOutput, Error>)
      decreases input, output
    {
      Operations.AESEncryptEnsuresPublicly(input, output)
    }

    method AESEncrypt(input: AESEncryptInput) returns (output: Result<AESEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESEncrypt
      ensures true && ValidState()
      ensures AESEncryptEnsuresPublicly(input, output)
      ensures History.AESEncrypt == old(History.AESEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AESEncrypt(config, input);
      History.AESEncrypt := History.AESEncrypt + [DafnyCallEvent(input, output)];
    }

    predicate AESDecryptEnsuresPublicly(input: AESDecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.AESDecryptEnsuresPublicly(input, output)
    }

    method AESDecrypt(input: AESDecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESDecrypt
      ensures true && ValidState()
      ensures AESDecryptEnsuresPublicly(input, output)
      ensures History.AESDecrypt == old(History.AESDecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AESDecrypt(config, input);
      History.AESDecrypt := History.AESDecrypt + [DafnyCallEvent(input, output)];
    }

    predicate GenerateRSAKeyPairEnsuresPublicly(input: GenerateRSAKeyPairInput, output: Result<GenerateRSAKeyPairOutput, Error>)
      decreases input, output
    {
      Operations.GenerateRSAKeyPairEnsuresPublicly(input, output)
    }

    method GenerateRSAKeyPair(input: GenerateRSAKeyPairInput) returns (output: Result<GenerateRSAKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRSAKeyPair
      ensures true && ValidState()
      ensures GenerateRSAKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateRSAKeyPair == old(History.GenerateRSAKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateRSAKeyPair(config, input);
      History.GenerateRSAKeyPair := History.GenerateRSAKeyPair + [DafnyCallEvent(input, output)];
    }

    function method GetRSAKeyModulusLength(input: GetRSAKeyModulusLengthInput): (output: Result<GetRSAKeyModulusLengthOutput, Error>)
      decreases input
    {
      Operations.GetRSAKeyModulusLength(config, input)
    }

    predicate RSADecryptEnsuresPublicly(input: RSADecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.RSADecryptEnsuresPublicly(input, output)
    }

    method RSADecrypt(input: RSADecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSADecrypt
      ensures true && ValidState()
      ensures RSADecryptEnsuresPublicly(input, output)
      ensures History.RSADecrypt == old(History.RSADecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.RSADecrypt(config, input);
      History.RSADecrypt := History.RSADecrypt + [DafnyCallEvent(input, output)];
    }

    predicate RSAEncryptEnsuresPublicly(input: RSAEncryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.RSAEncryptEnsuresPublicly(input, output)
    }

    method RSAEncrypt(input: RSAEncryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSAEncrypt
      ensures true && ValidState()
      ensures RSAEncryptEnsuresPublicly(input, output)
      ensures History.RSAEncrypt == old(History.RSAEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.RSAEncrypt(config, input);
      History.RSAEncrypt := History.RSAEncrypt + [DafnyCallEvent(input, output)];
    }

    predicate GenerateECDSASignatureKeyEnsuresPublicly(input: GenerateECDSASignatureKeyInput, output: Result<GenerateECDSASignatureKeyOutput, Error>)
      decreases input, output
    {
      Operations.GenerateECDSASignatureKeyEnsuresPublicly(input, output)
    }

    method GenerateECDSASignatureKey(input: GenerateECDSASignatureKeyInput) returns (output: Result<GenerateECDSASignatureKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECDSASignatureKey
      ensures true && ValidState()
      ensures GenerateECDSASignatureKeyEnsuresPublicly(input, output)
      ensures History.GenerateECDSASignatureKey == old(History.GenerateECDSASignatureKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateECDSASignatureKey(config, input);
      History.GenerateECDSASignatureKey := History.GenerateECDSASignatureKey + [DafnyCallEvent(input, output)];
    }

    predicate ECDSASignEnsuresPublicly(input: ECDSASignInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.ECDSASignEnsuresPublicly(input, output)
    }

    method ECDSASign(input: ECDSASignInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSASign
      ensures true && ValidState()
      ensures ECDSASignEnsuresPublicly(input, output)
      ensures History.ECDSASign == old(History.ECDSASign) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ECDSASign(config, input);
      History.ECDSASign := History.ECDSASign + [DafnyCallEvent(input, output)];
    }

    predicate ECDSAVerifyEnsuresPublicly(input: ECDSAVerifyInput, output: Result<bool, Error>)
      decreases input, output
    {
      Operations.ECDSAVerifyEnsuresPublicly(input, output)
    }

    method ECDSAVerify(input: ECDSAVerifyInput) returns (output: Result<bool, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSAVerify
      ensures true && ValidState()
      ensures ECDSAVerifyEnsuresPublicly(input, output)
      ensures History.ECDSAVerify == old(History.ECDSAVerify) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ECDSAVerify(config, input);
      History.ECDSAVerify := History.ECDSAVerify + [DafnyCallEvent(input, output)];
    }

    predicate GenerateECCKeyPairEnsuresPublicly(input: GenerateECCKeyPairInput, output: Result<GenerateECCKeyPairOutput, Error>)
      decreases input, output
    {
      Operations.GenerateECCKeyPairEnsuresPublicly(input, output)
    }

    method GenerateECCKeyPair(input: GenerateECCKeyPairInput) returns (output: Result<GenerateECCKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECCKeyPair
      ensures true && ValidState()
      ensures GenerateECCKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateECCKeyPair == old(History.GenerateECCKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateECCKeyPair(config, input);
      History.GenerateECCKeyPair := History.GenerateECCKeyPair + [DafnyCallEvent(input, output)];
    }

    predicate GetPublicKeyFromPrivateKeyEnsuresPublicly(input: GetPublicKeyFromPrivateKeyInput, output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
    }

    method GetPublicKeyFromPrivateKey(input: GetPublicKeyFromPrivateKeyInput) returns (output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetPublicKeyFromPrivateKey
      ensures true && ValidState()
      ensures GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
      ensures History.GetPublicKeyFromPrivateKey == old(History.GetPublicKeyFromPrivateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetPublicKeyFromPrivateKey(config, input);
      History.GetPublicKeyFromPrivateKey := History.GetPublicKeyFromPrivateKey + [DafnyCallEvent(input, output)];
    }

    predicate ValidatePublicKeyEnsuresPublicly(input: ValidatePublicKeyInput, output: Result<ValidatePublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.ValidatePublicKeyEnsuresPublicly(input, output)
    }

    method ValidatePublicKey(input: ValidatePublicKeyInput) returns (output: Result<ValidatePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ValidatePublicKey
      ensures true && ValidState()
      ensures ValidatePublicKeyEnsuresPublicly(input, output)
      ensures History.ValidatePublicKey == old(History.ValidatePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ValidatePublicKey(config, input);
      History.ValidatePublicKey := History.ValidatePublicKey + [DafnyCallEvent(input, output)];
    }

    predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretInput, output: Result<DeriveSharedSecretOutput, Error>)
      decreases input, output
    {
      Operations.DeriveSharedSecretEnsuresPublicly(input, output)
    }

    method DeriveSharedSecret(input: DeriveSharedSecretInput) returns (output: Result<DeriveSharedSecretOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeriveSharedSecret
      ensures true && ValidState()
      ensures DeriveSharedSecretEnsuresPublicly(input, output)
      ensures History.DeriveSharedSecret == old(History.DeriveSharedSecret) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeriveSharedSecret(config, input);
      History.DeriveSharedSecret := History.DeriveSharedSecret + [DafnyCallEvent(input, output)];
    }

    predicate CompressPublicKeyEnsuresPublicly(input: CompressPublicKeyInput, output: Result<CompressPublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.CompressPublicKeyEnsuresPublicly(input, output)
    }

    method CompressPublicKey(input: CompressPublicKeyInput) returns (output: Result<CompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CompressPublicKey
      ensures true && ValidState()
      ensures CompressPublicKeyEnsuresPublicly(input, output)
      ensures History.CompressPublicKey == old(History.CompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CompressPublicKey(config, input);
      History.CompressPublicKey := History.CompressPublicKey + [DafnyCallEvent(input, output)];
    }

    predicate DecompressPublicKeyEnsuresPublicly(input: DecompressPublicKeyInput, output: Result<DecompressPublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.DecompressPublicKeyEnsuresPublicly(input, output)
    }

    method DecompressPublicKey(input: DecompressPublicKeyInput) returns (output: Result<DecompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecompressPublicKey
      ensures true && ValidState()
      ensures DecompressPublicKeyEnsuresPublicly(input, output)
      ensures History.DecompressPublicKey == old(History.DecompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DecompressPublicKey(config, input);
      History.DecompressPublicKey := History.DecompressPublicKey + [DafnyCallEvent(input, output)];
    }

    predicate ParsePublicKeyEnsuresPublicly(input: ParsePublicKeyInput, output: Result<ParsePublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.ParsePublicKeyEnsuresPublicly(input, output)
    }

    method ParsePublicKey(input: ParsePublicKeyInput) returns (output: Result<ParsePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ParsePublicKey
      ensures true && ValidState()
      ensures ParsePublicKeyEnsuresPublicly(input, output)
      ensures History.ParsePublicKey == old(History.ParsePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ParsePublicKey(config, input);
      History.ParsePublicKey := History.ParsePublicKey + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyPrimitivesTypes
}

module AwsCryptographyPrimitivesOperations refines AbstractAwsCryptographyPrimitivesOperations {
  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    true
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    {}
  }

  predicate GenerateRandomBytesEnsuresPublicly(input: GenerateRandomBytesInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      |output.value| == input.length as int
  }

  method GenerateRandomBytes(config: InternalConfig, input: GenerateRandomBytesInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateRandomBytesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := Random.GenerateBytes(input.length);
  }

  predicate DigestEnsuresPublicly(input: DigestInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      |output.value| == D.Length(input.digestAlgorithm) as nat
  }

  method Digest(config: InternalConfig, input: DigestInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DigestEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := D.Digest(input);
  }

  predicate HMacEnsuresPublicly(input: HMacInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true
  }

  function method HMac(config: InternalConfig, input: HMacInput): (output: Result<seq<uint8>, Error>)
    decreases input
  {
    WrappedHMAC.Digest(input)
  }

  predicate HkdfExtractEnsuresPublicly(input: HkdfExtractInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true
  }

  method HkdfExtract(config: InternalConfig, input: HkdfExtractInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfExtractEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := WrappedHKDF.Extract(input);
  }

  predicate HkdfExpandEnsuresPublicly(input: HkdfExpandInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      |output.value| == input.expectedLength as nat
  }

  method HkdfExpand(config: InternalConfig, input: HkdfExpandInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfExpandEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := WrappedHKDF.Expand(input);
  }

  predicate HkdfEnsuresPublicly(input: HkdfInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      |output.value| == input.expectedLength as nat
  }

  method Hkdf(config: InternalConfig, input: HkdfInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := WrappedHKDF.Hkdf(input);
  }

  predicate KdfCounterModeEnsuresPublicly(input: KdfCtrInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      |output.value| == input.expectedLength as nat
  }

  method KdfCounterMode(config: InternalConfig, input: KdfCtrInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures KdfCounterModeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := KdfCtr.KdfCounterMode(input);
  }

  predicate AesKdfCounterModeEnsuresPublicly(input: AesKdfCtrInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    output.Success? ==>
      true &&
      |output.value| == input.expectedLength as nat
  }

  method AesKdfCounterMode(config: InternalConfig, input: AesKdfCtrInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AesKdfCounterModeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := Failure(Types.AwsCryptographicPrimitivesError(message := "Implement"));
  }

  predicate AESEncryptEnsuresPublicly(input: AESEncryptInput, output: Result<AESEncryptOutput, Error>)
    decreases input, output
  {
    true &&
    output.Success? ==>
      |output.value.cipherText| == |input.msg| &&
      |output.value.authTag| == input.encAlg.tagLength as nat
  }

  method AESEncrypt(config: InternalConfig, input: AESEncryptInput) returns (output: Result<AESEncryptOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AESEncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := AESEncryption.AESEncrypt(input);
  }

  predicate AESDecryptEnsuresPublicly(input: AESDecryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true &&
    output.Success? ==>
      true &&
      |output.value| == |input.cipherTxt|
  }

  method AESDecrypt(config: InternalConfig, input: AESDecryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AESDecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := AESEncryption.AESDecrypt(input);
  }

  predicate GenerateRSAKeyPairEnsuresPublicly(input: GenerateRSAKeyPairInput, output: Result<GenerateRSAKeyPairOutput, Error>)
    decreases input, output
  {
    true
  }

  method GenerateRSAKeyPair(config: InternalConfig, input: GenerateRSAKeyPairInput) returns (output: Result<GenerateRSAKeyPairOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateRSAKeyPairEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    var publicKey, privateKey := RSAEncryption.GenerateKeyPair(input.lengthBits);
    output := Success(GenerateRSAKeyPairOutput(publicKey := publicKey, privateKey := privateKey));
  }

  predicate GetRSAKeyModulusLengthEnsuresPublicly(input: GetRSAKeyModulusLengthInput, output: Result<GetRSAKeyModulusLengthOutput, Error>)
    decreases input, output
  {
    true
  }

  function method GetRSAKeyModulusLength(config: InternalConfig, input: GetRSAKeyModulusLengthInput): (output: Result<GetRSAKeyModulusLengthOutput, Error>)
    decreases input
  {
    var length: Types.RSAModulusLengthBits :- RSAEncryption.GetRSAKeyModulusLength(input.publicKey); Success(GetRSAKeyModulusLengthOutput(length := length))
  }

  predicate RSADecryptEnsuresPublicly(input: RSADecryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true
  }

  method RSADecrypt(config: InternalConfig, input: RSADecryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RSADecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := RSAEncryption.Decrypt(input);
  }

  predicate RSAEncryptEnsuresPublicly(input: RSAEncryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true
  }

  method RSAEncrypt(config: InternalConfig, input: RSAEncryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RSAEncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := RSAEncryption.Encrypt(input);
  }

  predicate GenerateECDSASignatureKeyEnsuresPublicly(input: GenerateECDSASignatureKeyInput, output: Result<GenerateECDSASignatureKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GenerateECDSASignatureKey(config: InternalConfig, input: GenerateECDSASignatureKeyInput) returns (output: Result<GenerateECDSASignatureKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateECDSASignatureKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := Signature.KeyGen(input);
  }

  predicate ECDSASignEnsuresPublicly(input: ECDSASignInput, output: Result<seq<uint8>, Error>)
    decreases input, output
  {
    true
  }

  method ECDSASign(config: InternalConfig, input: ECDSASignInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ECDSASignEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := Signature.Sign(input.signatureAlgorithm, input.signingKey, input.message);
  }

  predicate ECDSAVerifyEnsuresPublicly(input: ECDSAVerifyInput, output: Result<bool, Error>)
    decreases input, output
  {
    true
  }

  method ECDSAVerify(config: InternalConfig, input: ECDSAVerifyInput) returns (output: Result<bool, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ECDSAVerifyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := Signature.Verify(input.signatureAlgorithm, input.verificationKey, input.message, input.signature);
  }

  predicate GenerateECCKeyPairEnsuresPublicly(input: GenerateECCKeyPairInput, output: Result<GenerateECCKeyPairOutput, Error>)
    decreases input, output
  {
    true
  }

  method GenerateECCKeyPair(config: InternalConfig, input: GenerateECCKeyPairInput) returns (output: Result<GenerateECCKeyPairOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateECCKeyPairEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.GenerateEccKeyPair(input);
  }

  predicate GetPublicKeyFromPrivateKeyEnsuresPublicly(input: GetPublicKeyFromPrivateKeyInput, output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetPublicKeyFromPrivateKey(config: InternalConfig, input: GetPublicKeyFromPrivateKeyInput) returns (output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.GetPublicKeyFromPrivate(input);
  }

  predicate ValidatePublicKeyEnsuresPublicly(input: ValidatePublicKeyInput, output: Result<ValidatePublicKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method ValidatePublicKey(config: InternalConfig, input: ValidatePublicKeyInput) returns (output: Result<ValidatePublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ValidatePublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.ValidatePublicKey(input);
  }

  predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretInput, output: Result<DeriveSharedSecretOutput, Error>)
    decreases input, output
  {
    true
  }

  method DeriveSharedSecret(config: InternalConfig, input: DeriveSharedSecretInput) returns (output: Result<DeriveSharedSecretOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeriveSharedSecretEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.DeriveSharedSecret(input);
  }

  predicate CompressPublicKeyEnsuresPublicly(input: CompressPublicKeyInput, output: Result<CompressPublicKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method CompressPublicKey(config: InternalConfig, input: CompressPublicKeyInput) returns (output: Result<CompressPublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CompressPublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.CompressPublicKey(input);
  }

  predicate DecompressPublicKeyEnsuresPublicly(input: DecompressPublicKeyInput, output: Result<DecompressPublicKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method DecompressPublicKey(config: InternalConfig, input: DecompressPublicKeyInput) returns (output: Result<DecompressPublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DecompressPublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.DecompressPublicKey(input);
  }

  predicate ParsePublicKeyEnsuresPublicly(input: ParsePublicKeyInput, output: Result<ParsePublicKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method ParsePublicKey(config: InternalConfig, input: ParsePublicKeyInput) returns (output: Result<ParsePublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ParsePublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := ECDH.ParsePublicKey(input);
  }

  import Random

  import AESEncryption

  import D = Digest

  import WrappedHMAC

  import WrappedHKDF

  import Signature

  import KdfCtr

  import RSAEncryption

  import ECDH

  datatype Config = Config

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyPrimitivesTypes
}

module {:extern "ECDH"} ECDH {
  method GenerateEccKeyPair(input: Types.GenerateECCKeyPairInput) returns (output: Result<Types.GenerateECCKeyPairOutput, Types.Error>)
    decreases input
  {
    var keyPair :- ExternEccKeyGen(input.eccCurve);
    return Success(Types.GenerateECCKeyPairOutput(eccCurve := input.eccCurve, privateKey := Types.ECCPrivateKey(pem := keyPair.privateKey), publicKey := Types.ECCPublicKey(der := keyPair.publicKey)));
  }

  method GetPublicKeyFromPrivate(input: Types.GetPublicKeyFromPrivateKeyInput) returns (output: Result<Types.GetPublicKeyFromPrivateKeyOutput, Types.Error>)
    decreases input
  {
    var publicKey :- ExternGetPublicKeyFromPrivate(input.eccCurve, input.privateKey);
    return Success(Types.GetPublicKeyFromPrivateKeyOutput(eccCurve := input.eccCurve, privateKey := input.privateKey, publicKey := publicKey));
  }

  method ValidatePublicKey(input: Types.ValidatePublicKeyInput) returns (output: Result<Types.ValidatePublicKeyOutput, Types.Error>)
    decreases input
  {
    var result :- ExternValidatePublicKey(input.eccCurve, input.publicKey);
    return Success(Types.ValidatePublicKeyOutput(success := result));
  }

  method DeriveSharedSecret(input: Types.DeriveSharedSecretInput) returns (output: Result<Types.DeriveSharedSecretOutput, Types.Error>)
    decreases input
  {
    var derivedSharedSecret :- ExternDeriveSharedSecret(input.eccCurve, input.privateKey, input.publicKey);
    return Success(Types.DeriveSharedSecretOutput(sharedSecret := derivedSharedSecret));
  }

  method CompressPublicKey(input: Types.CompressPublicKeyInput) returns (output: Result<Types.CompressPublicKeyOutput, Types.Error>)
    decreases input
  {
    var compressedPublicKey :- ExternCompressPublicKey(input.publicKey.der, input.eccCurve);
    return Success(Types.CompressPublicKeyOutput(compressedPublicKey := compressedPublicKey));
  }

  method DecompressPublicKey(input: Types.DecompressPublicKeyInput) returns (output: Result<Types.DecompressPublicKeyOutput, Types.Error>)
    decreases input
  {
    var decompressedPublicKey :- ExternDecompressPublicKey(input.compressedPublicKey, input.eccCurve);
    return Success(Types.DecompressPublicKeyOutput(publicKey := Types.ECCPublicKey(der := decompressedPublicKey)));
  }

  method ParsePublicKey(input: Types.ParsePublicKeyInput) returns (output: Result<Types.ParsePublicKeyOutput, Types.Error>)
    decreases input
  {
    var derPublicKey :- ExternParsePublicKey(input.publicKey);
    return Success(Types.ParsePublicKeyOutput(publicKey := Types.ECCPublicKey(der := derPublicKey)));
  }

  method {:extern "ECDH.KeyGeneration", "GenerateKeyPair"} ExternEccKeyGen(s: Types.ECDHCurveSpec) returns (res: Result<EccKeyPair, Types.Error>)
    ensures res.Success? ==> 1 < |res.value.publicKey| <= 8192
    decreases s

  method {:extern "ECDH.ECCUtils", "GetPublicKey"} ExternGetPublicKeyFromPrivate(curveAlgorithm: Types.ECDHCurveSpec, privateKey: Types.ECCPrivateKey) returns (res: Result<seq<uint8>, Types.Error>)
    decreases curveAlgorithm, privateKey

  method {:extern "ECDH.ECCUtils", "ValidatePublicKey"} ExternValidatePublicKey(curveAlgorithm: Types.ECDHCurveSpec, publicKey: seq<uint8>) returns (res: Result<bool, Types.Error>)
    decreases curveAlgorithm, publicKey

  method {:extern "ECDH.DeriveSharedSecret", "CalculateSharedSecret"} ExternDeriveSharedSecret(curveAlgorithm: Types.ECDHCurveSpec, privateKey: Types.ECCPrivateKey, publicKey: Types.ECCPublicKey)
      returns (res: Result<seq<uint8>, Types.Error>)
    decreases curveAlgorithm, privateKey, publicKey

  method {:extern "ECDH.ECCUtils", "CompressPublicKey"} ExternCompressPublicKey(publicKey: seq<uint8>, curveAlgorithm: Types.ECDHCurveSpec) returns (res: Result<seq<uint8>, Types.Error>)
    decreases publicKey, curveAlgorithm

  method {:extern "ECDH.ECCUtils", "DecompressPublicKey"} ExternDecompressPublicKey(publicKey: seq<uint8>, curveAlgorithm: Types.ECDHCurveSpec) returns (res: Result<seq<uint8>, Types.Error>)
    decreases publicKey, curveAlgorithm

  method {:extern "ECDH.ECCUtils", "ParsePublicKey"} ExternParsePublicKey(publicKey: seq<uint8>) returns (res: Result<seq<uint8>, Types.Error>)
    decreases publicKey

  function method CreateExternEccKeyGenSuccess(output: EccKeyPair): Result<EccKeyPair, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternEccKeyGenFailure(error: Types.Error): Result<EccKeyPair, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternGetPublicKeyFromPrivateSuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternGetPublicKeyFromPrivateError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternValidatePublicKeySuccess(output: bool): Result<bool, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternValidatePublicKeyError(error: Types.Error): Result<bool, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternDerivesharedSecretSuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternDerivesharedSecretError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternCompressPublicKeyError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternCompressPublicKeySuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternDecompressPublicKeyError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternDecompressPublicKeySuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternParsePublicKeyError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateExternParsePublicKeySuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateGetInfinityPublicKeyError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateGetInfinityPublicKeySuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateGetOutOfBoundsPublicKeyError(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateGetOutOfBoundsPublicKeySuccess(output: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases output
  {
    Success(output)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyPrimitivesTypes

  datatype EccKeyPair = EccKeyPair(privateKey: seq<uint8>, publicKey: seq<uint8>)
}

module {:extern "software.amazon.cryptography.primitives.internaldafny.types"} AwsCryptographyPrimitivesTypes {
  predicate method IsValid_PositiveInteger(x: int32)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_RSAModulusLengthBits(x: int32)
    decreases x
  {
    81 <= x
  }

  predicate method IsValid_RSAModulusLengthBitsToGenerate(x: int32)
    decreases x
  {
    81 <= x <= 4096
  }

  predicate method IsValid_SymmetricKeyLength(x: int32)
    decreases x
  {
    1 <= x <= 32
  }

  predicate method IsValid_Uint8Bits(x: int32)
    decreases x
  {
    0 <= x <= 255
  }

  predicate method IsValid_Uint8Bytes(x: int32)
    decreases x
  {
    0 <= x <= 32
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype AES_CTR = AES_CTR(nameonly keyLength: SymmetricKeyLength, nameonly nonceLength: Uint8Bits)

  datatype AES_GCM = AES_GCM(nameonly keyLength: SymmetricKeyLength, nameonly tagLength: Uint8Bytes, nameonly ivLength: Uint8Bits)

  datatype AESDecryptInput = AESDecryptInput(nameonly encAlg: AES_GCM, nameonly key: seq<uint8>, nameonly cipherTxt: seq<uint8>, nameonly authTag: seq<uint8>, nameonly iv: seq<uint8>, nameonly aad: seq<uint8>)

  datatype AESEncryptInput = AESEncryptInput(nameonly encAlg: AES_GCM, nameonly iv: seq<uint8>, nameonly key: seq<uint8>, nameonly msg: seq<uint8>, nameonly aad: seq<uint8>)

  datatype AESEncryptOutput = AESEncryptOutput(nameonly cipherText: seq<uint8>, nameonly authTag: seq<uint8>)

  datatype AesKdfCtrInput = AesKdfCtrInput(nameonly ikm: seq<uint8>, nameonly expectedLength: PositiveInteger, nameonly nonce: Option<seq<uint8>> := Option.None)

  class IAwsCryptographicPrimitivesClientCallHistory {
    ghost constructor ()
    {
      GenerateRandomBytes := [];
      Digest := [];
      HMac := [];
      HkdfExtract := [];
      HkdfExpand := [];
      Hkdf := [];
      KdfCounterMode := [];
      AesKdfCounterMode := [];
      AESEncrypt := [];
      AESDecrypt := [];
      GenerateRSAKeyPair := [];
      GetRSAKeyModulusLength := [];
      RSADecrypt := [];
      RSAEncrypt := [];
      GenerateECDSASignatureKey := [];
      ECDSASign := [];
      ECDSAVerify := [];
      GenerateECCKeyPair := [];
      GetPublicKeyFromPrivateKey := [];
      ValidatePublicKey := [];
      DeriveSharedSecret := [];
      CompressPublicKey := [];
      DecompressPublicKey := [];
      ParsePublicKey := [];
    }

    ghost var GenerateRandomBytes: seq<DafnyCallEvent<GenerateRandomBytesInput, Result<seq<uint8>, Error>>>
    ghost var Digest: seq<DafnyCallEvent<DigestInput, Result<seq<uint8>, Error>>>
    ghost var HMac: seq<DafnyCallEvent<HMacInput, Result<seq<uint8>, Error>>>
    ghost var HkdfExtract: seq<DafnyCallEvent<HkdfExtractInput, Result<seq<uint8>, Error>>>
    ghost var HkdfExpand: seq<DafnyCallEvent<HkdfExpandInput, Result<seq<uint8>, Error>>>
    ghost var Hkdf: seq<DafnyCallEvent<HkdfInput, Result<seq<uint8>, Error>>>
    ghost var KdfCounterMode: seq<DafnyCallEvent<KdfCtrInput, Result<seq<uint8>, Error>>>
    ghost var AesKdfCounterMode: seq<DafnyCallEvent<AesKdfCtrInput, Result<seq<uint8>, Error>>>
    ghost var AESEncrypt: seq<DafnyCallEvent<AESEncryptInput, Result<AESEncryptOutput, Error>>>
    ghost var AESDecrypt: seq<DafnyCallEvent<AESDecryptInput, Result<seq<uint8>, Error>>>
    ghost var GenerateRSAKeyPair: seq<DafnyCallEvent<GenerateRSAKeyPairInput, Result<GenerateRSAKeyPairOutput, Error>>>
    ghost var GetRSAKeyModulusLength: seq<DafnyCallEvent<GetRSAKeyModulusLengthInput, Result<GetRSAKeyModulusLengthOutput, Error>>>
    ghost var RSADecrypt: seq<DafnyCallEvent<RSADecryptInput, Result<seq<uint8>, Error>>>
    ghost var RSAEncrypt: seq<DafnyCallEvent<RSAEncryptInput, Result<seq<uint8>, Error>>>
    ghost var GenerateECDSASignatureKey: seq<DafnyCallEvent<GenerateECDSASignatureKeyInput, Result<GenerateECDSASignatureKeyOutput, Error>>>
    ghost var ECDSASign: seq<DafnyCallEvent<ECDSASignInput, Result<seq<uint8>, Error>>>
    ghost var ECDSAVerify: seq<DafnyCallEvent<ECDSAVerifyInput, Result<bool, Error>>>
    ghost var GenerateECCKeyPair: seq<DafnyCallEvent<GenerateECCKeyPairInput, Result<GenerateECCKeyPairOutput, Error>>>
    ghost var GetPublicKeyFromPrivateKey: seq<DafnyCallEvent<GetPublicKeyFromPrivateKeyInput, Result<GetPublicKeyFromPrivateKeyOutput, Error>>>
    ghost var ValidatePublicKey: seq<DafnyCallEvent<ValidatePublicKeyInput, Result<ValidatePublicKeyOutput, Error>>>
    ghost var DeriveSharedSecret: seq<DafnyCallEvent<DeriveSharedSecretInput, Result<DeriveSharedSecretOutput, Error>>>
    ghost var CompressPublicKey: seq<DafnyCallEvent<CompressPublicKeyInput, Result<CompressPublicKeyOutput, Error>>>
    ghost var DecompressPublicKey: seq<DafnyCallEvent<DecompressPublicKeyInput, Result<DecompressPublicKeyOutput, Error>>>
    ghost var ParsePublicKey: seq<DafnyCallEvent<ParsePublicKeyInput, Result<ParsePublicKeyOutput, Error>>>
  }

  trait {:termination false} IAwsCryptographicPrimitivesClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IAwsCryptographicPrimitivesClientCallHistory

    predicate GenerateRandomBytesEnsuresPublicly(input: GenerateRandomBytesInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method GenerateRandomBytes(input: GenerateRandomBytesInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRandomBytes
      ensures true && ValidState()
      ensures GenerateRandomBytesEnsuresPublicly(input, output)
      ensures History.GenerateRandomBytes == old(History.GenerateRandomBytes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DigestEnsuresPublicly(input: DigestInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method Digest(input: DigestInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Digest
      ensures true && ValidState()
      ensures DigestEnsuresPublicly(input, output)
      ensures History.Digest == old(History.Digest) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    function method HMac(input: HMacInput): (output: Result<seq<uint8>, Error>)
      decreases input

    predicate HkdfExtractEnsuresPublicly(input: HkdfExtractInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method HkdfExtract(input: HkdfExtractInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExtract
      ensures true && ValidState()
      ensures HkdfExtractEnsuresPublicly(input, output)
      ensures History.HkdfExtract == old(History.HkdfExtract) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate HkdfExpandEnsuresPublicly(input: HkdfExpandInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method HkdfExpand(input: HkdfExpandInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExpand
      ensures true && ValidState()
      ensures HkdfExpandEnsuresPublicly(input, output)
      ensures History.HkdfExpand == old(History.HkdfExpand) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate HkdfEnsuresPublicly(input: HkdfInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method Hkdf(input: HkdfInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Hkdf
      ensures true && ValidState()
      ensures HkdfEnsuresPublicly(input, output)
      ensures History.Hkdf == old(History.Hkdf) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate KdfCounterModeEnsuresPublicly(input: KdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method KdfCounterMode(input: KdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`KdfCounterMode
      ensures true && ValidState()
      ensures KdfCounterModeEnsuresPublicly(input, output)
      ensures History.KdfCounterMode == old(History.KdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate AesKdfCounterModeEnsuresPublicly(input: AesKdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method AesKdfCounterMode(input: AesKdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AesKdfCounterMode
      ensures true && ValidState()
      ensures AesKdfCounterModeEnsuresPublicly(input, output)
      ensures History.AesKdfCounterMode == old(History.AesKdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate AESEncryptEnsuresPublicly(input: AESEncryptInput, output: Result<AESEncryptOutput, Error>)
      decreases input, output

    method AESEncrypt(input: AESEncryptInput) returns (output: Result<AESEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESEncrypt
      ensures true && ValidState()
      ensures AESEncryptEnsuresPublicly(input, output)
      ensures History.AESEncrypt == old(History.AESEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate AESDecryptEnsuresPublicly(input: AESDecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method AESDecrypt(input: AESDecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESDecrypt
      ensures true && ValidState()
      ensures AESDecryptEnsuresPublicly(input, output)
      ensures History.AESDecrypt == old(History.AESDecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateRSAKeyPairEnsuresPublicly(input: GenerateRSAKeyPairInput, output: Result<GenerateRSAKeyPairOutput, Error>)
      decreases input, output

    method GenerateRSAKeyPair(input: GenerateRSAKeyPairInput) returns (output: Result<GenerateRSAKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRSAKeyPair
      ensures true && ValidState()
      ensures GenerateRSAKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateRSAKeyPair == old(History.GenerateRSAKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    function method GetRSAKeyModulusLength(input: GetRSAKeyModulusLengthInput): (output: Result<GetRSAKeyModulusLengthOutput, Error>)
      decreases input

    predicate RSADecryptEnsuresPublicly(input: RSADecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method RSADecrypt(input: RSADecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSADecrypt
      ensures true && ValidState()
      ensures RSADecryptEnsuresPublicly(input, output)
      ensures History.RSADecrypt == old(History.RSADecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RSAEncryptEnsuresPublicly(input: RSAEncryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method RSAEncrypt(input: RSAEncryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSAEncrypt
      ensures true && ValidState()
      ensures RSAEncryptEnsuresPublicly(input, output)
      ensures History.RSAEncrypt == old(History.RSAEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateECDSASignatureKeyEnsuresPublicly(input: GenerateECDSASignatureKeyInput, output: Result<GenerateECDSASignatureKeyOutput, Error>)
      decreases input, output

    method GenerateECDSASignatureKey(input: GenerateECDSASignatureKeyInput) returns (output: Result<GenerateECDSASignatureKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECDSASignatureKey
      ensures true && ValidState()
      ensures GenerateECDSASignatureKeyEnsuresPublicly(input, output)
      ensures History.GenerateECDSASignatureKey == old(History.GenerateECDSASignatureKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ECDSASignEnsuresPublicly(input: ECDSASignInput, output: Result<seq<uint8>, Error>)
      decreases input, output

    method ECDSASign(input: ECDSASignInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSASign
      ensures true && ValidState()
      ensures ECDSASignEnsuresPublicly(input, output)
      ensures History.ECDSASign == old(History.ECDSASign) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ECDSAVerifyEnsuresPublicly(input: ECDSAVerifyInput, output: Result<bool, Error>)
      decreases input, output

    method ECDSAVerify(input: ECDSAVerifyInput) returns (output: Result<bool, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSAVerify
      ensures true && ValidState()
      ensures ECDSAVerifyEnsuresPublicly(input, output)
      ensures History.ECDSAVerify == old(History.ECDSAVerify) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateECCKeyPairEnsuresPublicly(input: GenerateECCKeyPairInput, output: Result<GenerateECCKeyPairOutput, Error>)
      decreases input, output

    method GenerateECCKeyPair(input: GenerateECCKeyPairInput) returns (output: Result<GenerateECCKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECCKeyPair
      ensures true && ValidState()
      ensures GenerateECCKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateECCKeyPair == old(History.GenerateECCKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetPublicKeyFromPrivateKeyEnsuresPublicly(input: GetPublicKeyFromPrivateKeyInput, output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      decreases input, output

    method GetPublicKeyFromPrivateKey(input: GetPublicKeyFromPrivateKeyInput) returns (output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetPublicKeyFromPrivateKey
      ensures true && ValidState()
      ensures GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
      ensures History.GetPublicKeyFromPrivateKey == old(History.GetPublicKeyFromPrivateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ValidatePublicKeyEnsuresPublicly(input: ValidatePublicKeyInput, output: Result<ValidatePublicKeyOutput, Error>)
      decreases input, output

    method ValidatePublicKey(input: ValidatePublicKeyInput) returns (output: Result<ValidatePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ValidatePublicKey
      ensures true && ValidState()
      ensures ValidatePublicKeyEnsuresPublicly(input, output)
      ensures History.ValidatePublicKey == old(History.ValidatePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretInput, output: Result<DeriveSharedSecretOutput, Error>)
      decreases input, output

    method DeriveSharedSecret(input: DeriveSharedSecretInput) returns (output: Result<DeriveSharedSecretOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeriveSharedSecret
      ensures true && ValidState()
      ensures DeriveSharedSecretEnsuresPublicly(input, output)
      ensures History.DeriveSharedSecret == old(History.DeriveSharedSecret) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CompressPublicKeyEnsuresPublicly(input: CompressPublicKeyInput, output: Result<CompressPublicKeyOutput, Error>)
      decreases input, output

    method CompressPublicKey(input: CompressPublicKeyInput) returns (output: Result<CompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CompressPublicKey
      ensures true && ValidState()
      ensures CompressPublicKeyEnsuresPublicly(input, output)
      ensures History.CompressPublicKey == old(History.CompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DecompressPublicKeyEnsuresPublicly(input: DecompressPublicKeyInput, output: Result<DecompressPublicKeyOutput, Error>)
      decreases input, output

    method DecompressPublicKey(input: DecompressPublicKeyInput) returns (output: Result<DecompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecompressPublicKey
      ensures true && ValidState()
      ensures DecompressPublicKeyEnsuresPublicly(input, output)
      ensures History.DecompressPublicKey == old(History.DecompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ParsePublicKeyEnsuresPublicly(input: ParsePublicKeyInput, output: Result<ParsePublicKeyOutput, Error>)
      decreases input, output

    method ParsePublicKey(input: ParsePublicKeyInput) returns (output: Result<ParsePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ParsePublicKey
      ensures true && ValidState()
      ensures ParsePublicKeyEnsuresPublicly(input, output)
      ensures History.ParsePublicKey == old(History.ParsePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype CompressPublicKeyInput = CompressPublicKeyInput(nameonly publicKey: ECCPublicKey, nameonly eccCurve: ECDHCurveSpec)

  datatype CompressPublicKeyOutput = CompressPublicKeyOutput(nameonly compressedPublicKey: seq<uint8>)

  datatype CryptoConfig = CryptoConfig

  datatype DecompressPublicKeyInput = DecompressPublicKeyInput(nameonly compressedPublicKey: seq<uint8>, nameonly eccCurve: ECDHCurveSpec)

  datatype DecompressPublicKeyOutput = DecompressPublicKeyOutput(nameonly publicKey: ECCPublicKey)

  datatype DeriveSharedSecretInput = DeriveSharedSecretInput(nameonly eccCurve: ECDHCurveSpec, nameonly privateKey: ECCPrivateKey, nameonly publicKey: ECCPublicKey)

  datatype DeriveSharedSecretOutput = DeriveSharedSecretOutput(nameonly sharedSecret: seq<uint8>)

  datatype DigestAlgorithm = SHA_512 | SHA_384 | SHA_256

  datatype DigestInput = DigestInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly message: seq<uint8>)

  datatype ECCPrivateKey = ECCPrivateKey(nameonly pem: seq<uint8>)

  datatype ECCPublicKey = ECCPublicKey(nameonly der: seq<uint8>)

  datatype ECDHCurveSpec = ECC_NIST_P256 | ECC_NIST_P384 | ECC_NIST_P521 | SM2

  datatype ECDSASignatureAlgorithm = ECDSA_P384 | ECDSA_P256

  datatype ECDSASignInput = ECDSASignInput(nameonly signatureAlgorithm: ECDSASignatureAlgorithm, nameonly signingKey: seq<uint8>, nameonly message: seq<uint8>)

  datatype ECDSAVerifyInput = ECDSAVerifyInput(nameonly signatureAlgorithm: ECDSASignatureAlgorithm, nameonly verificationKey: seq<uint8>, nameonly message: seq<uint8>, nameonly signature: seq<uint8>)

  datatype GenerateECCKeyPairInput = GenerateECCKeyPairInput(nameonly eccCurve: ECDHCurveSpec)

  datatype GenerateECCKeyPairOutput = GenerateECCKeyPairOutput(nameonly eccCurve: ECDHCurveSpec, nameonly privateKey: ECCPrivateKey, nameonly publicKey: ECCPublicKey)

  datatype GenerateECDSASignatureKeyInput = GenerateECDSASignatureKeyInput(nameonly signatureAlgorithm: ECDSASignatureAlgorithm)

  datatype GenerateECDSASignatureKeyOutput = GenerateECDSASignatureKeyOutput(nameonly signatureAlgorithm: ECDSASignatureAlgorithm, nameonly verificationKey: seq<uint8>, nameonly signingKey: seq<uint8>)

  datatype GenerateRandomBytesInput = GenerateRandomBytesInput(nameonly length: PositiveInteger)

  datatype GenerateRSAKeyPairInput = GenerateRSAKeyPairInput(nameonly lengthBits: RSAModulusLengthBitsToGenerate)

  datatype GenerateRSAKeyPairOutput = GenerateRSAKeyPairOutput(nameonly publicKey: RSAPublicKey, nameonly privateKey: RSAPrivateKey)

  datatype GetPublicKeyFromPrivateKeyInput = GetPublicKeyFromPrivateKeyInput(nameonly eccCurve: ECDHCurveSpec, nameonly privateKey: ECCPrivateKey)

  datatype GetPublicKeyFromPrivateKeyOutput = GetPublicKeyFromPrivateKeyOutput(nameonly eccCurve: ECDHCurveSpec, nameonly privateKey: ECCPrivateKey, nameonly publicKey: seq<uint8>)

  datatype GetRSAKeyModulusLengthInput = GetRSAKeyModulusLengthInput(nameonly publicKey: seq<uint8>)

  datatype GetRSAKeyModulusLengthOutput = GetRSAKeyModulusLengthOutput(nameonly length: RSAModulusLengthBits)

  datatype HkdfExpandInput = HkdfExpandInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly prk: seq<uint8>, nameonly info: seq<uint8>, nameonly expectedLength: PositiveInteger)

  datatype HkdfExtractInput = HkdfExtractInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly salt: Option<seq<uint8>> := Option.None, nameonly ikm: seq<uint8>)

  datatype HkdfInput = HkdfInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly salt: Option<seq<uint8>> := Option.None, nameonly ikm: seq<uint8>, nameonly info: seq<uint8>, nameonly expectedLength: PositiveInteger)

  datatype HMacInput = HMacInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly key: seq<uint8>, nameonly message: seq<uint8>)

  datatype KdfCtrInput = KdfCtrInput(nameonly digestAlgorithm: DigestAlgorithm, nameonly ikm: seq<uint8>, nameonly expectedLength: PositiveInteger, nameonly purpose: Option<seq<uint8>> := Option.None, nameonly nonce: Option<seq<uint8>> := Option.None)

  datatype ParsePublicKeyInput = ParsePublicKeyInput(nameonly publicKey: seq<uint8>)

  datatype ParsePublicKeyOutput = ParsePublicKeyOutput(nameonly publicKey: ECCPublicKey)

  type PositiveInteger = x: int32
    | IsValid_PositiveInteger(x)
    witness *

  datatype RSADecryptInput = RSADecryptInput(nameonly padding: RSAPaddingMode, nameonly privateKey: seq<uint8>, nameonly cipherText: seq<uint8>)

  datatype RSAEncryptInput = RSAEncryptInput(nameonly padding: RSAPaddingMode, nameonly publicKey: seq<uint8>, nameonly plaintext: seq<uint8>)

  type RSAModulusLengthBits = x: int32
    | IsValid_RSAModulusLengthBits(x)
    witness *

  type RSAModulusLengthBitsToGenerate = x: int32
    | IsValid_RSAModulusLengthBitsToGenerate(x)
    witness *

  datatype RSAPaddingMode = PKCS1 | OAEP_SHA1 | OAEP_SHA256 | OAEP_SHA384 | OAEP_SHA512

  datatype RSAPrivateKey = RSAPrivateKey(nameonly lengthBits: RSAModulusLengthBits, nameonly pem: seq<uint8>)

  datatype RSAPublicKey = RSAPublicKey(nameonly lengthBits: RSAModulusLengthBits, nameonly pem: seq<uint8>)

  type SymmetricKeyLength = x: int32
    | IsValid_SymmetricKeyLength(x)
    witness *

  type Uint8Bits = x: int32
    | IsValid_Uint8Bits(x)
    witness *

  type Uint8Bytes = x: int32
    | IsValid_Uint8Bytes(x)
    witness *

  datatype ValidatePublicKeyInput = ValidatePublicKeyInput(nameonly eccCurve: ECDHCurveSpec, nameonly publicKey: seq<uint8>)

  datatype ValidatePublicKeyOutput = ValidatePublicKeyOutput(nameonly success: bool)

  datatype Error = AwsCryptographicPrimitivesError(nameonly message: string) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyPrimitivesService {
  function method DefaultCryptoConfig(): CryptoConfig

  method AtomicPrimitives(config: CryptoConfig := DefaultCryptoConfig()) returns (res: Result<AtomicPrimitivesClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IAwsCryptographicPrimitivesClient): Result<IAwsCryptographicPrimitivesClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IAwsCryptographicPrimitivesClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyPrimitivesTypes

  import Operations : AbstractAwsCryptographyPrimitivesOperations

  class AtomicPrimitivesClient extends IAwsCryptographicPrimitivesClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate GenerateRandomBytesEnsuresPublicly(input: GenerateRandomBytesInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.GenerateRandomBytesEnsuresPublicly(input, output)
    }

    method GenerateRandomBytes(input: GenerateRandomBytesInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRandomBytes
      ensures true && ValidState()
      ensures GenerateRandomBytesEnsuresPublicly(input, output)
      ensures History.GenerateRandomBytes == old(History.GenerateRandomBytes) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateRandomBytes(config, input);
      History.GenerateRandomBytes := History.GenerateRandomBytes + [DafnyCallEvent(input, output)];
    }

    predicate DigestEnsuresPublicly(input: DigestInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.DigestEnsuresPublicly(input, output)
    }

    method Digest(input: DigestInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Digest
      ensures true && ValidState()
      ensures DigestEnsuresPublicly(input, output)
      ensures History.Digest == old(History.Digest) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.Digest(config, input);
      History.Digest := History.Digest + [DafnyCallEvent(input, output)];
    }

    function method HMac(input: HMacInput): (output: Result<seq<uint8>, Error>)
      decreases input
    {
      Operations.HMac(config, input)
    }

    predicate HkdfExtractEnsuresPublicly(input: HkdfExtractInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfExtractEnsuresPublicly(input, output)
    }

    method HkdfExtract(input: HkdfExtractInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExtract
      ensures true && ValidState()
      ensures HkdfExtractEnsuresPublicly(input, output)
      ensures History.HkdfExtract == old(History.HkdfExtract) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.HkdfExtract(config, input);
      History.HkdfExtract := History.HkdfExtract + [DafnyCallEvent(input, output)];
    }

    predicate HkdfExpandEnsuresPublicly(input: HkdfExpandInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfExpandEnsuresPublicly(input, output)
    }

    method HkdfExpand(input: HkdfExpandInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`HkdfExpand
      ensures true && ValidState()
      ensures HkdfExpandEnsuresPublicly(input, output)
      ensures History.HkdfExpand == old(History.HkdfExpand) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.HkdfExpand(config, input);
      History.HkdfExpand := History.HkdfExpand + [DafnyCallEvent(input, output)];
    }

    predicate HkdfEnsuresPublicly(input: HkdfInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.HkdfEnsuresPublicly(input, output)
    }

    method Hkdf(input: HkdfInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Hkdf
      ensures true && ValidState()
      ensures HkdfEnsuresPublicly(input, output)
      ensures History.Hkdf == old(History.Hkdf) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.Hkdf(config, input);
      History.Hkdf := History.Hkdf + [DafnyCallEvent(input, output)];
    }

    predicate KdfCounterModeEnsuresPublicly(input: KdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.KdfCounterModeEnsuresPublicly(input, output)
    }

    method KdfCounterMode(input: KdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`KdfCounterMode
      ensures true && ValidState()
      ensures KdfCounterModeEnsuresPublicly(input, output)
      ensures History.KdfCounterMode == old(History.KdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.KdfCounterMode(config, input);
      History.KdfCounterMode := History.KdfCounterMode + [DafnyCallEvent(input, output)];
    }

    predicate AesKdfCounterModeEnsuresPublicly(input: AesKdfCtrInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.AesKdfCounterModeEnsuresPublicly(input, output)
    }

    method AesKdfCounterMode(input: AesKdfCtrInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AesKdfCounterMode
      ensures true && ValidState()
      ensures AesKdfCounterModeEnsuresPublicly(input, output)
      ensures History.AesKdfCounterMode == old(History.AesKdfCounterMode) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AesKdfCounterMode(config, input);
      History.AesKdfCounterMode := History.AesKdfCounterMode + [DafnyCallEvent(input, output)];
    }

    predicate AESEncryptEnsuresPublicly(input: AESEncryptInput, output: Result<AESEncryptOutput, Error>)
      decreases input, output
    {
      Operations.AESEncryptEnsuresPublicly(input, output)
    }

    method AESEncrypt(input: AESEncryptInput) returns (output: Result<AESEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESEncrypt
      ensures true && ValidState()
      ensures AESEncryptEnsuresPublicly(input, output)
      ensures History.AESEncrypt == old(History.AESEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AESEncrypt(config, input);
      History.AESEncrypt := History.AESEncrypt + [DafnyCallEvent(input, output)];
    }

    predicate AESDecryptEnsuresPublicly(input: AESDecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.AESDecryptEnsuresPublicly(input, output)
    }

    method AESDecrypt(input: AESDecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`AESDecrypt
      ensures true && ValidState()
      ensures AESDecryptEnsuresPublicly(input, output)
      ensures History.AESDecrypt == old(History.AESDecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.AESDecrypt(config, input);
      History.AESDecrypt := History.AESDecrypt + [DafnyCallEvent(input, output)];
    }

    predicate GenerateRSAKeyPairEnsuresPublicly(input: GenerateRSAKeyPairInput, output: Result<GenerateRSAKeyPairOutput, Error>)
      decreases input, output
    {
      Operations.GenerateRSAKeyPairEnsuresPublicly(input, output)
    }

    method GenerateRSAKeyPair(input: GenerateRSAKeyPairInput) returns (output: Result<GenerateRSAKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRSAKeyPair
      ensures true && ValidState()
      ensures GenerateRSAKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateRSAKeyPair == old(History.GenerateRSAKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateRSAKeyPair(config, input);
      History.GenerateRSAKeyPair := History.GenerateRSAKeyPair + [DafnyCallEvent(input, output)];
    }

    function method GetRSAKeyModulusLength(input: GetRSAKeyModulusLengthInput): (output: Result<GetRSAKeyModulusLengthOutput, Error>)
      decreases input
    {
      Operations.GetRSAKeyModulusLength(config, input)
    }

    predicate RSADecryptEnsuresPublicly(input: RSADecryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.RSADecryptEnsuresPublicly(input, output)
    }

    method RSADecrypt(input: RSADecryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSADecrypt
      ensures true && ValidState()
      ensures RSADecryptEnsuresPublicly(input, output)
      ensures History.RSADecrypt == old(History.RSADecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.RSADecrypt(config, input);
      History.RSADecrypt := History.RSADecrypt + [DafnyCallEvent(input, output)];
    }

    predicate RSAEncryptEnsuresPublicly(input: RSAEncryptInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.RSAEncryptEnsuresPublicly(input, output)
    }

    method RSAEncrypt(input: RSAEncryptInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RSAEncrypt
      ensures true && ValidState()
      ensures RSAEncryptEnsuresPublicly(input, output)
      ensures History.RSAEncrypt == old(History.RSAEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.RSAEncrypt(config, input);
      History.RSAEncrypt := History.RSAEncrypt + [DafnyCallEvent(input, output)];
    }

    predicate GenerateECDSASignatureKeyEnsuresPublicly(input: GenerateECDSASignatureKeyInput, output: Result<GenerateECDSASignatureKeyOutput, Error>)
      decreases input, output
    {
      Operations.GenerateECDSASignatureKeyEnsuresPublicly(input, output)
    }

    method GenerateECDSASignatureKey(input: GenerateECDSASignatureKeyInput) returns (output: Result<GenerateECDSASignatureKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECDSASignatureKey
      ensures true && ValidState()
      ensures GenerateECDSASignatureKeyEnsuresPublicly(input, output)
      ensures History.GenerateECDSASignatureKey == old(History.GenerateECDSASignatureKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateECDSASignatureKey(config, input);
      History.GenerateECDSASignatureKey := History.GenerateECDSASignatureKey + [DafnyCallEvent(input, output)];
    }

    predicate ECDSASignEnsuresPublicly(input: ECDSASignInput, output: Result<seq<uint8>, Error>)
      decreases input, output
    {
      Operations.ECDSASignEnsuresPublicly(input, output)
    }

    method ECDSASign(input: ECDSASignInput) returns (output: Result<seq<uint8>, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSASign
      ensures true && ValidState()
      ensures ECDSASignEnsuresPublicly(input, output)
      ensures History.ECDSASign == old(History.ECDSASign) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ECDSASign(config, input);
      History.ECDSASign := History.ECDSASign + [DafnyCallEvent(input, output)];
    }

    predicate ECDSAVerifyEnsuresPublicly(input: ECDSAVerifyInput, output: Result<bool, Error>)
      decreases input, output
    {
      Operations.ECDSAVerifyEnsuresPublicly(input, output)
    }

    method ECDSAVerify(input: ECDSAVerifyInput) returns (output: Result<bool, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ECDSAVerify
      ensures true && ValidState()
      ensures ECDSAVerifyEnsuresPublicly(input, output)
      ensures History.ECDSAVerify == old(History.ECDSAVerify) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ECDSAVerify(config, input);
      History.ECDSAVerify := History.ECDSAVerify + [DafnyCallEvent(input, output)];
    }

    predicate GenerateECCKeyPairEnsuresPublicly(input: GenerateECCKeyPairInput, output: Result<GenerateECCKeyPairOutput, Error>)
      decreases input, output
    {
      Operations.GenerateECCKeyPairEnsuresPublicly(input, output)
    }

    method GenerateECCKeyPair(input: GenerateECCKeyPairInput) returns (output: Result<GenerateECCKeyPairOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateECCKeyPair
      ensures true && ValidState()
      ensures GenerateECCKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateECCKeyPair == old(History.GenerateECCKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GenerateECCKeyPair(config, input);
      History.GenerateECCKeyPair := History.GenerateECCKeyPair + [DafnyCallEvent(input, output)];
    }

    predicate GetPublicKeyFromPrivateKeyEnsuresPublicly(input: GetPublicKeyFromPrivateKeyInput, output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
    }

    method GetPublicKeyFromPrivateKey(input: GetPublicKeyFromPrivateKeyInput) returns (output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetPublicKeyFromPrivateKey
      ensures true && ValidState()
      ensures GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
      ensures History.GetPublicKeyFromPrivateKey == old(History.GetPublicKeyFromPrivateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetPublicKeyFromPrivateKey(config, input);
      History.GetPublicKeyFromPrivateKey := History.GetPublicKeyFromPrivateKey + [DafnyCallEvent(input, output)];
    }

    predicate ValidatePublicKeyEnsuresPublicly(input: ValidatePublicKeyInput, output: Result<ValidatePublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.ValidatePublicKeyEnsuresPublicly(input, output)
    }

    method ValidatePublicKey(input: ValidatePublicKeyInput) returns (output: Result<ValidatePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ValidatePublicKey
      ensures true && ValidState()
      ensures ValidatePublicKeyEnsuresPublicly(input, output)
      ensures History.ValidatePublicKey == old(History.ValidatePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ValidatePublicKey(config, input);
      History.ValidatePublicKey := History.ValidatePublicKey + [DafnyCallEvent(input, output)];
    }

    predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretInput, output: Result<DeriveSharedSecretOutput, Error>)
      decreases input, output
    {
      Operations.DeriveSharedSecretEnsuresPublicly(input, output)
    }

    method DeriveSharedSecret(input: DeriveSharedSecretInput) returns (output: Result<DeriveSharedSecretOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeriveSharedSecret
      ensures true && ValidState()
      ensures DeriveSharedSecretEnsuresPublicly(input, output)
      ensures History.DeriveSharedSecret == old(History.DeriveSharedSecret) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DeriveSharedSecret(config, input);
      History.DeriveSharedSecret := History.DeriveSharedSecret + [DafnyCallEvent(input, output)];
    }

    predicate CompressPublicKeyEnsuresPublicly(input: CompressPublicKeyInput, output: Result<CompressPublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.CompressPublicKeyEnsuresPublicly(input, output)
    }

    method CompressPublicKey(input: CompressPublicKeyInput) returns (output: Result<CompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CompressPublicKey
      ensures true && ValidState()
      ensures CompressPublicKeyEnsuresPublicly(input, output)
      ensures History.CompressPublicKey == old(History.CompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CompressPublicKey(config, input);
      History.CompressPublicKey := History.CompressPublicKey + [DafnyCallEvent(input, output)];
    }

    predicate DecompressPublicKeyEnsuresPublicly(input: DecompressPublicKeyInput, output: Result<DecompressPublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.DecompressPublicKeyEnsuresPublicly(input, output)
    }

    method DecompressPublicKey(input: DecompressPublicKeyInput) returns (output: Result<DecompressPublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecompressPublicKey
      ensures true && ValidState()
      ensures DecompressPublicKeyEnsuresPublicly(input, output)
      ensures History.DecompressPublicKey == old(History.DecompressPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.DecompressPublicKey(config, input);
      History.DecompressPublicKey := History.DecompressPublicKey + [DafnyCallEvent(input, output)];
    }

    predicate ParsePublicKeyEnsuresPublicly(input: ParsePublicKeyInput, output: Result<ParsePublicKeyOutput, Error>)
      decreases input, output
    {
      Operations.ParsePublicKeyEnsuresPublicly(input, output)
    }

    method ParsePublicKey(input: ParsePublicKeyInput) returns (output: Result<ParsePublicKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ParsePublicKey
      ensures true && ValidState()
      ensures ParsePublicKeyEnsuresPublicly(input, output)
      ensures History.ParsePublicKey == old(History.ParsePublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.ParsePublicKey(config, input);
      History.ParsePublicKey := History.ParsePublicKey + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyPrimitivesOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate GenerateRandomBytesEnsuresPublicly(input: GenerateRandomBytesInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method GenerateRandomBytes(config: InternalConfig, input: GenerateRandomBytesInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateRandomBytesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DigestEnsuresPublicly(input: DigestInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method Digest(config: InternalConfig, input: DigestInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DigestEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  function method HMac(config: InternalConfig, input: HMacInput): (output: Result<seq<uint8>, Error>)
    decreases input

  predicate HkdfExtractEnsuresPublicly(input: HkdfExtractInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method HkdfExtract(config: InternalConfig, input: HkdfExtractInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfExtractEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate HkdfExpandEnsuresPublicly(input: HkdfExpandInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method HkdfExpand(config: InternalConfig, input: HkdfExpandInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfExpandEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate HkdfEnsuresPublicly(input: HkdfInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method Hkdf(config: InternalConfig, input: HkdfInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures HkdfEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate KdfCounterModeEnsuresPublicly(input: KdfCtrInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method KdfCounterMode(config: InternalConfig, input: KdfCtrInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures KdfCounterModeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate AesKdfCounterModeEnsuresPublicly(input: AesKdfCtrInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method AesKdfCounterMode(config: InternalConfig, input: AesKdfCtrInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AesKdfCounterModeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate AESEncryptEnsuresPublicly(input: AESEncryptInput, output: Result<AESEncryptOutput, Error>)
    decreases input, output

  method AESEncrypt(config: InternalConfig, input: AESEncryptInput) returns (output: Result<AESEncryptOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AESEncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate AESDecryptEnsuresPublicly(input: AESDecryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method AESDecrypt(config: InternalConfig, input: AESDecryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures AESDecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateRSAKeyPairEnsuresPublicly(input: GenerateRSAKeyPairInput, output: Result<GenerateRSAKeyPairOutput, Error>)
    decreases input, output

  method GenerateRSAKeyPair(config: InternalConfig, input: GenerateRSAKeyPairInput) returns (output: Result<GenerateRSAKeyPairOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateRSAKeyPairEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  function method GetRSAKeyModulusLength(config: InternalConfig, input: GetRSAKeyModulusLengthInput): (output: Result<GetRSAKeyModulusLengthOutput, Error>)
    decreases input

  predicate RSADecryptEnsuresPublicly(input: RSADecryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method RSADecrypt(config: InternalConfig, input: RSADecryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RSADecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RSAEncryptEnsuresPublicly(input: RSAEncryptInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method RSAEncrypt(config: InternalConfig, input: RSAEncryptInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RSAEncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateECDSASignatureKeyEnsuresPublicly(input: GenerateECDSASignatureKeyInput, output: Result<GenerateECDSASignatureKeyOutput, Error>)
    decreases input, output

  method GenerateECDSASignatureKey(config: InternalConfig, input: GenerateECDSASignatureKeyInput) returns (output: Result<GenerateECDSASignatureKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateECDSASignatureKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ECDSASignEnsuresPublicly(input: ECDSASignInput, output: Result<seq<uint8>, Error>)
    decreases input, output

  method ECDSASign(config: InternalConfig, input: ECDSASignInput) returns (output: Result<seq<uint8>, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ECDSASignEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ECDSAVerifyEnsuresPublicly(input: ECDSAVerifyInput, output: Result<bool, Error>)
    decreases input, output

  method ECDSAVerify(config: InternalConfig, input: ECDSAVerifyInput) returns (output: Result<bool, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ECDSAVerifyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateECCKeyPairEnsuresPublicly(input: GenerateECCKeyPairInput, output: Result<GenerateECCKeyPairOutput, Error>)
    decreases input, output

  method GenerateECCKeyPair(config: InternalConfig, input: GenerateECCKeyPairInput) returns (output: Result<GenerateECCKeyPairOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateECCKeyPairEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetPublicKeyFromPrivateKeyEnsuresPublicly(input: GetPublicKeyFromPrivateKeyInput, output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
    decreases input, output

  method GetPublicKeyFromPrivateKey(config: InternalConfig, input: GetPublicKeyFromPrivateKeyInput) returns (output: Result<GetPublicKeyFromPrivateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetPublicKeyFromPrivateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ValidatePublicKeyEnsuresPublicly(input: ValidatePublicKeyInput, output: Result<ValidatePublicKeyOutput, Error>)
    decreases input, output

  method ValidatePublicKey(config: InternalConfig, input: ValidatePublicKeyInput) returns (output: Result<ValidatePublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ValidatePublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretInput, output: Result<DeriveSharedSecretOutput, Error>)
    decreases input, output

  method DeriveSharedSecret(config: InternalConfig, input: DeriveSharedSecretInput) returns (output: Result<DeriveSharedSecretOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeriveSharedSecretEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CompressPublicKeyEnsuresPublicly(input: CompressPublicKeyInput, output: Result<CompressPublicKeyOutput, Error>)
    decreases input, output

  method CompressPublicKey(config: InternalConfig, input: CompressPublicKeyInput) returns (output: Result<CompressPublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CompressPublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DecompressPublicKeyEnsuresPublicly(input: DecompressPublicKeyInput, output: Result<DecompressPublicKeyOutput, Error>)
    decreases input, output

  method DecompressPublicKey(config: InternalConfig, input: DecompressPublicKeyInput) returns (output: Result<DecompressPublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DecompressPublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ParsePublicKeyEnsuresPublicly(input: ParsePublicKeyInput, output: Result<ParsePublicKeyOutput, Error>)
    decreases input, output

  method ParsePublicKey(config: InternalConfig, input: ParsePublicKeyInput) returns (output: Result<ParsePublicKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ParsePublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyPrimitivesTypes

  type InternalConfig
}

module {:options "-functionSyntax:4"} UnicodeStrings refines AbstractUnicodeStrings {
  predicate method IsWellFormedString(s: string)
    ensures |s| == 0 ==> IsWellFormedString(s)
    decreases s
  {
    Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map((c: char) => c as Utf16EncodingForm.CodeUnit, s))
  }

  function method ToUTF8Checked(s: string): Option<seq<uint8>>
    decreases s
  {
    var asCodeUnits: seq<Utf16EncodingForm.CodeUnit> := Seq.Map((c: char) => c as Utf16EncodingForm.CodeUnit, s);
    var utf32: seq<Unicode.ScalarValue> :- Utf16EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits); var asUtf8CodeUnits: WellFormedCodeUnitSeq := Utf8EncodingForm.EncodeScalarSequence(utf32); Some(Seq.Map((c: bv8) => c as byte, asUtf8CodeUnits))
  }

  function method {:vcs_split_on_every_assert} FromUTF8Checked(bs: seq<uint8>): Option<string>
    decreases bs
  {
    var asCodeUnits: seq<Utf8EncodingForm.CodeUnit> := Seq.Map((c: uint8) => c as Utf8EncodingForm.CodeUnit, bs);
    var utf32: seq<Unicode.ScalarValue> :- Utf8EncodingForm.DecodeCodeUnitSequenceChecked(asCodeUnits); var asUtf16CodeUnits: WellFormedCodeUnitSeq := Utf16EncodingForm.EncodeScalarSequence(utf32); Some(Seq.Map((cu: bv16) => cu as char, asUtf16CodeUnits))
  }

  function method ToUTF16Checked(s: string): Option<seq<uint16>>
    decreases s
  {
    if Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map((c: char) => c as Utf16EncodingForm.CodeUnit, s)) then
      Some(Seq.Map((c: char) => c as uint16, s))
    else
      None
  }

  function method FromUTF16Checked(bs: seq<uint16>): Option<string>
    decreases bs
  {
    if Utf16EncodingForm.IsWellFormedCodeUnitSequence(Seq.Map((c: uint16) => c as Utf16EncodingForm.CodeUnit, bs)) then
      Some(Seq.Map((c: uint16) => c as char, bs))
    else
      None
  }

  function method ASCIIToUTF8(s: string): seq<uint8>
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: 0 <= s[i] as int && s[i] as int < 128
    decreases s
  {
    Seq.Map((c: char) requires 0 <= c as int < 128 => c as uint8, s)
  }

  function method ASCIIToUTF16(s: string): seq<uint16>
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: 0 <= s[i] as int && s[i] as int < 128
    decreases s
  {
    Seq.Map((c: char) requires 0 <= c as int < 128 => c as uint16, s)
  }

  import Unicode

  import Utf8EncodingForm

  import Utf16EncodingForm

  import Seq

  import opened Wrappers

  import opened BoundedInts
}

module {:options "-functionSyntax:4"} Seq {
  function method First<T>(xs: seq<T>): T
    requires |xs| > 0
    decreases xs
  {
    xs[0]
  }

  function method DropFirst<T>(xs: seq<T>): seq<T>
    requires |xs| > 0
    decreases xs
  {
    xs[1..]
  }

  function method Last<T>(xs: seq<T>): T
    requires |xs| > 0
    decreases xs
  {
    xs[|xs| - 1]
  }

  function method DropLast<T>(xs: seq<T>): seq<T>
    requires |xs| > 0
    decreases xs
  {
    xs[..|xs| - 1]
  }

  lemma LemmaLast<T>(xs: seq<T>)
    requires |xs| > 0
    ensures DropLast(xs) + [Last(xs)] == xs
    decreases xs
  {
  }

  lemma LemmaAppendLast<T>(xs: seq<T>, ys: seq<T>)
    requires 0 < |ys|
    ensures Last(xs + ys) == Last(ys)
    decreases xs, ys
  {
  }

  lemma LemmaConcatIsAssociative<T>(xs: seq<T>, ys: seq<T>, zs: seq<T>)
    ensures xs + (ys + zs) == xs + ys + zs
    decreases xs, ys, zs
  {
  }

  lemma IndexingImpliesMembership<T>(p: T -> bool, xs: seq<T>)
    requires forall i: int {:trigger xs[i]} | 0 <= i < |xs| :: p(xs[i])
    ensures forall t: T {:trigger p(t)} {:trigger t in xs} | t in xs :: p(t)
    decreases xs
  {
  }

  lemma MembershipImpliesIndexing<T>(p: T -> bool, xs: seq<T>)
    requires forall t: T {:trigger p(t)} {:trigger t in xs} | t in xs :: p(t)
    ensures forall i: int {:trigger xs[i]} | 0 <= i < |xs| :: p(xs[i])
    decreases xs
  {
  }

  predicate IsPrefix<T>(xs: seq<T>, ys: seq<T>)
    ensures IsPrefix(xs, ys) ==> |xs| <= |ys| && xs == ys[..|xs|]
    decreases xs, ys
  {
    xs <= ys
  }

  predicate IsSuffix<T>(xs: seq<T>, ys: seq<T>)
    decreases xs, ys
  {
    |xs| <= |ys| &&
    xs == ys[|ys| - |xs|..]
  }

  lemma LemmaSplitAt<T>(xs: seq<T>, pos: nat)
    requires pos < |xs|
    ensures xs[..pos] + xs[pos..] == xs
    decreases xs, pos
  {
  }

  lemma LemmaElementFromSlice<T>(xs: seq<T>, xs': seq<T>, a: int, b: int, pos: nat)
    requires 0 <= a <= b <= |xs|
    requires xs' == xs[a .. b]
    requires a <= pos < b
    ensures pos - a < |xs'|
    ensures xs'[pos - a] == xs[pos]
    decreases xs, xs', a, b, pos
  {
  }

  lemma LemmaSliceOfSlice<T>(xs: seq<T>, s1: int, e1: int, s2: int, e2: int)
    requires 0 <= s1 <= e1 <= |xs|
    requires 0 <= s2 <= e2 <= e1 - s1
    ensures xs[s1 .. e1][s2 .. e2] == xs[s1 + s2 .. s1 + e2]
    decreases xs, s1, e1, s2, e2
  {
    ghost var r1 := xs[s1 .. e1];
    ghost var r2 := r1[s2 .. e2];
    ghost var r3 := xs[s1 + s2 .. s1 + e2];
    assert |r2| == |r3|;
    forall i: int {:trigger r2[i], r3[i]} | 0 <= i < |r2|
      ensures r2[i] == r3[i]
    {
    }
  }

  method ToArray<T>(xs: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |xs|
    ensures forall i: int {:trigger xs[i]} {:trigger a[i]} :: 0 <= i < |xs| ==> a[i] == xs[i]
    decreases xs
  {
    a := new T[|xs|] ((i: int) requires 0 <= i < |xs| => xs[i]);
  }

  function method {:opaque} ToSet<T>(xs: seq<T>): set<T>
    decreases xs
  {
    set x: T {:trigger x in xs} | x in xs
  }

  lemma LemmaCardinalityOfSet<T>(xs: seq<T>)
    ensures |ToSet(xs)| <= |xs|
    decreases xs
  {
    reveal ToSet();
    if |xs| == 0 {
    } else {
      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};
      LemmaCardinalityOfSet(DropLast(xs));
    }
  }

  lemma LemmaCardinalityOfEmptySetIs0<T>(xs: seq<T>)
    ensures |ToSet(xs)| == 0 <==> |xs| == 0
    decreases xs
  {
    reveal ToSet();
    if |xs| != 0 {
      assert xs[0] in ToSet(xs);
    }
  }

  predicate {:opaque} HasNoDuplicates<T>(xs: seq<T>)
    decreases xs
  {
    forall i: int, j: int {:trigger xs[j], xs[i]} :: 
      0 <= i < |xs| &&
      0 <= j < |xs| &&
      i != j ==>
        xs[i] != xs[j]
  }

  lemma {:timeLimitMultiplier 3} /*{:_timeLimit 90}*/ LemmaNoDuplicatesInConcat<T>(xs: seq<T>, ys: seq<T>)
    requires HasNoDuplicates(xs)
    requires HasNoDuplicates(ys)
    requires multiset(xs) !! multiset(ys)
    ensures HasNoDuplicates(xs + ys)
    decreases xs, ys
  {
    reveal HasNoDuplicates();
    ghost var zs := xs + ys;
    if |zs| > 1 {
      assert forall i: int {:trigger zs[i]} :: 0 <= i < |xs| ==> zs[i] in multiset(xs);
      assert forall j: int {:trigger zs[j]} :: |xs| <= j < |zs| ==> zs[j] in multiset(ys);
      assert forall i: int, j: int {:trigger zs[j], zs[i]} :: i != j && 0 <= i < |xs| && |xs| <= j < |zs| ==> zs[i] != zs[j];
    }
  }

  lemma LemmaCardinalityOfSetNoDuplicates<T>(xs: seq<T>)
    requires HasNoDuplicates(xs)
    ensures |ToSet(xs)| == |xs|
    decreases xs
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if |xs| == 0 {
    } else {
      LemmaCardinalityOfSetNoDuplicates(DropLast(xs));
      assert ToSet(xs) == ToSet(DropLast(xs)) + {Last(xs)};
    }
  }

  lemma LemmaNoDuplicatesCardinalityOfSet<T>(xs: seq<T>)
    requires |ToSet(xs)| == |xs|
    ensures HasNoDuplicates(xs)
    decreases xs
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if |xs| == 0 {
    } else {
      assert xs == [First(xs)] + DropFirst(xs);
      assert ToSet(xs) == {First(xs)} + ToSet(DropFirst(xs));
      if First(xs) in DropFirst(xs) {
        assert ToSet(xs) == ToSet(DropFirst(xs));
        LemmaCardinalityOfSet(DropFirst(xs));
        assert |ToSet(xs)| <= |DropFirst(xs)|;
      } else {
        assert |ToSet(xs)| == 1 + |ToSet(DropFirst(xs))|;
        LemmaNoDuplicatesCardinalityOfSet(DropFirst(xs));
      }
    }
  }

  lemma LemmaMultisetHasNoDuplicates<T>(xs: seq<T>)
    requires HasNoDuplicates(xs)
    ensures forall x: T {:trigger multiset(xs)[x]} | x in multiset(xs) :: multiset(xs)[x] == 1
    decreases xs
  {
    if |xs| == 0 {
    } else {
      assert xs == DropLast(xs) + [Last(xs)];
      assert Last(xs) !in DropLast(xs) by {
        reveal HasNoDuplicates();
      }
      assert HasNoDuplicates(DropLast(xs)) by {
        reveal HasNoDuplicates();
      }
      LemmaMultisetHasNoDuplicates(DropLast(xs));
    }
  }

  function method {:opaque} IndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)
    requires v in xs
    ensures i < |xs| && xs[i] == v
    ensures forall j: int {:trigger xs[j]} :: 0 <= j < i ==> xs[j] != v
    decreases xs
  {
    if xs[0] == v then
      0
    else
      1 + IndexOf(xs[1..], v)
  }

  function method {:opaque} IndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |xs| && xs[o.value] == v && forall j: int {:trigger xs[j]} :: 0 <= j < o.value ==> xs[j] != v else v !in xs
    decreases xs
  {
    if |xs| == 0 then
      None()
    else if xs[0] == v then
      Some(0)
    else
      var o': Option<nat> := IndexOfOption(xs[1..], v); if o'.Some? then Some(o'.value + 1) else None()
  }

  function method {:opaque} LastIndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)
    requires v in xs
    ensures i < |xs| && xs[i] == v
    ensures forall j: int {:trigger xs[j]} :: i < j < |xs| ==> xs[j] != v
    decreases xs
  {
    if xs[|xs| - 1] == v then
      |xs| - 1
    else
      LastIndexOf(xs[..|xs| - 1], v)
  }

  function method {:opaque} LastIndexOfOption<T(==)>(xs: seq<T>, v: T): (o: Option<nat>)
    ensures if o.Some? then o.value < |xs| && xs[o.value] == v && forall j: int {:trigger xs[j]} :: o.value < j < |xs| ==> xs[j] != v else v !in xs
    decreases xs
  {
    if |xs| == 0 then
      None()
    else if xs[|xs| - 1] == v then
      Some(|xs| - 1)
    else
      LastIndexOfOption(xs[..|xs| - 1], v)
  }

  function method {:opaque} Remove<T>(xs: seq<T>, pos: nat): (ys: seq<T>)
    requires pos < |xs|
    ensures |ys| == |xs| - 1
    ensures forall i: int {:trigger ys[i], xs[i]} | 0 <= i < pos :: ys[i] == xs[i]
    ensures forall i: int {:trigger ys[i]} | pos <= i < |xs| - 1 :: ys[i] == xs[i + 1]
    decreases xs, pos
  {
    xs[..pos] + xs[pos + 1..]
  }

  function method {:opaque} RemoveValue<T(==)>(xs: seq<T>, v: T): (ys: seq<T>)
    ensures v !in xs ==> xs == ys
    ensures v in xs ==> |multiset(ys)| == |multiset(xs)| - 1
    ensures v in xs ==> multiset(ys)[v] == multiset(xs)[v] - 1
    ensures HasNoDuplicates(xs) ==> HasNoDuplicates(ys) && ToSet(ys) == ToSet(xs) - {v}
    decreases xs
  {
    reveal HasNoDuplicates();
    reveal ToSet();
    if v !in xs then
      xs
    else
      var i: nat := IndexOf(xs, v); assert xs == xs[..i] + [v] + xs[i + 1..]; xs[..i] + xs[i + 1..]
  }

  function method {:opaque} Insert<T>(xs: seq<T>, a: T, pos: nat): seq<T>
    requires pos <= |xs|
    ensures |Insert(xs, a, pos)| == |xs| + 1
    ensures forall i: int {:trigger Insert(xs, a, pos)[i], xs[i]} :: 0 <= i < pos ==> Insert(xs, a, pos)[i] == xs[i]
    ensures forall i: int {:trigger xs[i]} :: pos <= i < |xs| ==> Insert(xs, a, pos)[i + 1] == xs[i]
    ensures Insert(xs, a, pos)[pos] == a
    ensures multiset(Insert(xs, a, pos)) == multiset(xs) + multiset{a}
    decreases xs, pos
  {
    assert xs == xs[..pos] + xs[pos..];
    xs[..pos] + [a] + xs[pos..]
  }

  function method {:opaque} Reverse<T>(xs: seq<T>): (ys: seq<T>)
    ensures |ys| == |xs|
    ensures forall i: int {:trigger ys[i]} {:trigger xs[|xs| - i - 1]} :: 0 <= i < |xs| ==> ys[i] == xs[|xs| - i - 1]
    decreases xs
  {
    if xs == [] then
      []
    else
      [xs[|xs| - 1]] + Reverse(xs[0 .. |xs| - 1])
  }

  function method {:opaque} Repeat<T>(v: T, length: nat): (xs: seq<T>)
    ensures |xs| == length
    ensures forall i: nat {:trigger xs[i]} | i < |xs| :: xs[i] == v
    decreases length
  {
    if length == 0 then
      []
    else
      [v] + Repeat(v, length - 1)
  }

  function method {:opaque} Unzip<A, B>(xs: seq<(A, B)>): (seq<A>, seq<B>)
    ensures |Unzip(xs).0| == |Unzip(xs).1| == |xs|
    ensures forall i: int {:trigger Unzip(xs).0[i]} {:trigger Unzip(xs).1[i]} :: 0 <= i < |xs| ==> (Unzip(xs).0[i], Unzip(xs).1[i]) == xs[i]
    decreases xs
  {
    if |xs| == 0 then
      ([], [])
    else
      var (a: seq<A>, b: seq<B>) := Unzip(DropLast(xs)); (a + [Last(xs).0], b + [Last(xs).1])
  }

  function method {:opaque} Zip<A, B>(xs: seq<A>, ys: seq<B>): seq<(A, B)>
    requires |xs| == |ys|
    ensures |Zip(xs, ys)| == |xs|
    ensures forall i: int {:trigger Zip(xs, ys)[i]} :: 0 <= i < |Zip(xs, ys)| ==> Zip(xs, ys)[i] == (xs[i], ys[i])
    ensures Unzip(Zip(xs, ys)).0 == xs
    ensures Unzip(Zip(xs, ys)).1 == ys
    decreases xs, ys
  {
    if |xs| == 0 then
      []
    else
      Zip(DropLast(xs), DropLast(ys)) + [(Last(xs), Last(ys))]
  }

  lemma /*{:_inductionTrigger Unzip(xs)}*/ /*{:_induction xs}*/ LemmaZipOfUnzip<A, B>(xs: seq<(A, B)>)
    ensures Zip(Unzip(xs).0, Unzip(xs).1) == xs
    decreases xs
  {
  }

  function method {:opaque} Max(xs: seq<int>): int
    requires 0 < |xs|
    ensures forall k: int {:trigger k in xs} :: k in xs ==> Max(xs) >= k
    ensures Max(xs) in xs
    decreases xs
  {
    assert xs == [xs[0]] + xs[1..];
    if |xs| == 1 then
      xs[0]
    else
      Math.Max(xs[0], Max(xs[1..]))
  }

  lemma /*{:_inductionTrigger xs + ys}*/ /*{:_inductionTrigger |ys|, |xs|}*/ /*{:_induction xs, ys}*/ LemmaMaxOfConcat(xs: seq<int>, ys: seq<int>)
    requires 0 < |xs| && 0 < |ys|
    ensures Max(xs + ys) >= Max(xs)
    ensures Max(xs + ys) >= Max(ys)
    ensures forall i: int {:trigger i in [Max(xs + ys)]} :: i in xs + ys ==> Max(xs + ys) >= i
    decreases xs, ys
  {
    reveal Max();
    if |xs| == 1 {
    } else {
      assert xs[1..] + ys == (xs + ys)[1..];
      LemmaMaxOfConcat(xs[1..], ys);
    }
  }

  function method {:opaque} Min(xs: seq<int>): int
    requires 0 < |xs|
    ensures forall k: int {:trigger k in xs} :: k in xs ==> Min(xs) <= k
    ensures Min(xs) in xs
    decreases xs
  {
    assert xs == [xs[0]] + xs[1..];
    if |xs| == 1 then
      xs[0]
    else
      Math.Min(xs[0], Min(xs[1..]))
  }

  lemma /*{:_inductionTrigger xs + ys}*/ /*{:_inductionTrigger |ys|, |xs|}*/ /*{:_induction xs, ys}*/ LemmaMinOfConcat(xs: seq<int>, ys: seq<int>)
    requires 0 < |xs| && 0 < |ys|
    ensures Min(xs + ys) <= Min(xs)
    ensures Min(xs + ys) <= Min(ys)
    ensures forall i: int {:trigger i in xs + ys} :: i in xs + ys ==> Min(xs + ys) <= i
    decreases xs, ys
  {
    reveal Min();
    if |xs| == 1 {
    } else {
      assert xs[1..] + ys == (xs + ys)[1..];
      LemmaMinOfConcat(xs[1..], ys);
    }
  }

  lemma /*{:_inductionTrigger xs[from .. to]}*/ /*{:_inductionTrigger |xs|}*/ /*{:_induction xs}*/ LemmaSubseqMax(xs: seq<int>, from: nat, to: nat)
    requires from < to <= |xs|
    ensures Max(xs[from .. to]) <= Max(xs)
    decreases xs, from, to
  {
    ghost var subseq := xs[from .. to];
    if Max(subseq) > Max(xs) {
      ghost var k :| 0 <= k < |subseq| && subseq[k] == Max(subseq);
      assert xs[seq(|subseq|, (i: int) requires 0 <= i < |subseq| => i + from)[k]] in xs;
      assert false;
    }
  }

  lemma /*{:_inductionTrigger xs[from .. to]}*/ /*{:_inductionTrigger |xs|}*/ /*{:_induction xs}*/ LemmaSubseqMin(xs: seq<int>, from: nat, to: nat)
    requires from < to <= |xs|
    ensures Min(xs[from .. to]) >= Min(xs)
    decreases xs, from, to
  {
    ghost var subseq := xs[from .. to];
    if Min(subseq) < Min(xs) {
      ghost var k :| 0 <= k < |subseq| && subseq[k] == Min(subseq);
      assert xs[seq(|subseq|, (i: int) requires 0 <= i < |subseq| => i + from)[k]] in xs;
    }
  }

  function method Flatten<T>(xs: seq<seq<T>>): seq<T>
    decreases |xs|
  {
    if |xs| == 0 then
      []
    else
      xs[0] + Flatten(xs[1..])
  }

  lemma /*{:_inductionTrigger Flatten(xs) + Flatten(ys)}*/ /*{:_inductionTrigger Flatten(xs + ys)}*/ /*{:_induction xs, ys}*/ LemmaFlattenConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)
    ensures Flatten(xs + ys) == Flatten(xs) + Flatten(ys)
    decreases xs, ys
  {
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc == {
        Flatten(xs + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        xs[0] + Flatten(xs[1..] + ys);
        xs[0] + Flatten(xs[1..]) + Flatten(ys);
        Flatten(xs) + Flatten(ys);
      }
    }
  }

  function method FlattenReverse<T>(xs: seq<seq<T>>): seq<T>
    decreases |xs|
  {
    if |xs| == 0 then
      []
    else
      FlattenReverse(DropLast(xs)) + Last(xs)
  }

  lemma /*{:_inductionTrigger FlattenReverse(xs) + FlattenReverse(ys)}*/ /*{:_inductionTrigger FlattenReverse(xs + ys)}*/ /*{:_induction xs, ys}*/ LemmaFlattenReverseConcat<T>(xs: seq<seq<T>>, ys: seq<seq<T>>)
    ensures FlattenReverse(xs + ys) == FlattenReverse(xs) + FlattenReverse(ys)
    decreases xs, ys
  {
    if |ys| == 0 {
      assert FlattenReverse(ys) == [];
      assert xs + ys == xs;
    } else {
      calc == {
        FlattenReverse(xs + ys);
        {
          assert Last(xs + ys) == Last(ys);
          assert DropLast(xs + ys) == xs + DropLast(ys);
        }
        FlattenReverse(xs + DropLast(ys)) + Last(ys);
        FlattenReverse(xs) + FlattenReverse(DropLast(ys)) + Last(ys);
        FlattenReverse(xs) + FlattenReverse(ys);
      }
    }
  }

  lemma /*{:_inductionTrigger FlattenReverse(xs)}*/ /*{:_inductionTrigger Flatten(xs)}*/ /*{:_induction xs}*/ LemmaFlattenAndFlattenReverseAreEquivalent<T>(xs: seq<seq<T>>)
    ensures Flatten(xs) == FlattenReverse(xs)
    decreases xs
  {
    if |xs| == 0 {
    } else {
      calc == {
        FlattenReverse(xs);
        FlattenReverse(DropLast(xs)) + Last(xs);
        {
          LemmaFlattenAndFlattenReverseAreEquivalent(DropLast(xs));
        }
        Flatten(DropLast(xs)) + Last(xs);
        Flatten(DropLast(xs)) + Flatten([Last(xs)]);
        {
          LemmaFlattenConcat(DropLast(xs), [Last(xs)]);
          assert xs == DropLast(xs) + [Last(xs)];
        }
        Flatten(xs);
      }
    }
  }

  lemma /*{:_inductionTrigger xs[i]}*/ /*{:_inductionTrigger FlattenReverse(xs)}*/ /*{:_induction xs}*/ LemmaFlattenLengthGeSingleElementLength<T>(xs: seq<seq<T>>, i: int)
    requires 0 <= i < |xs|
    ensures |FlattenReverse(xs)| >= |xs[i]|
    decreases xs, i
  {
    if i < |xs| - 1 {
      LemmaFlattenLengthGeSingleElementLength(xs[..|xs| - 1], i);
    }
  }

  lemma /*{:_inductionTrigger |xs| * j}*/ /*{:_inductionTrigger FlattenReverse(xs)}*/ /*{:_induction xs}*/ LemmaFlattenLengthLeMul<T>(xs: seq<seq<T>>, j: int)
    requires forall i: int {:trigger xs[i]} | 0 <= i < |xs| :: |xs[i]| <= j
    ensures |FlattenReverse(xs)| <= |xs| * j
    decreases xs, j
  {
    if |xs| == 0 {
    } else {
      LemmaFlattenLengthLeMul(xs[..|xs| - 1], j);
      assert |FlattenReverse(xs[..|xs| - 1])| <= (|xs| - 1) * j;
    }
  }

  function method {:opaque} Map<T, R>(f: T ~> R, xs: seq<T>): (result: seq<R>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| == |xs|
    ensures forall i: int {:trigger result[i]} :: 0 <= i < |xs| ==> result[i] == f(xs[i])
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    seq(|xs|, (i: int) requires 0 <= i < |xs| && f.requires(xs[i]) reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o => f(xs[i]))
  }

  function method {:opaque} MapWithResult<T, R, E>(f: T ~> Result<R, E>, xs: seq<T>): (result: Result<seq<R>, E>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures result.Success? ==> |result.value| == |xs| && forall i: int {:trigger result.value[i]} {:trigger xs[i]} :: (0 <= i < |xs| ==> f(xs[i]).Success?) && (0 <= i < |xs| ==> result.value[i] == f(xs[i]).value)
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    if |xs| == 0 then
      Success([])
    else
      var head: R :- f(xs[0]); var tail: seq<R> :- MapWithResult(f, xs[1..]); Success([head] + tail)
  }

  lemma LemmaMapDistributesOverConcat<T, R>(f: T ~> R, xs: seq<T>, ys: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    requires forall j: int {:trigger ys[j]} :: 0 <= j < |ys| ==> f.requires(ys[j])
    ensures Map(f, xs + ys) == Map(f, xs) + Map(f, ys)
    decreases xs, ys
  {
    reveal Map();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        Map(f, xs + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        Map(f, [xs[0]]) + Map(f, xs[1..] + ys);
        Map(f, [xs[0]]) + Map(f, xs[1..]) + Map(f, ys);
        {
          assert [(xs + ys)[0]] + xs[1..] + ys == xs + ys;
        }
        Map(f, xs) + Map(f, ys);
      }
    }
  }

  function method {:opaque} Filter<T>(f: T ~> bool, xs: seq<T>): (result: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| <= |xs|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    if |xs| == 0 then
      []
    else
      (if f(xs[0]) then [xs[0]] else []) + Filter(f, xs[1..])
  }

  lemma /*{:_inductionTrigger Filter(f, xs) + Filter(f, ys)}*/ /*{:_inductionTrigger Filter(f, xs + ys)}*/ /*{:_inductionTrigger |ys|, |xs|}*/ /*{:_induction xs, ys}*/ LemmaFilterDistributesOverConcat<T>(f: T ~> bool, xs: seq<T>, ys: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    requires forall j: int {:trigger ys[j]} :: 0 <= j < |ys| ==> f.requires(ys[j])
    ensures Filter(f, xs + ys) == Filter(f, xs) + Filter(f, ys)
    decreases xs, ys
  {
    reveal Filter();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        Filter(f, xs + ys);
        {
          assert {:split_here} (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        Filter(f, [xs[0]]) + Filter(f, xs[1..] + ys);
        {
          assert Filter(f, xs[1..] + ys) == Filter(f, xs[1..]) + Filter(f, ys);
        }
        Filter(f, [xs[0]]) + (Filter(f, xs[1..]) + Filter(f, ys));
        {
          assert {:split_here} [(xs + ys)[0]] + (xs[1..] + ys) == xs + ys;
        }
        Filter(f, xs) + Filter(f, ys);
      }
    }
  }

  function method {:opaque} FoldLeft<A, T>(f: (A, T) -> A, init: A, xs: seq<T>): A
    decreases xs
  {
    if |xs| == 0 then
      init
    else
      FoldLeft(f, f(init, xs[0]), xs[1..])
  }

  lemma /*{:_inductionTrigger FoldLeft(f, FoldLeft(f, init, xs), ys)}*/ /*{:_inductionTrigger xs + ys}*/ /*{:_induction xs, ys}*/ LemmaFoldLeftDistributesOverConcat<A, T>(f: (A, T) -> A, init: A, xs: seq<T>, ys: seq<T>)
    requires 0 <= |xs + ys|
    ensures FoldLeft(f, init, xs + ys) == FoldLeft(f, FoldLeft(f, init, xs), ys)
    decreases xs, ys
  {
    reveal FoldLeft();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      assert |xs| >= 1;
      assert ([xs[0]] + xs[1..] + ys)[0] == xs[0];
      calc {
        FoldLeft(f, FoldLeft(f, init, xs), ys);
        FoldLeft(f, FoldLeft(f, f(init, xs[0]), xs[1..]), ys);
        {
          LemmaFoldLeftDistributesOverConcat(f, f(init, xs[0]), xs[1..], ys);
        }
        FoldLeft(f, f(init, xs[0]), xs[1..] + ys);
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        FoldLeft(f, init, xs + ys);
      }
    }
  }

  predicate InvFoldLeft<A(!new), B(!new)>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B {:trigger stp(b, x, b'), [x] + xs} :: 
      inv(b, [x] + xs) &&
      stp(b, x, b') ==>
        inv(b', xs)
  }

  lemma /*{:_inductionTrigger FoldLeft(f, b, xs)}*/ /*{:_inductionTrigger inv(b, xs)}*/ /*{:_induction xs}*/ LemmaInvFoldLeft<A(!new), B(!new)>(inv: (B, seq<A>) -> bool, stp: (B, A, B) -> bool, f: (B, A) -> B, b: B, xs: seq<A>)
    requires InvFoldLeft(inv, stp)
    requires forall b: B, a: A {:trigger f(b, a)} :: stp(b, a, f(b, a))
    requires inv(b, xs)
    ensures inv(FoldLeft(f, b, xs), [])
    decreases xs
  {
    reveal FoldLeft();
    if xs == [] {
    } else {
      assert [xs[0]] + xs[1..] == xs;
      LemmaInvFoldLeft(inv, stp, f, f(b, xs[0]), xs[1..]);
    }
  }

  function method {:opaque} FoldRight<A, T>(f: (T, A) -> A, xs: seq<T>, init: A): A
    decreases xs
  {
    if |xs| == 0 then
      init
    else
      f(xs[0], FoldRight(f, xs[1..], init))
  }

  lemma /*{:_inductionTrigger FoldRight(f, xs, FoldRight(f, ys, init))}*/ /*{:_inductionTrigger xs + ys}*/ /*{:_induction xs, ys}*/ LemmaFoldRightDistributesOverConcat<A, T>(f: (T, A) -> A, init: A, xs: seq<T>, ys: seq<T>)
    requires 0 <= |xs + ys|
    ensures FoldRight(f, xs + ys, init) == FoldRight(f, xs, FoldRight(f, ys, init))
    decreases xs, ys
  {
    reveal FoldRight();
    if |xs| == 0 {
      assert xs + ys == ys;
    } else {
      calc {
        FoldRight(f, xs, FoldRight(f, ys, init));
        f(xs[0], FoldRight(f, xs[1..], FoldRight(f, ys, init)));
        f(xs[0], FoldRight(f, xs[1..] + ys, init));
        {
          assert (xs + ys)[0] == xs[0];
          assert (xs + ys)[1..] == xs[1..] + ys;
        }
        FoldRight(f, xs + ys, init);
      }
    }
  }

  predicate InvFoldRight<A(!new), B(!new)>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool)
  {
    forall x: A, xs: seq<A>, b: B, b': B {:trigger [x] + xs, stp(x, b, b')} :: 
      inv(xs, b) &&
      stp(x, b, b') ==>
        inv([x] + xs, b')
  }

  lemma /*{:_inductionTrigger FoldRight(f, xs, b)}*/ /*{:_induction xs}*/ LemmaInvFoldRight<A(!new), B(!new)>(inv: (seq<A>, B) -> bool, stp: (A, B, B) -> bool, f: (A, B) -> B, b: B, xs: seq<A>)
    requires InvFoldRight(inv, stp)
    requires forall a: A, b: B {:trigger f(a, b)} :: stp(a, b, f(a, b))
    requires inv([], b)
    ensures inv(xs, FoldRight(f, xs, b))
    decreases xs
  {
    reveal FoldRight();
    if xs == [] {
    } else {
      assert [xs[0]] + xs[1..] == xs;
    }
  }

  function FlatMap<T, R>(f: T ~> seq<R>, xs: seq<T>): (result: seq<R>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    Flatten(Map(f, xs))
  } by method {
    result := [];
    ghost var unflattened: seq<seq<R>> := [];
    for i: int := |xs| downto 0
      invariant unflattened == Map(f, xs[i..])
      invariant result == Flatten(unflattened)
    {
      var next := f(xs[i]);
      unflattened := [next] + unflattened;
      result := next + result;
    }
  }

  import opened Wrappers

  import opened MergeSort

  import opened Relations

  import Math

  module {:options "-functionSyntax:4"} MergeSort {
    function method MergeSortBy<T(!new)>(a: seq<T>, lessThanOrEq: (T, T) -> bool): (result: seq<T>)
      requires TotalOrdering(lessThanOrEq)
      ensures multiset(a) == multiset(result)
      ensures SortedBy(result, lessThanOrEq)
      decreases a
    {
      if |a| <= 1 then
        a
      else
        var splitIndex: int := |a| / 2; var left: seq<T>, right: seq<T> := a[..splitIndex], a[splitIndex..]; assert a == left + right; var leftSorted: seq<T> := MergeSortBy(left, lessThanOrEq); var rightSorted: seq<T> := MergeSortBy(right, lessThanOrEq); MergeSortedWith(leftSorted, rightSorted, lessThanOrEq)
    }

    function method {:tailrecursion} MergeSortedWith<T(!new)>(left: seq<T>, right: seq<T>, lessThanOrEq: (T, T) -> bool): (result: seq<T>)
      requires SortedBy(left, lessThanOrEq)
      requires SortedBy(right, lessThanOrEq)
      requires TotalOrdering(lessThanOrEq)
      ensures multiset(left + right) == multiset(result)
      ensures SortedBy(result, lessThanOrEq)
      decreases left, right
    {
      if |left| == 0 then
        right
      else if |right| == 0 then
        left
      else if lessThanOrEq(left[0], right[0]) then
        LemmaNewFirstElementStillSortedBy(left[0], MergeSortedWith(left[1..], right, lessThanOrEq), lessThanOrEq);
        assert left == [left[0]] + left[1..];
        [left[0]] + MergeSortedWith(left[1..], right, lessThanOrEq)
      else
        LemmaNewFirstElementStillSortedBy(right[0], MergeSortedWith(left, right[1..], lessThanOrEq), lessThanOrEq); assert right == [right[0]] + right[1..]; [right[0]] + MergeSortedWith(left, right[1..], lessThanOrEq)
    }

    import opened Relations
  }
}

module {:options "-functionSyntax:4"} Relations {
  predicate Reflexive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T {:trigger R(x, x)} :: 
      R(x, x)
  }

  predicate Irreflexive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T {:trigger R(x, x)} :: 
      !R(x, x)
  }

  predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      R(x, y) &&
      R(y, x) ==>
        x == y
  }

  predicate Symmetric<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      R(x, y) <==> R(y, x)
  }

  predicate Connected<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      x != y ==>
        R(x, y) || R(y, x)
  }

  predicate StronglyConnected<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      R(x, y) || R(y, x)
  }

  predicate Transitive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T, z: T {:trigger R(x, z), R(y, z)} {:trigger R(y, z), R(x, y)} :: 
      R(x, y) &&
      R(y, z) ==>
        R(x, z)
  }

  predicate TotalOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    AntiSymmetric(R) &&
    Transitive(R) &&
    StronglyConnected(R)
  }

  predicate StrictTotalOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Irreflexive(R) &&
    AntiSymmetric(R) &&
    Transitive(R) &&
    Connected(R)
  }

  predicate PreOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    Transitive(R)
  }

  predicate PartialOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    Transitive(R) &&
    AntiSymmetric(R)
  }

  predicate EquivalenceRelation<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    Symmetric(R) &&
    Transitive(R)
  }

  predicate SortedBy<T>(a: seq<T>, lessThan: (T, T) -> bool)
    decreases a
  {
    forall i: int, j: int {:trigger a[j], a[i]} | 0 <= i < j < |a| :: 
      lessThan(a[i], a[j])
  }

  predicate IsLeast<T>(R: (T, T) -> bool, min: T, s: set<T>)
    decreases s
  {
    min in s &&
    forall x: T {:trigger R(min, x)} {:trigger x in s} | x in s :: 
      R(min, x)
  }

  predicate IsMinimal<T>(R: (T, T) -> bool, min: T, s: set<T>)
    decreases s
  {
    min in s &&
    forall x: T {:trigger R(min, x)} {:trigger R(x, min)} {:trigger x in s} | x in s && R(x, min) :: 
      R(min, x)
  }

  predicate IsGreatest<T>(R: (T, T) -> bool, max: T, s: set<T>)
    decreases s
  {
    max in s &&
    forall x: T {:trigger R(x, max)} {:trigger x in s} | x in s :: 
      R(x, max)
  }

  predicate IsMaximal<T>(R: (T, T) -> bool, max: T, s: set<T>)
    decreases s
  {
    max in s &&
    forall x: T {:trigger R(x, max)} {:trigger R(max, x)} {:trigger x in s} | x in s && R(max, x) :: 
      R(x, max)
  }

  lemma LemmaNewFirstElementStillSortedBy<T(!new)>(x: T, s: seq<T>, lessThan: (T, T) -> bool)
    requires SortedBy(s, lessThan)
    requires |s| == 0 || lessThan(x, s[0])
    requires TotalOrdering(lessThan)
    ensures SortedBy([x] + s, lessThan)
    decreases s
  {
  }
}

module {:options "-functionSyntax:4"} Math {
  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Max(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      b
    else
      a
  }

  function method Abs(a: int): (a': int)
    ensures a' >= 0
    decreases a
  {
    if a >= 0 then
      a
    else
      -a
  }
}

module {:options "-functionSyntax:4"} Wrappers {
  function method Need<E>(condition: bool, error: E): (result: Outcome<E>)
    decreases condition
  {
    if condition then
      Pass
    else
      Fail(error)
  }

  function method FNeed<E>(condition: bool, error: () --> E): (result: Outcome<E>)
    requires !condition ==> error.requires()
    decreases condition
  {
    if condition then
      Pass
    else
      Fail(error())
  }

  datatype Option<+T> = None | Some(value: T) {
    function method ToResult(): Result<T, string>
      decreases this
    {
      match this
      case Some(v) =>
        Success(v)
      case None() =>
        Failure("Option is None")
    }

    function method ToResult'<R>(error: R): Result<T, R>
      decreases this
    {
      match this
      case Some(v) =>
        Success(v)
      case None() =>
        Failure(error)
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Some(v) =>
        v
      case None() =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      None?
    }

    function method PropagateFailure<U>(): Option<U>
      requires None?
      decreases this
    {
      None
    }

    function method Extract(): T
      requires Some?
      decreases this
    {
      value
    }
  }

  datatype Result<+T, +R> = Success(value: T) | Failure(error: R) {
    function method ToOption(): Option<T>
      decreases this
    {
      match this
      case Success(s) =>
        Some(s)
      case Failure(e) =>
        None()
    }

    function method UnwrapOr(default: T): T
      decreases this
    {
      match this
      case Success(s) =>
        s
      case Failure(e) =>
        default
    }

    predicate method IsFailure()
      decreases this
    {
      Failure?
    }

    function method PropagateFailure<U>(): Result<U, R>
      requires Failure?
      decreases this
    {
      Failure(this.error)
    }

    function method MapFailure<NewR>(reWrap: R -> NewR): Result<T, NewR>
      decreases this
    {
      match this
      case Success(s) =>
        Success(s)
      case Failure(e) =>
        Failure(reWrap(e))
    }

    function method Extract(): T
      requires Success?
      decreases this
    {
      value
    }
  }

  datatype Outcome<E> = Pass | Fail(error: E) {
    predicate method IsFailure()
      decreases this
    {
      Fail?
    }

    function method PropagateFailure<U>(): Result<U, E>
      requires Fail?
      decreases this
    {
      Failure(this.error)
    }
  }
}

abstract module {:options "-functionSyntax:4"} AbstractUnicodeStrings {
  function method ToUTF8Checked(s: string): Option<seq<uint8>>
    decreases s

  function method ASCIIToUTF8(s: string): seq<uint8>
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: 0 <= s[i] as int && s[i] as int < 128
    decreases s
  {
    Seq.Map((c: char) requires 0 <= c as int < 128 => c as uint8, s)
  }

  function method FromUTF8Checked(bs: seq<uint8>): Option<string>
    decreases bs

  function method ToUTF16Checked(s: string): Option<seq<uint16>>
    decreases s

  function method ASCIIToUTF16(s: string): seq<uint16>
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: 0 <= s[i] as int && s[i] as int < 128
    decreases s
  {
    Seq.Map((c: char) requires 0 <= c as int < 128 => c as uint16, s)
  }

  function method FromUTF16Checked(bs: seq<uint16>): Option<string>
    decreases bs

  import Seq

  import opened Wrappers

  import opened BoundedInts
}

module {:options "-functionSyntax:4"} Utf16EncodingForm refines UnicodeEncodingForm {
  function method IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
    ensures b ==> |s| > 0 && forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases |s|
  {
    if |s| == 1 then
      IsWellFormedSingleCodeUnitSequence(s)
    else if |s| == 2 then
      var b: bool := IsWellFormedDoubleCodeUnitSequence(s);
      assert b ==> forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else
      false
  }

  function method IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 1
    decreases s
  {
    var firstWord: bv16 := s[0];
    0 <= firstWord <= 55295 || 57344 <= firstWord <= 65535
  }

  function method IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 2
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1])
    decreases s
  {
    var firstWord: bv16 := s[0];
    var secondWord: bv16 := s[1];
    55296 <= firstWord <= 56319 &&
    56320 <= secondWord <= 57343
  }

  function method SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i: int {:trigger s[..i]} | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix: MinimalWellFormedCodeUnitSeq := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && forall i: int {:trigger s[..i]} | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i: int {:trigger s[..i]} | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix: MinimalWellFormedCodeUnitSeq := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && IsMinimalWellFormedCodeUnitSubsequence(prefix)
    decreases s
  {
    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then
      Some(s[..1])
    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then
      Some(s[..2])
    else
      None
  }

  function method EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    decreases v
  {
    if 0 <= v <= 55295 || 57344 <= v <= 65535 then
      EncodeScalarValueSingleWord(v)
    else
      EncodeScalarValueDoubleWord(v)
  }

  function method EncodeScalarValueSingleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 0 <= v <= 55295 || 57344 <= v <= 65535
    ensures |m| == 1
    ensures IsWellFormedSingleCodeUnitSequence(m)
    decreases v
  {
    var firstWord: CodeUnit := v as CodeUnit;
    [firstWord]
  }

  function method EncodeScalarValueDoubleWord(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 65536 <= v <= 1114111
    ensures |m| == 2
    ensures IsWellFormedDoubleCodeUnitSequence(m)
    decreases v
  {
    var x2: bv10 := (v & 1023) as bv10;
    var x1: bv6 := (v & 64512 >> 10 as bv5) as bv6;
    var u: bv5 := (v & 2031616 >> 16 as bv5) as bv5;
    var w: bv4 := (u - 1) as bv4;
    var firstWord: bv16 := 55296 | (w as CodeUnit << 6 as bv5) | x1 as CodeUnit;
    var secondWord: bv16 := 56320 | x2 as CodeUnit;
    [firstWord, secondWord]
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    ensures EncodeScalarValue(v) == m
    decreases m
  {
    if |m| == 1 then
      DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m)
    else
      assert |m| == 2; DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m)
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceSingleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 1
    ensures 0 <= v <= 55295 || 57344 <= v <= 65535
    ensures EncodeScalarValueSingleWord(v) == m
    decreases m
  {
    var firstWord: bv16 := m[0];
    var x: bv16 := firstWord as bv16;
    assert EncodeScalarValueSingleWord(x as Unicode.ScalarValue) == m;
    x as Unicode.ScalarValue
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceDoubleWord(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 2
    ensures 65536 <= v <= 1114111
    ensures EncodeScalarValueDoubleWord(v) == m
    decreases m
  {
    var firstWord: bv16 := m[0];
    var secondWord: bv16 := m[1];
    var x2: bv24 := (secondWord & 1023) as bv24;
    var x1: bv24 := (firstWord & 63) as bv24;
    var w: bv24 := (firstWord & 960 >> 6 as bv5) as bv24;
    var u: bv24 := (w + 1) as bv24;
    var v: bv24 := (u << 16 as bv5) | (x1 << 10 as bv5) | x2 as Unicode.ScalarValue;
    assert {:split_here} true;
    assert EncodeScalarValueDoubleWord(v) == m;
    v
  }

  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)
    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)
    decreases m, s
  {
    ghost var ms := m + s;
    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);
    ghost var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();
    calc ==> {
      IsMinimalWellFormedCodeUnitSubsequence(m);
      |prefix| <= |m|;
      prefix == ms[..|prefix|] == m[..|prefix|] == m;
    }
  }

  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)
    ensures maybeParts.Some? ==> Seq.Flatten(maybeParts.Extract()) == s
    decreases |s|
  {
    if s == [] then
      Some([])
    else
      var prefix: MinimalWellFormedCodeUnitSeq :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(s); var restParts: seq<MinimalWellFormedCodeUnitSeq> :- PartitionCodeUnitSequenceChecked(s[|prefix|..]); Some([prefix] + restParts)
  } by method {
    if s == [] {
      return Some([]);
    }
    var result: seq<MinimalWellFormedCodeUnitSeq> := [];
    var rest := s;
    while |rest| > 0
      invariant PartitionCodeUnitSequenceChecked(s).Some? <==> PartitionCodeUnitSequenceChecked(rest).Some?
      invariant PartitionCodeUnitSequenceChecked(s).Some? ==> true && PartitionCodeUnitSequenceChecked(s).value == result + PartitionCodeUnitSequenceChecked(rest).value
      decreases |rest| - 0
    {
      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(rest);
      result := result + [prefix];
      rest := rest[|prefix|..];
    }
    assert result + [] == result;
    return Some(result);
  }

  function method PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)
    ensures Seq.Flatten(parts) == s
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Extract()
  }

  lemma /*{:_inductionTrigger [m]}*/ /*{:_inductionTrigger PartitionCodeUnitSequenceChecked(m)}*/ /*{:_induction m}*/ LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)
    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])
    decreases m
  {
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);
    calc == {
      Some(m);
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);
      {
        assert m + [] == m;
      }
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);
    }
    calc == {
      PartitionCodeUnitSequenceChecked(m);
      Some([m] + []);
      {
        assert [m] + [] == [m];
      }
      Some([m]);
    }
  }

  function method IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Some?
  }

  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m)
    decreases m
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
  }

  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m + s)
    decreases m, s
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);
    assert PartitionCodeUnitSequenceChecked(m + s).Some?;
  }

  lemma /*{:_inductionTrigger _default.Flatten(ms)}*/ /*{:_induction ms}*/ LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)
    ensures IsWellFormedCodeUnitSequence(Seq.Flatten(ms))
    decreases ms
  {
    if |ms| == 0 {
      assert IsWellFormedCodeUnitSequence(Seq.Flatten(ms));
    } else {
      ghost var head := ms[0];
      ghost var tail := ms[1..];
      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);
      ghost var flatTail := Seq.Flatten(tail);
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);
      assert IsWellFormedCodeUnitSequence(head + flatTail);
    }
  }

  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(s + t)
    decreases s, t
  {
    ghost var partsS := PartitionCodeUnitSequence(s);
    ghost var partsT := PartitionCodeUnitSequence(t);
    ghost var partsST := partsS + partsT;
    Seq.LemmaFlattenConcat(partsS, partsT);
    assert s + t == Seq.Flatten(partsST);
    assert forall part: CodeUnitSeq {:trigger IsMinimalWellFormedCodeUnitSubsequence(part)} {:trigger |part|} {:trigger part in partsST} | part in partsST :: |part| > 0 && IsMinimalWellFormedCodeUnitSubsequence(part);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);
  }

  function EncodeScalarSequence(vs: seq<Unicode.ScalarValue>): (s: WellFormedCodeUnitSeq)
    decreases vs
  {
    var ms: seq<MinimalWellFormedCodeUnitSeq> := Seq.Map(EncodeScalarValue, vs);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);
    Seq.Flatten(ms)
  } by method {
    s := [];
    ghost var unflattened: seq<MinimalWellFormedCodeUnitSeq> := [];
    for i: int := |vs| downto 0
      invariant unflattened == Seq.Map(EncodeScalarValue, vs[i..])
      invariant s == Seq.Flatten(unflattened)
    {
      var next: MinimalWellFormedCodeUnitSeq := EncodeScalarValue(vs[i]);
      unflattened := [next] + unflattened;
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(next, s);
      s := next + s;
    }
  }

  function method DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<Unicode.ScalarValue>)
    ensures EncodeScalarSequence(vs) == s
    decreases s
  {
    var parts: seq<MinimalWellFormedCodeUnitSeq> := PartitionCodeUnitSequence(s);
    var vs: seq<Unicode.ScalarValue> := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    vs
  }

  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<Unicode.ScalarValue>>)
    ensures IsWellFormedCodeUnitSequence(s) ==> maybeVs.Some? && maybeVs.Extract() == DecodeCodeUnitSequence(s)
    ensures !IsWellFormedCodeUnitSequence(s) ==> true && maybeVs.None?
    decreases s
  {
    if IsWellFormedCodeUnitSequence(s) then
      Some(DecodeCodeUnitSequence(s))
    else
      None
  } by method {
    var maybeParts := PartitionCodeUnitSequenceChecked(s);
    if maybeParts.None? {
      return None;
    }
    var parts := maybeParts.value;
    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    return Some(vs);
  }

  type CodeUnit = bv16

  import opened Wrappers

  import Functions

  import Seq

  import Unicode

  type CodeUnitSeq = seq<CodeUnit>

  type WellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsWellFormedCodeUnitSequence(s)
    witness []

  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsMinimalWellFormedCodeUnitSubsequence(s)
    witness *
}

abstract module {:options "-functionSyntax:4"} UnicodeEncodingForm {
  function method IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
    ensures b ==> |s| > 0 && forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases |s|

  function method SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i: int {:trigger s[..i]} | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix: MinimalWellFormedCodeUnitSeq := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && forall i: int {:trigger s[..i]} | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases s

  function method EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    decreases v

  function method DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    ensures EncodeScalarValue(v) == m
    decreases m

  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)
    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)
    decreases m, s
  {
    ghost var ms := m + s;
    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);
    ghost var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();
    calc ==> {
      IsMinimalWellFormedCodeUnitSubsequence(m);
      |prefix| <= |m|;
      prefix == ms[..|prefix|] == m[..|prefix|] == m;
    }
  }

  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)
    ensures maybeParts.Some? ==> Seq.Flatten(maybeParts.Extract()) == s
    decreases |s|
  {
    if s == [] then
      Some([])
    else
      var prefix: MinimalWellFormedCodeUnitSeq :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(s); var restParts: seq<MinimalWellFormedCodeUnitSeq> :- PartitionCodeUnitSequenceChecked(s[|prefix|..]); Some([prefix] + restParts)
  } by method {
    if s == [] {
      return Some([]);
    }
    var result: seq<MinimalWellFormedCodeUnitSeq> := [];
    var rest := s;
    while |rest| > 0
      invariant PartitionCodeUnitSequenceChecked(s).Some? <==> PartitionCodeUnitSequenceChecked(rest).Some?
      invariant PartitionCodeUnitSequenceChecked(s).Some? ==> true && PartitionCodeUnitSequenceChecked(s).value == result + PartitionCodeUnitSequenceChecked(rest).value
      decreases |rest| - 0
    {
      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(rest);
      result := result + [prefix];
      rest := rest[|prefix|..];
    }
    assert result + [] == result;
    return Some(result);
  }

  function method PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)
    ensures Seq.Flatten(parts) == s
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Extract()
  }

  lemma /*{:_inductionTrigger [m]}*/ /*{:_inductionTrigger PartitionCodeUnitSequenceChecked(m)}*/ /*{:_induction m}*/ LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)
    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])
    decreases m
  {
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);
    calc == {
      Some(m);
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);
      {
        assert m + [] == m;
      }
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);
    }
    calc == {
      PartitionCodeUnitSequenceChecked(m);
      Some([m] + []);
      {
        assert [m] + [] == [m];
      }
      Some([m]);
    }
  }

  function method IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Some?
  }

  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m)
    decreases m
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
  }

  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m + s)
    decreases m, s
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);
    assert PartitionCodeUnitSequenceChecked(m + s).Some?;
  }

  lemma /*{:_inductionTrigger _default.Flatten(ms)}*/ /*{:_induction ms}*/ LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)
    ensures IsWellFormedCodeUnitSequence(Seq.Flatten(ms))
    decreases ms
  {
    if |ms| == 0 {
      assert IsWellFormedCodeUnitSequence(Seq.Flatten(ms));
    } else {
      ghost var head := ms[0];
      ghost var tail := ms[1..];
      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);
      ghost var flatTail := Seq.Flatten(tail);
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);
      assert IsWellFormedCodeUnitSequence(head + flatTail);
    }
  }

  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(s + t)
    decreases s, t
  {
    ghost var partsS := PartitionCodeUnitSequence(s);
    ghost var partsT := PartitionCodeUnitSequence(t);
    ghost var partsST := partsS + partsT;
    Seq.LemmaFlattenConcat(partsS, partsT);
    assert s + t == Seq.Flatten(partsST);
    assert forall part: CodeUnitSeq {:trigger IsMinimalWellFormedCodeUnitSubsequence(part)} {:trigger |part|} {:trigger part in partsST} | part in partsST :: |part| > 0 && IsMinimalWellFormedCodeUnitSubsequence(part);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);
  }

  function EncodeScalarSequence(vs: seq<Unicode.ScalarValue>): (s: WellFormedCodeUnitSeq)
    decreases vs
  {
    var ms: seq<MinimalWellFormedCodeUnitSeq> := Seq.Map(EncodeScalarValue, vs);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);
    Seq.Flatten(ms)
  } by method {
    s := [];
    ghost var unflattened: seq<MinimalWellFormedCodeUnitSeq> := [];
    for i: int := |vs| downto 0
      invariant unflattened == Seq.Map(EncodeScalarValue, vs[i..])
      invariant s == Seq.Flatten(unflattened)
    {
      var next: MinimalWellFormedCodeUnitSeq := EncodeScalarValue(vs[i]);
      unflattened := [next] + unflattened;
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(next, s);
      s := next + s;
    }
  }

  function method DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<Unicode.ScalarValue>)
    ensures EncodeScalarSequence(vs) == s
    decreases s
  {
    var parts: seq<MinimalWellFormedCodeUnitSeq> := PartitionCodeUnitSequence(s);
    var vs: seq<Unicode.ScalarValue> := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    vs
  }

  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<Unicode.ScalarValue>>)
    ensures IsWellFormedCodeUnitSequence(s) ==> maybeVs.Some? && maybeVs.Extract() == DecodeCodeUnitSequence(s)
    ensures !IsWellFormedCodeUnitSequence(s) ==> true && maybeVs.None?
    decreases s
  {
    if IsWellFormedCodeUnitSequence(s) then
      Some(DecodeCodeUnitSequence(s))
    else
      None
  } by method {
    var maybeParts := PartitionCodeUnitSequenceChecked(s);
    if maybeParts.None? {
      return None;
    }
    var parts := maybeParts.value;
    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    return Some(vs);
  }

  import opened Wrappers

  import Functions

  import Seq

  import Unicode

  type CodeUnitSeq = seq<CodeUnit>

  type WellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsWellFormedCodeUnitSequence(s)
    witness []

  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsMinimalWellFormedCodeUnitSubsequence(s)
    witness *

  type CodeUnit
}

module {:options "-functionSyntax:4"} Unicode {
  const HIGH_SURROGATE_MIN: CodePoint := 55296
  const HIGH_SURROGATE_MAX: CodePoint := 56319
  const LOW_SURROGATE_MIN: CodePoint := 56320
  const LOW_SURROGATE_MAX: CodePoint := 57343
  const ASSIGNED_PLANES: set<bv8> := {0, 1, 2, 3, 14, 15, 16}

  predicate {:opaque} IsInAssignedPlane(i: CodePoint)
    decreases i
  {
    ghost var plane: bv8 := (i >> 16 as bv5) as bv8;
    plane in ASSIGNED_PLANES
  }

  import opened Wrappers

  import Seq

  type CodePoint = i: bv24
    | 0 <= i <= 1114111

  type HighSurrogateCodePoint = p: CodePoint
    | HIGH_SURROGATE_MIN <= p <= HIGH_SURROGATE_MAX
    witness HIGH_SURROGATE_MIN

  type LowSurrogateCodePoint = p: CodePoint
    | LOW_SURROGATE_MIN <= p <= LOW_SURROGATE_MAX
    witness LOW_SURROGATE_MIN

  type ScalarValue = p: CodePoint
    | (p < HIGH_SURROGATE_MIN || p > HIGH_SURROGATE_MAX) && (p < LOW_SURROGATE_MIN || p > LOW_SURROGATE_MAX)

  type AssignedCodePoint = p: CodePoint
    | IsInAssignedPlane(p)
    witness *
}

module {:options "-functionSyntax:4"} Functions {
  predicate Injective<X(!new), Y>(f: X --> Y)
    requires forall x: X {:trigger f.requires(x)} :: f.requires(x)
    reads set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
    decreases set _x0: X, _obj: object? /*{:_reads}*/ {:trigger _obj in f.reads(_x0)} | _obj in f.reads(_x0) :: _obj
  {
    forall x1: X, x2: X {:trigger f(x2), f(x1)} :: 
      f(x1) == f(x2) ==>
        x1 == x2
  }
}

module {:options "-functionSyntax:4"} Utf8EncodingForm refines UnicodeEncodingForm {
  function method IsMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (b: bool)
    ensures b ==> |s| > 0 && forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases |s|
  {
    if |s| == 1 then
      var b: bool := IsWellFormedSingleCodeUnitSequence(s);
      assert b ==> forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 2 then
      var b: bool := IsWellFormedDoubleCodeUnitSequence(s);
      assert b ==> forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 3 then
      var b: bool := IsWellFormedTripleCodeUnitSequence(s);
      assert b ==> forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else if |s| == 4 then
      var b: bool := IsWellFormedQuadrupleCodeUnitSequence(s);
      assert b ==> forall i: int {:trigger s[..i]} | 0 < i < |s| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i]);
      b
    else
      false
  }

  function method IsWellFormedSingleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 1
    decreases s
  {
    var firstByte: bv8 := s[0];
    true &&
    0 <= firstByte <= 127
  }

  function method IsWellFormedDoubleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 2
    ensures b ==> true && !IsWellFormedSingleCodeUnitSequence(s[..1])
    decreases s
  {
    var firstByte: bv8 := s[0];
    var secondByte: bv8 := s[1];
    194 <= firstByte <= 223 &&
    128 <= secondByte <= 191
  }

  function method IsWellFormedTripleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 3
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1]) && !IsWellFormedDoubleCodeUnitSequence(s[..2])
    decreases s
  {
    var firstByte: bv8 := s[0];
    var secondByte: bv8 := s[1];
    var thirdByte: bv8 := s[2];
    ((firstByte == 224 && 160 <= secondByte <= 191) || (225 <= firstByte <= 236 && 128 <= secondByte <= 191) || (firstByte == 237 && 128 <= secondByte <= 159) || (238 <= firstByte <= 239 && 128 <= secondByte <= 191)) &&
    128 <= thirdByte <= 191
  }

  function method IsWellFormedQuadrupleCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    requires |s| == 4
    ensures b ==> !IsWellFormedSingleCodeUnitSequence(s[..1]) && !IsWellFormedDoubleCodeUnitSequence(s[..2]) && !IsWellFormedTripleCodeUnitSequence(s[..3])
    decreases s
  {
    var firstByte: bv8 := s[0];
    var secondByte: bv8 := s[1];
    var thirdByte: bv8 := s[2];
    var fourthByte: bv8 := s[3];
    ((firstByte == 240 && 144 <= secondByte <= 191) || (241 <= firstByte <= 243 && 128 <= secondByte <= 191) || (firstByte == 244 && 128 <= secondByte <= 143)) &&
    128 <= thirdByte <= 191 &&
    128 <= fourthByte <= 191
  }

  function method SplitPrefixMinimalWellFormedCodeUnitSubsequence(s: CodeUnitSeq): (maybePrefix: Option<MinimalWellFormedCodeUnitSeq>)
    ensures |s| == 0 ==> maybePrefix.None?
    ensures (exists i: int {:trigger s[..i]} | 0 < i <= |s| :: IsMinimalWellFormedCodeUnitSubsequence(s[..i])) <==> true && maybePrefix.Some?
    ensures maybePrefix.Some? ==> true && var prefix: MinimalWellFormedCodeUnitSeq := maybePrefix.Extract(); 0 < |prefix| <= |s| && prefix == s[..|prefix|] && forall i: int {:trigger s[..i]} | 0 < i < |prefix| :: !IsMinimalWellFormedCodeUnitSubsequence(s[..i])
    decreases s
  {
    if |s| >= 1 && IsWellFormedSingleCodeUnitSequence(s[..1]) then
      Some(s[..1])
    else if |s| >= 2 && IsWellFormedDoubleCodeUnitSequence(s[..2]) then
      Some(s[..2])
    else if |s| >= 3 && IsWellFormedTripleCodeUnitSequence(s[..3]) then
      Some(s[..3])
    else if |s| >= 4 && IsWellFormedQuadrupleCodeUnitSequence(s[..4]) then
      Some(s[..4])
    else
      None
  }

  function method EncodeScalarValue(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    decreases v
  {
    if v <= 127 then
      EncodeScalarValueSingleByte(v)
    else if v <= 2047 then
      EncodeScalarValueDoubleByte(v)
    else if v <= 65535 then
      EncodeScalarValueTripleByte(v)
    else
      EncodeScalarValueQuadrupleByte(v)
  }

  function method EncodeScalarValueSingleByte(v: Unicode.ScalarValue): (m: MinimalWellFormedCodeUnitSeq)
    requires 0 <= v <= 127
    ensures |m| == 1
    ensures IsWellFormedSingleCodeUnitSequence(m)
    decreases v
  {
    var x: bv7 := (v & 127) as bv7;
    var firstByte: CodeUnit := x as CodeUnit;
    [firstByte]
  }

  function method EncodeScalarValueDoubleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)
    requires 128 <= v <= 2047
    ensures |s| == 2
    ensures IsWellFormedDoubleCodeUnitSequence(s)
    decreases v
  {
    var x: bv6 := (v & 63) as bv6;
    var y: bv5 := (v & 1984 >> 6 as bv5) as bv5;
    var firstByte: bv8 := 192 | y as CodeUnit;
    var secondByte: bv8 := 128 | x as CodeUnit;
    [firstByte, secondByte]
  }

  function method EncodeScalarValueTripleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)
    requires 2048 <= v <= 65535
    ensures |s| == 3
    ensures IsWellFormedTripleCodeUnitSequence(s)
    decreases v
  {
    var x: bv6 := (v & 63) as bv6;
    var y: bv6 := (v & 4032 >> 6 as bv5) as bv6;
    var z: bv4 := (v & 61440 >> 12 as bv5) as bv4;
    var firstByte: bv8 := 224 | z as CodeUnit;
    var secondByte: bv8 := 128 | y as CodeUnit;
    var thirdByte: bv8 := 128 | x as CodeUnit;
    [firstByte, secondByte, thirdByte]
  }

  function method EncodeScalarValueQuadrupleByte(v: Unicode.ScalarValue): (s: CodeUnitSeq)
    requires 65536 <= v <= 1114111
    ensures |s| == 4
    ensures IsWellFormedQuadrupleCodeUnitSequence(s)
    decreases v
  {
    assert v <= 2097151;
    var x: bv6 := (v & 63) as bv6;
    var y: bv6 := (v & 4032 >> 6 as bv5) as bv6;
    var z: bv4 := (v & 61440 >> 12 as bv5) as bv4;
    var u2: bv2 := (v & 196608 >> 16 as bv5) as bv2;
    var u1: bv3 := (v & 1835008 >> 18 as bv5) as bv3;
    var firstByte: bv8 := 240 | u1 as CodeUnit;
    var secondByte: bv8 := 128 | (u2 as CodeUnit << 4 as bv4) | z as CodeUnit;
    var thirdByte: bv8 := 128 | y as CodeUnit;
    var fourthByte: bv8 := 128 | x as CodeUnit;
    [firstByte, secondByte, thirdByte, fourthByte]
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    ensures EncodeScalarValue(v) == m
    decreases m
  {
    if |m| == 1 then
      DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m)
    else if |m| == 2 then
      DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m)
    else if |m| == 3 then
      DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m)
    else
      assert |m| == 4; DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m)
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceSingleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 1
    ensures 0 <= v <= 127
    ensures EncodeScalarValueSingleByte(v) == m
    decreases m
  {
    var firstByte: bv8 := m[0];
    var x: bv7 := firstByte as bv7;
    x as Unicode.ScalarValue
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceDoubleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 2
    ensures 128 <= v <= 2047
    ensures EncodeScalarValueDoubleByte(v) == m
    decreases m
  {
    var firstByte: bv8 := m[0];
    var secondByte: bv8 := m[1];
    var y: bv24 := (firstByte & 31) as bv24;
    var x: bv24 := (secondByte & 63) as bv24;
    (y << 6 as bv5) | x as Unicode.ScalarValue
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceTripleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 3
    ensures 2048 <= v <= 65535
    ensures EncodeScalarValueTripleByte(v) == m
    decreases m
  {
    var firstByte: bv8 := m[0];
    var secondByte: bv8 := m[1];
    var thirdByte: bv8 := m[2];
    var z: bv24 := (firstByte & 15) as bv24;
    var y: bv24 := (secondByte & 63) as bv24;
    var x: bv24 := (thirdByte & 63) as bv24;
    assert {:split_here} true;
    (z << 12 as bv5) | (y << 6 as bv5) | x as Unicode.ScalarValue
  }

  function method DecodeMinimalWellFormedCodeUnitSubsequenceQuadrupleByte(m: MinimalWellFormedCodeUnitSeq): (v: Unicode.ScalarValue)
    requires |m| == 4
    ensures 65536 <= v <= 1114111
    ensures EncodeScalarValueQuadrupleByte(v) == m
    decreases m
  {
    var firstByte: bv8 := m[0];
    var secondByte: bv8 := m[1];
    var thirdByte: bv8 := m[2];
    var fourthByte: bv8 := m[3];
    var u1: bv24 := (firstByte & 7) as bv24;
    var u2: bv24 := (secondByte & 48 >> 4 as bv4) as bv24;
    var z: bv24 := (secondByte & 15) as bv24;
    var y: bv24 := (thirdByte & 63) as bv24;
    var x: bv24 := (fourthByte & 63) as bv24;
    assert {:split_here} true;
    (u1 << 18 as bv5) | (u2 << 16 as bv5) | (z << 12 as bv5) | (y << 6 as bv5) | x as Unicode.ScalarValue
  }

  lemma LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m: MinimalWellFormedCodeUnitSeq, s: CodeUnitSeq)
    ensures SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + s) == Some(m)
    decreases m, s
  {
    ghost var ms := m + s;
    assert IsMinimalWellFormedCodeUnitSubsequence(ms[..|m|]);
    ghost var prefix := SplitPrefixMinimalWellFormedCodeUnitSubsequence(ms).Extract();
    calc ==> {
      IsMinimalWellFormedCodeUnitSubsequence(m);
      |prefix| <= |m|;
      prefix == ms[..|prefix|] == m[..|prefix|] == m;
    }
  }

  function PartitionCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeParts: Option<seq<MinimalWellFormedCodeUnitSeq>>)
    ensures maybeParts.Some? ==> Seq.Flatten(maybeParts.Extract()) == s
    decreases |s|
  {
    if s == [] then
      Some([])
    else
      var prefix: MinimalWellFormedCodeUnitSeq :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(s); var restParts: seq<MinimalWellFormedCodeUnitSeq> :- PartitionCodeUnitSequenceChecked(s[|prefix|..]); Some([prefix] + restParts)
  } by method {
    if s == [] {
      return Some([]);
    }
    var result: seq<MinimalWellFormedCodeUnitSeq> := [];
    var rest := s;
    while |rest| > 0
      invariant PartitionCodeUnitSequenceChecked(s).Some? <==> PartitionCodeUnitSequenceChecked(rest).Some?
      invariant PartitionCodeUnitSequenceChecked(s).Some? ==> true && PartitionCodeUnitSequenceChecked(s).value == result + PartitionCodeUnitSequenceChecked(rest).value
      decreases |rest| - 0
    {
      var prefix :- SplitPrefixMinimalWellFormedCodeUnitSubsequence(rest);
      result := result + [prefix];
      rest := rest[|prefix|..];
    }
    assert result + [] == result;
    return Some(result);
  }

  function method PartitionCodeUnitSequence(s: WellFormedCodeUnitSeq): (parts: seq<MinimalWellFormedCodeUnitSeq>)
    ensures Seq.Flatten(parts) == s
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Extract()
  }

  lemma /*{:_inductionTrigger [m]}*/ /*{:_inductionTrigger PartitionCodeUnitSequenceChecked(m)}*/ /*{:_induction m}*/ LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq)
    ensures PartitionCodeUnitSequenceChecked(m) == Some([m])
    decreases m
  {
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, []);
    calc == {
      Some(m);
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m + []);
      {
        assert m + [] == m;
      }
      SplitPrefixMinimalWellFormedCodeUnitSubsequence(m);
    }
    calc == {
      PartitionCodeUnitSequenceChecked(m);
      Some([m] + []);
      {
        assert [m] + [] == [m];
      }
      Some([m]);
    }
  }

  function method IsWellFormedCodeUnitSequence(s: CodeUnitSeq): (b: bool)
    decreases s
  {
    PartitionCodeUnitSequenceChecked(s).Some?
  }

  lemma LemmaMinimalWellFormedCodeUnitSubsequenceIsWellFormedSequence(m: MinimalWellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m)
    decreases m
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
  }

  lemma LemmaPrependMinimalWellFormedCodeUnitSubsequence(m: MinimalWellFormedCodeUnitSeq, s: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(m + s)
    decreases m, s
  {
    LemmaPartitionMinimalWellFormedCodeUnitSubsequence(m);
    LemmaSplitPrefixMinimalWellFormedCodeUnitSubsequenceInvertsPrepend(m, s);
    assert PartitionCodeUnitSequenceChecked(m + s).Some?;
  }

  lemma /*{:_inductionTrigger _default.Flatten(ms)}*/ /*{:_induction ms}*/ LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms: seq<MinimalWellFormedCodeUnitSeq>)
    ensures IsWellFormedCodeUnitSequence(Seq.Flatten(ms))
    decreases ms
  {
    if |ms| == 0 {
      assert IsWellFormedCodeUnitSequence(Seq.Flatten(ms));
    } else {
      ghost var head := ms[0];
      ghost var tail := ms[1..];
      LemmaFlattenMinimalWellFormedCodeUnitSubsequences(tail);
      ghost var flatTail := Seq.Flatten(tail);
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(head, flatTail);
      assert IsWellFormedCodeUnitSequence(head + flatTail);
    }
  }

  lemma LemmaConcatWellFormedCodeUnitSubsequences(s: WellFormedCodeUnitSeq, t: WellFormedCodeUnitSeq)
    ensures IsWellFormedCodeUnitSequence(s + t)
    decreases s, t
  {
    ghost var partsS := PartitionCodeUnitSequence(s);
    ghost var partsT := PartitionCodeUnitSequence(t);
    ghost var partsST := partsS + partsT;
    Seq.LemmaFlattenConcat(partsS, partsT);
    assert s + t == Seq.Flatten(partsST);
    assert forall part: CodeUnitSeq {:trigger IsMinimalWellFormedCodeUnitSubsequence(part)} {:trigger |part|} {:trigger part in partsST} | part in partsST :: |part| > 0 && IsMinimalWellFormedCodeUnitSubsequence(part);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(partsST);
  }

  function EncodeScalarSequence(vs: seq<Unicode.ScalarValue>): (s: WellFormedCodeUnitSeq)
    decreases vs
  {
    var ms: seq<MinimalWellFormedCodeUnitSeq> := Seq.Map(EncodeScalarValue, vs);
    LemmaFlattenMinimalWellFormedCodeUnitSubsequences(ms);
    Seq.Flatten(ms)
  } by method {
    s := [];
    ghost var unflattened: seq<MinimalWellFormedCodeUnitSeq> := [];
    for i: int := |vs| downto 0
      invariant unflattened == Seq.Map(EncodeScalarValue, vs[i..])
      invariant s == Seq.Flatten(unflattened)
    {
      var next: MinimalWellFormedCodeUnitSeq := EncodeScalarValue(vs[i]);
      unflattened := [next] + unflattened;
      LemmaPrependMinimalWellFormedCodeUnitSubsequence(next, s);
      s := next + s;
    }
  }

  function method DecodeCodeUnitSequence(s: WellFormedCodeUnitSeq): (vs: seq<Unicode.ScalarValue>)
    ensures EncodeScalarSequence(vs) == s
    decreases s
  {
    var parts: seq<MinimalWellFormedCodeUnitSeq> := PartitionCodeUnitSequence(s);
    var vs: seq<Unicode.ScalarValue> := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    vs
  }

  function DecodeCodeUnitSequenceChecked(s: CodeUnitSeq): (maybeVs: Option<seq<Unicode.ScalarValue>>)
    ensures IsWellFormedCodeUnitSequence(s) ==> maybeVs.Some? && maybeVs.Extract() == DecodeCodeUnitSequence(s)
    ensures !IsWellFormedCodeUnitSequence(s) ==> true && maybeVs.None?
    decreases s
  {
    if IsWellFormedCodeUnitSequence(s) then
      Some(DecodeCodeUnitSequence(s))
    else
      None
  } by method {
    var maybeParts := PartitionCodeUnitSequenceChecked(s);
    if maybeParts.None? {
      return None;
    }
    var parts := maybeParts.value;
    var vs := Seq.Map(DecodeMinimalWellFormedCodeUnitSubsequence, parts);
    calc == {
      s;
      Seq.Flatten(parts);
      {
        assert parts == Seq.Map(EncodeScalarValue, vs);
      }
      Seq.Flatten(Seq.Map(EncodeScalarValue, vs));
      EncodeScalarSequence(vs);
    }
    return Some(vs);
  }

  type CodeUnit = bv8

  import opened Wrappers

  import Functions

  import Seq

  import Unicode

  type CodeUnitSeq = seq<CodeUnit>

  type WellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsWellFormedCodeUnitSequence(s)
    witness []

  type MinimalWellFormedCodeUnitSeq = s: CodeUnitSeq
    | IsMinimalWellFormedCodeUnitSubsequence(s)
    witness *
}

module {:options "-functionSyntax:4"} BoundedInts {
  const TWO_TO_THE_0: int := 1
  const TWO_TO_THE_1: int := 2
  const TWO_TO_THE_2: int := 4
  const TWO_TO_THE_4: int := 16
  const TWO_TO_THE_5: int := 32
  const TWO_TO_THE_8: int := 256
  const TWO_TO_THE_16: int := 65536
  const TWO_TO_THE_24: int := 16777216
  const TWO_TO_THE_32: int := 4294967296
  const TWO_TO_THE_40: int := 1099511627776
  const TWO_TO_THE_48: int := 281474976710656
  const TWO_TO_THE_56: int := 72057594037927936
  const TWO_TO_THE_64: int := 18446744073709551616
  const TWO_TO_THE_128: int := 340282366920938463463374607431768211456
  const TWO_TO_THE_256: int := 115792089237316195423570985008687907853269984665640564039457584007913129639936
  const TWO_TO_THE_512: int := 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
  const UINT8_MAX: uint8 := 255
  const UINT16_MAX: uint16 := 65535
  const UINT32_MAX: uint32 := 4294967295
  const UINT64_MAX: uint64 := 18446744073709551615
  const INT8_MIN: int8 := -128
  const INT8_MAX: int8 := 127
  const INT16_MIN: int16 := -32768
  const INT16_MAX: int16 := 32767
  const INT32_MIN: int32 := -2147483648
  const INT32_MAX: int32 := 2147483647
  const INT64_MIN: int64 := -9223372036854775808
  const INT64_MAX: int64 := 9223372036854775807
  const NAT8_MAX: nat8 := 127
  const NAT16_MAX: nat16 := 32767
  const NAT32_MAX: nat32 := 2147483647
  const NAT64_MAX: nat64 := 9223372036854775807

  newtype uint8 = x: int
    | 0 <= x < TWO_TO_THE_8

  newtype uint16 = x: int
    | 0 <= x < TWO_TO_THE_16

  newtype uint32 = x: int
    | 0 <= x < TWO_TO_THE_32

  newtype uint64 = x: int
    | 0 <= x < TWO_TO_THE_64

  newtype int8 = x: int
    | -128 <= x < 128

  newtype int16 = x: int
    | -32768 <= x < 32768

  newtype int32 = x: int
    | -2147483648 <= x < 2147483648

  newtype int64 = x: int
    | -9223372036854775808 <= x < 9223372036854775808

  newtype nat8 = x: int
    | 0 <= x < 128

  newtype nat16 = x: int
    | 0 <= x < 32768

  newtype nat32 = x: int
    | 0 <= x < 2147483648

  newtype nat64 = x: int
    | 0 <= x < 9223372036854775808

  type byte = uint8

  type bytes = seq<byte>

  newtype opt_byte = c: int
    | -1 <= c < TWO_TO_THE_8
}

module {:options "-functionSyntax:4"} FileIO {
  method ReadBytesFromFile(path: string) returns (res: Result<seq<uint8>, string>)
    decreases path
  {
    var isError, bytesRead, errorMsg := INTERNAL_ReadBytesFromFile(path);
    return if isError then Failure(errorMsg) else Success(bytesRead);
  }

  method WriteBytesToFile(path: string, bytes: seq<uint8>) returns (res: Result<(), string>)
    decreases path, bytes
  {
    var isError, errorMsg := INTERNAL_WriteBytesToFile(path, bytes);
    return if isError then Failure(errorMsg) else Success(());
  }

  method AppendBytesToFile(path: string, bytes: seq<uint8>) returns (res: Result<(), string>)
    decreases path, bytes
  {
    var isError, errorMsg := INTERNAL_AppendBytesToFile(path, bytes);
    return if isError then Failure(errorMsg) else Success(());
  }

  method {:extern "DafnyLibraries.FileIO", "INTERNAL_ReadBytesFromFile"} INTERNAL_ReadBytesFromFile(path: string)
      returns (isError: bool, bytesRead: seq<uint8>, errorMsg: string)
    decreases path

  method {:extern "DafnyLibraries.FileIO", "INTERNAL_WriteBytesToFile"} INTERNAL_WriteBytesToFile(path: string, bytes: seq<uint8>)
      returns (isError: bool, errorMsg: string)
    decreases path, bytes

  method {:extern "DafnyLibraries.FileIO", "INTERNAL_AppendBytesToFile"} INTERNAL_AppendBytesToFile(path: string, bytes: seq<uint8>)
      returns (isError: bool, errorMsg: string)
    decreases path, bytes

  import opened Wrappers

  import opened BoundedInts

  export
    provides AppendBytesToFile, ReadBytesFromFile, WriteBytesToFile, Wrappers, BoundedInts

}

module {:options "-functionSyntax:4"} Power {
  function method {:opaque} Pow(b: int, e: nat): int
    decreases e
  {
    if e == 0 then
      1
    else
      b * Pow(b, e - 1)
  }

  lemma /*{:_inductionTrigger Pow(b, 0)}*/ /*{:_induction b}*/ LemmaPow0(b: int)
    ensures Pow(b, 0) == 1
    decreases b
  {
    reveal Pow();
  }

  lemma LemmaPow0Auto()
    ensures forall b: nat {:trigger Pow(b, 0)} :: Pow(b, 0) == 1
  {
    reveal Pow();
    forall b: nat {:trigger Pow(b, 0)} | true
      ensures Pow(b, 0) == 1
    {
      LemmaPow0(b);
    }
  }

  lemma /*{:_inductionTrigger Pow(b, 1)}*/ /*{:_induction b}*/ LemmaPow1(b: int)
    ensures Pow(b, 1) == b
    decreases b
  {
    calc {
      Pow(b, 1);
      {
        reveal Pow();
      }
      b * Pow(b, 0);
      {
        LemmaPow0(b);
      }
      b * 1;
      {
        LemmaMulBasicsAuto();
      }
      b;
    }
  }

  lemma LemmaPow1Auto()
    ensures forall b: nat {:trigger Pow(b, 1)} :: Pow(b, 1) == b
  {
    reveal Pow();
    forall b: nat {:trigger Pow(b, 1)} | true
      ensures Pow(b, 1) == b
    {
      LemmaPow1(b);
    }
  }

  lemma /*{:_inductionTrigger Pow(0, e)}*/ /*{:_induction e}*/ Lemma0Pow(e: nat)
    requires e > 0
    ensures Pow(0, e) == 0
    decreases e
  {
    reveal Pow();
    LemmaMulBasicsAuto();
    if e != 1 {
      Lemma0Pow(e - 1);
    }
  }

  lemma Lemma0PowAuto()
    ensures forall e: nat {:trigger Pow(0, e)} :: e > 0 ==> Pow(0, e) == 0
  {
    reveal Pow();
    forall e: nat {:trigger Pow(0, e)} | e > 0
      ensures Pow(0, e) == 0
    {
      Lemma0Pow(e);
    }
  }

  lemma /*{:_inductionTrigger Pow(1, e)}*/ /*{:_induction e}*/ Lemma1Pow(e: nat)
    ensures Pow(1, e) == 1
    decreases e
  {
    reveal Pow();
    LemmaMulBasicsAuto();
    if e != 0 {
      Lemma1Pow(e - 1);
    }
  }

  lemma Lemma1PowAuto()
    ensures forall e: nat {:trigger Pow(1, e)} :: Pow(1, e) == 1
  {
    reveal Pow();
    forall e: nat {:trigger Pow(1, e)} | true
      ensures Pow(1, e) == 1
    {
      Lemma1Pow(e);
    }
  }

  lemma /*{:_inductionTrigger Pow(x, 2)}*/ /*{:_induction x}*/ LemmaSquareIsPow2(x: nat)
    ensures Pow(x, 2) == x * x
    decreases x
  {
    reveal Pow();
  }

  lemma LemmaSquareIsPow2Auto()
    ensures forall x: nat {:trigger Pow(x, 2)} :: Pow(x, 2) == x * x
  {
    reveal Pow();
    forall x: nat {:trigger Pow(x, 2)} | true
      ensures Pow(x, 2) == x * x
    {
    }
  }

  lemma /*{:_inductionTrigger Pow(b, e)}*/ /*{:_induction b, e}*/ LemmaPowPositive(b: int, e: nat)
    requires b > 0
    ensures 0 < Pow(b, e)
    decreases b, e
  {
    LemmaMulIncreasesAuto();
    LemmaMulInductionAuto(e, (u: int) => 0 <= u ==> 0 < Pow(b, u));
  }

  lemma LemmaPowPositiveAuto()
    ensures forall b: int, e: nat {:trigger Pow(b, e)} :: b > 0 ==> 0 < Pow(b, e)
  {
    reveal Pow();
    forall b: int, e: nat {:trigger Pow(b, e)} | b > 0
      ensures 0 < Pow(b, e)
    {
      LemmaPowPositive(b, e);
    }
  }

  lemma LemmaPowAdds(b: int, e1: nat, e2: nat)
    ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)
    decreases e1
  {
    if e1 == 0 {
      calc {
        Pow(b, e1) * Pow(b, e2);
        {
          LemmaPow0(b);
        }
        1 * Pow(b, e2);
        {
          LemmaMulBasicsAuto();
        }
        Pow(b, 0 + e2);
      }
    } else {
      calc {
        Pow(b, e1) * Pow(b, e2);
        {
          reveal Pow();
        }
        b * Pow(b, e1 - 1) * Pow(b, e2);
        {
          LemmaMulIsAssociativeAuto();
        }
        b * Pow(b, e1 - 1) * Pow(b, e2);
        {
          LemmaPowAdds(b, e1 - 1, e2);
        }
        b * Pow(b, e1 - 1 + e2);
        {
          reveal Pow();
        }
        Pow(b, e1 + e2);
      }
    }
  }

  lemma LemmaPowAddsAuto()
    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)} :: Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)
  {
    reveal Pow();
    forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 + e2)} | true
      ensures Pow(b, e1 + e2) == Pow(b, e1) * Pow(b, e2)
    {
      LemmaPowAdds(b, e1, e2);
    }
  }

  lemma LemmaPowSubAddCancel(b: int, e1: nat, e2: nat)
    requires e1 >= e2
    ensures Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)
    decreases e1
  {
    LemmaPowAdds(b, e1 - e2, e2);
  }

  lemma LemmaPowSubAddCancelAuto()
    ensures forall b: int, e1: nat, e2: nat {:trigger Pow(b, e1 - e2)} | e1 >= e2 :: Pow(b, e1 - e2) * Pow(b, e2) == Pow(b, e1)
  {
    reveal Pow();
    forall b: int, e1: nat, e2: nat | e1 >= e2 {
      LemmaPowSubAddCancel(b, e1, e2);
    }
  }

  lemma LemmaPowSubtracts(b: nat, e1: nat, e2: nat)
    requires b > 0
    requires e1 <= e2
    ensures Pow(b, e1) > 0
    ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0
    decreases b, e1, e2
  {
    LemmaPowPositiveAuto();
    calc {
      Pow(b, e2) / Pow(b, e1);
      {
        LemmaPowSubAddCancel(b, e2, e1);
      }
      Pow(b, e2 - e1) * Pow(b, e1) / Pow(b, e1);
      {
        LemmaDivByMultiple(Pow(b, e2 - e1), Pow(b, e1));
      }
      Pow(b, e2 - e1);
    }
  }

  lemma LemmaPowSubtractsAuto()
    ensures forall b: nat, e1: nat {:trigger Pow(b, e1)} :: b > 0 ==> Pow(b, e1) > 0
    ensures forall e2: nat, e1: nat, b: nat {:trigger Pow(b, e2 - e1)} :: (b > 0 && e1 <= e2 ==> Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1)) && (b > 0 && e1 <= e2 ==> Pow(b, e2) / Pow(b, e1) > 0)
  {
    reveal Pow();
    LemmaPowPositiveAuto();
    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e2 - e1)} | b > 0 && e1 <= e2
      ensures Pow(b, e2 - e1) == Pow(b, e2) / Pow(b, e1) > 0
    {
      LemmaPowSubtracts(b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(a, b * c)}*/ /*{:_inductionTrigger Pow(Pow(a, b), c)}*/ /*{:_induction a, b, c}*/ LemmaPowMultiplies(a: int, b: nat, c: nat)
    ensures 0 <= b * c
    ensures Pow(Pow(a, b), c) == Pow(a, b * c)
    decreases c
  {
    LemmaMulNonnegative(b, c);
    if c == 0 {
      LemmaMulBasicsAuto();
      calc {
        Pow(a, b * c);
        {
          LemmaPow0(a);
        }
        1;
        {
          LemmaPow0(Pow(a, b));
        }
        Pow(Pow(a, b), c);
      }
    } else {
      calc {
        b * c - b;
        {
          LemmaMulBasicsAuto();
        }
        b * c - b * 1;
        {
          LemmaMulIsDistributiveAuto();
        }
        b * (c - 1);
      }
      LemmaMulNonnegative(b, c - 1);
      assert 0 <= b * c - b;
      calc {
        Pow(a, b * c);
        Pow(a, b + b * c - b);
        {
          LemmaPowAdds(a, b, b * c - b);
        }
        Pow(a, b) * Pow(a, b * c - b);
        Pow(a, b) * Pow(a, b * (c - 1));
        {
          LemmaPowMultiplies(a, b, c - 1);
        }
        Pow(a, b) * Pow(Pow(a, b), c - 1);
        {
          reveal Pow();
        }
        Pow(Pow(a, b), c);
      }
    }
  }

  lemma LemmaPowMultipliesAuto()
    ensures forall b: nat, c: nat {:trigger b * c} :: 0 <= b * c
    ensures forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)} :: Pow(Pow(a, b), c) == Pow(a, b * c)
  {
    reveal Pow();
    LemmaMulNonnegativeAuto();
    forall a: int, b: nat, c: nat {:trigger Pow(a, b * c)} | true
      ensures Pow(Pow(a, b), c) == Pow(a, b * c)
    {
      LemmaPowMultiplies(a, b, c);
    }
  }

  lemma /*{:_inductionTrigger Pow(a, e) * Pow(b, e)}*/ /*{:_inductionTrigger Pow(a * b, e)}*/ /*{:_induction a, b, e}*/ LemmaPowDistributes(a: int, b: int, e: nat)
    ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)
    decreases e
  {
    reveal Pow();
    LemmaMulBasicsAuto();
    if e > 0 {
      calc {
        Pow(a * b, e);
        a * b * Pow(a * b, e - 1);
        {
          LemmaPowDistributes(a, b, e - 1);
        }
        a * b * Pow(a, e - 1) * Pow(b, e - 1);
        {
          LemmaMulIsAssociativeAuto();
          LemmaMulIsCommutativeAuto();
        }
        a * Pow(a, e - 1) * b * Pow(b, e - 1);
        Pow(a, e) * Pow(b, e);
      }
    }
  }

  lemma LemmaPowDistributesAuto()
    ensures forall a: int, b: int, e: nat {:trigger Pow(a * b, e)} :: Pow(a * b, e) == Pow(a, e) * Pow(b, e)
  {
    reveal Pow();
    forall a: int, b: int, e: nat {:trigger Pow(a * b, e)} | true
      ensures Pow(a * b, e) == Pow(a, e) * Pow(b, e)
    {
      LemmaPowDistributes(a, b, e);
    }
  }

  lemma LemmaPowAuto()
    ensures forall x: int {:trigger Pow(x, 0)} :: Pow(x, 0) == 1
    ensures forall x: int {:trigger Pow(x, 1)} :: Pow(x, 1) == x
    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 0 ==> Pow(x, y) == 1
    ensures forall x: int, y: int {:trigger Pow(x, y)} :: y == 1 ==> Pow(x, y) == x
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> x <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 1 < y ==> x < x * y
    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y + z)} :: Pow(x, y + z) == Pow(x, y) * Pow(x, z)
    ensures forall x: int, y: nat, z: nat {:trigger Pow(x, y - z)} :: y >= z ==> Pow(x, y - z) * Pow(x, z) == Pow(x, y)
    ensures forall x: int, y: int, z: nat {:trigger Pow(x * y, z)} :: Pow(x * y, z) == Pow(x, z) * Pow(y, z)
  {
    reveal Pow();
    LemmaPow0Auto();
    LemmaPow1Auto();
    LemmaPowDistributesAuto();
    LemmaPowAddsAuto();
    LemmaPowSubAddCancelAuto();
    LemmaMulAuto();
    LemmaMulIncreasesAuto();
    LemmaMulStrictlyIncreasesAuto();
  }

  lemma /*{:_inductionTrigger Pow(b, e2), Pow(b, e1)}*/ /*{:_induction b, e1, e2}*/ LemmaPowStrictlyIncreases(b: nat, e1: nat, e2: nat)
    requires 1 < b
    requires e1 < e2
    ensures Pow(b, e1) < Pow(b, e2)
    decreases b, e1, e2
  {
    reveal Pow();
    LemmaPowAuto();
    ghost var f := (e: int) => 0 < e ==> Pow(b, e1) < Pow(b, e1 + e);
    forall i: int {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)
      ensures f(i + 1)
    {
      assert 0 < i ==> Pow(b, e1) < Pow(b, e1 + i);
      calc {
        Pow(b, e1 + i);
      <=
        {
          LemmaPowPositive(b, e1 + i);
          LemmaMulLeftInequality(Pow(b, e1 + i), 1, b);
        }
        Pow(b, e1 + i) * b;
      ==
        {
          LemmaPow1(b);
        }
        Pow(b, e1 + i) * Pow(b, 1);
      ==
        {
          LemmaPowAdds(b, e1 + i, 1);
        }
        Pow(b, e1 + i + 1);
      ==
        calc {
          e1 + i + 1;
          e1 + i + 1;
        }
        Pow(b, e1 + i + 1);
      }
      assert f(i + 1);
    }
    LemmaMulInductionAuto(e2 - e1, f);
    assert Pow(b, e1) < Pow(b, e1 + e2 - e1) == Pow(b, e2) by {
      assert 0 < e2 - e1;
    }
  }

  lemma LemmaPowStrictlyIncreasesAuto()
    ensures forall e2: nat, e1: nat, b: nat {:trigger Pow(b, e1), Pow(b, e2)} :: 1 < b && e1 < e2 ==> Pow(b, e1) < Pow(b, e2)
  {
    reveal Pow();
    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} | 1 < b && e1 < e2
      ensures Pow(b, e1) < Pow(b, e2)
    {
      LemmaPowStrictlyIncreases(b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(b, e2), Pow(b, e1)}*/ /*{:_induction b, e1, e2}*/ LemmaPowIncreases(b: nat, e1: nat, e2: nat)
    requires b > 0
    requires e1 <= e2
    ensures Pow(b, e1) <= Pow(b, e2)
    decreases b, e1, e2
  {
    reveal Pow();
    LemmaPowAuto();
    ghost var f := (e: int) => 0 <= e ==> Pow(b, e1) <= Pow(b, e1 + e);
    forall i: int {:trigger IsLe(0, i)} | IsLe(0, i) && f(i)
      ensures f(i + 1)
    {
      calc {
        Pow(b, e1 + i);
      <=
        {
          LemmaPowPositive(b, e1 + i);
          LemmaMulLeftInequality(Pow(b, e1 + i), 1, b);
        }
        Pow(b, e1 + i) * b;
      ==
        {
          LemmaPow1(b);
        }
        Pow(b, e1 + i) * Pow(b, 1);
      ==
        {
          LemmaPowAdds(b, e1 + i, 1);
        }
        Pow(b, e1 + i + 1);
      }
    }
    LemmaMulInductionAuto(e2 - e1, f);
    assert Pow(b, e1) <= Pow(b, e1 + e2 - e1) by {
      assert 0 <= e2 - e1;
    }
  }

  lemma LemmaPowIncreasesAuto()
    ensures forall e2: nat, e1: nat, b: nat {:trigger Pow(b, e1), Pow(b, e2)} :: 1 < b && e1 <= e2 ==> Pow(b, e1) <= Pow(b, e2)
  {
    reveal Pow();
    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} | 1 < b && e1 <= e2
      ensures Pow(b, e1) <= Pow(b, e2)
    {
      LemmaPowIncreases(b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(b, e2), Pow(b, e1)}*/ /*{:_induction b, e1, e2}*/ LemmaPowStrictlyIncreasesConverse(b: nat, e1: nat, e2: nat)
    requires b > 0
    requires Pow(b, e1) < Pow(b, e2)
    ensures e1 < e2
    decreases b, e1, e2
  {
    if e1 >= e2 {
      LemmaPowIncreases(b, e2, e1);
      assert false;
    }
  }

  lemma LemmaPowStrictlyIncreasesConverseAuto()
    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} :: b > 0 && Pow(b, e1) < Pow(b, e2) ==> e1 < e2
  {
    reveal Pow();
    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} | b > 0 && Pow(b, e1) < Pow(b, e2)
      ensures e1 < e2
    {
      LemmaPowStrictlyIncreasesConverse(b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(b, e2), Pow(b, e1)}*/ /*{:_induction b, e1, e2}*/ LemmaPowIncreasesConverse(b: nat, e1: nat, e2: nat)
    requires 1 < b
    requires Pow(b, e1) <= Pow(b, e2)
    ensures e1 <= e2
    decreases b, e1, e2
  {
    if e1 > e2 {
      LemmaPowStrictlyIncreases(b, e2, e1);
      assert false;
    }
  }

  lemma LemmaPowIncreasesConverseAuto()
    ensures forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} :: 1 < b && Pow(b, e1) <= Pow(b, e2) ==> e1 <= e2
  {
    reveal Pow();
    forall b: nat, e1: nat, e2: nat {:trigger Pow(b, e1), Pow(b, e2)} | 1 < b && Pow(b, e1) <= Pow(b, e2)
      ensures e1 <= e2
    {
      LemmaPowIncreasesConverse(b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(Pow(b, x), y * z)}*/ /*{:_inductionTrigger Pow(Pow(b, x * y), z)}*/ /*{:_induction b, x, y, z}*/ LemmaPullOutPows(b: nat, x: nat, y: nat, z: nat)
    requires b > 0
    ensures 0 <= x * y
    ensures 0 <= y * z
    ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)
    decreases b, x, y, z
  {
    LemmaMulNonnegative(x, y);
    LemmaMulNonnegative(y, z);
    LemmaPowPositive(b, x);
    calc {
      Pow(Pow(b, x * y), z);
      {
        LemmaPowMultiplies(b, x, y);
      }
      Pow(Pow(Pow(b, x), y), z);
      {
        LemmaPowMultiplies(Pow(b, x), y, z);
      }
      Pow(Pow(b, x), y * z);
    }
  }

  lemma LemmaPullOutPowsAuto()
    ensures forall y: nat, z: nat {:trigger z * y} :: 0 <= z * y && 0 <= y * z
    ensures forall b: nat, x: nat, y: nat, z: nat {:trigger Pow(Pow(b, x * y), z)} :: b > 0 ==> Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)
  {
    reveal Pow();
    LemmaMulNonnegativeAuto();
    forall b: nat, x: nat, y: nat, z: nat {:trigger Pow(Pow(b, x * y), z)} | b > 0
      ensures Pow(Pow(b, x * y), z) == Pow(Pow(b, x), y * z)
    {
      LemmaPullOutPows(b, x, y, z);
    }
  }

  lemma LemmaPowDivisionInequality(x: nat, b: nat, e1: nat, e2: nat)
    requires b > 0
    requires e2 <= e1
    requires x < Pow(b, e1)
    ensures Pow(b, e2) > 0
    ensures x / Pow(b, e2) < Pow(b, e1 - e2)
    decreases x, b, e1, e2
  {
    LemmaPowPositiveAuto();
    calc ==> {
      x / Pow(b, e2) >= Pow(b, e1 - e2);
      {
        LemmaMulInequality(Pow(b, e1 - e2), x / Pow(b, e2), Pow(b, e2));
      }
      x / Pow(b, e2) * Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);
      {
        LemmaFundamentalDivMod(x, Pow(b, e2));
        LemmaMulIsCommutativeAuto();
      }
      x - x % Pow(b, e2) >= Pow(b, e1 - e2) * Pow(b, e2);
      {
        LemmaPowAdds(b, e1 - e2, e2);
      }
      x - x % Pow(b, e2) >= Pow(b, e1);
      {
        LemmaModPropertiesAuto();
      }
      x >= Pow(b, e1);
      false;
    }
  }

  lemma LemmaPowDivisionInequalityAuto()
    ensures forall b: nat, e2: nat {:trigger Pow(b, e2)} :: b > 0 ==> Pow(b, e2) > 0
    ensures forall x: nat, b: nat, e1: nat, e2: nat {:trigger x / Pow(b, e2), Pow(b, e1 - e2)} :: b > 0 && e2 <= e1 && x < Pow(b, e1) ==> x / Pow(b, e2) < Pow(b, e1 - e2)
  {
    reveal Pow();
    LemmaPowPositiveAuto();
    forall x: nat, b: nat, e1: nat, e2: nat {:trigger x / Pow(b, e2), Pow(b, e1 - e2)} | b > 0 && e2 <= e1 && x < Pow(b, e1)
      ensures x / Pow(b, e2) < Pow(b, e1 - e2)
    {
      LemmaPowDivisionInequality(x, b, e1, e2);
    }
  }

  lemma /*{:_inductionTrigger Pow(b, e)}*/ /*{:_induction b, e}*/ LemmaPowMod(b: nat, e: nat)
    requires b > 0 && e > 0
    ensures Pow(b, e) % b == 0
    decreases b, e
  {
    reveal Pow();
    calc {
      Pow(b, e) % b;
      b * Pow(b, e - 1) % b;
      {
        LemmaMulIsAssociativeAuto();
      }
      Pow(b, e - 1) * b % b;
      {
        LemmaPowPositiveAuto();
        LemmaModMultiplesBasic(Pow(b, e - 1), b);
      }
      0;
    }
  }

  lemma LemmaPowModAuto()
    ensures forall b: nat, e: nat {:trigger Pow(b, e)} :: b > 0 && e > 0 ==> Pow(b, e) % b == 0
  {
    reveal Pow();
    forall b: nat, e: nat {:trigger Pow(b, e)} | b > 0 && e > 0
      ensures Pow(b, e) % b == 0
    {
      LemmaPowMod(b, e);
    }
  }

  lemma /*{:_inductionTrigger Pow(b % m, e)}*/ /*{:_induction b, e, m}*/ LemmaPowModNoop(b: int, e: nat, m: int)
    requires m > 0
    ensures Pow(b % m, e) % m == Pow(b, e) % m
    decreases e
  {
    reveal Pow();
    LemmaModPropertiesAuto();
    if e > 0 {
      calc {
        Pow(b % m, e) % m;
        b % m * Pow(b % m, e - 1) % m;
        {
          LemmaMulModNoopGeneral(b, Pow(b % m, e - 1), m);
        }
        b % m * Pow(b % m, e - 1) % m % m % m;
        {
          LemmaPowModNoop(b, e - 1, m);
        }
        b % m * Pow(b, e - 1) % m % m % m;
        {
          LemmaMulModNoopGeneral(b, Pow(b, e - 1), m);
        }
        b * Pow(b, e - 1) % m % m;
        b * Pow(b, e - 1) % m;
        Pow(b, e) % m;
      }
    }
  }

  lemma LemmaPowModNoopAuto()
    ensures forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)} :: m > 0 ==> Pow(b % m, e) % m == Pow(b, e) % m
  {
    reveal Pow();
    forall b: nat, e: nat, m: nat {:trigger Pow(b % m, e)} | m > 0
      ensures Pow(b % m, e) % m == Pow(b, e) % m
    {
      LemmaPowModNoop(b, e, m);
    }
  }

  import opened DivMod

  import opened GeneralInternals

  import opened Mul

  import opened MulInternals
}

module {:options "-functionSyntax:4"} MulInternals {
  function method {:opaque} MulPos(x: int, y: int): int
    requires x >= 0
    decreases x, y
  {
    if x == 0 then
      0
    else
      y + MulPos(x - 1, y)
  }

  function method MulRecursive(x: int, y: int): int
    decreases x, y
  {
    if x >= 0 then
      MulPos(x, y)
    else
      -1 * MulPos(-1 * x, y)
  }

  lemma LemmaMulInduction(f: int -> bool)
    requires f(0)
    requires forall i: int {:trigger f(i), f(i + 1)} :: i >= 0 && f(i) ==> f(i + 1)
    requires forall i: int {:trigger f(i), f(i - 1)} :: i <= 0 && f(i) ==> f(i - 1)
    ensures forall i: int {:trigger f(i)} :: f(i)
  {
    forall i: int | true
      ensures f(i)
    {
      LemmaInductionHelper(1, f, i);
    }
  }

  lemma LemmaMulCommutes()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
  {
    forall x: int, y: int | true
      ensures x * y == y * x
    {
      LemmaMulInduction((i: int) => x * i == i * x);
    }
  }

  lemma LemmaMulSuccessor()
    ensures forall x: int, y: int {:trigger (x + 1) * y} :: (x + 1) * y == x * y + y
    ensures forall x: int, y: int {:trigger (x - 1) * y} :: (x - 1) * y == x * y - y
  {
    LemmaMulCommutes();
    forall x: int, y: int | true
      ensures (x + 1) * y == x * y + y
      ensures (x - 1) * y == x * y - y
    {
      LemmaMulIsDistributiveAdd(y, x, 1);
      LemmaMulIsDistributiveAdd(y, x, -1);
    }
  }

  lemma LemmaMulDistributes()
    ensures forall x: int, y: int, z: int {:trigger (x + y) * z} :: (x + y) * z == x * z + y * z
    ensures forall x: int, y: int, z: int {:trigger (x - y) * z} :: (x - y) * z == x * z - y * z
  {
    LemmaMulSuccessor();
    forall x: int, y: int, z: int | true
      ensures (x + y) * z == x * z + y * z
      ensures (x - y) * z == x * z - y * z
    {
      ghost var f1 := (i: int) => (x + i) * z == x * z + i * z;
      ghost var f2 := (i: int) => (x - i) * z == x * z - i * z;
      assert forall i: int {:trigger (x + i + 1) * z} :: (x + i + 1) * z == (x + i + 1) * z && (x + i + 1) * z == (x + i) * z + z;
      assert forall i: int {:trigger (x + i - 1) * z} :: (x + i - 1) * z == (x + i - 1) * z && (x + i - 1) * z == (x + i) * z - z;
      assert forall i: int {:trigger (x - (i + 1)) * z} :: (x - (i + 1)) * z == (x - i - 1) * z && (x - i - 1) * z == (x - i) * z - z;
      assert forall i: int {:trigger (x - (i - 1)) * z} :: (x - (i - 1)) * z == (x - i + 1) * z && (x - i + 1) * z == (x - i) * z + z;
      LemmaMulInduction(f1);
      LemmaMulInduction(f2);
      assert f1(y);
      assert f2(y);
    }
  }

  predicate MulAuto()
  {
    (forall x: int, y: int {:trigger x * y} :: 
      x * y == y * x) &&
    (forall x: int, y: int, z: int {:trigger (x + y) * z} :: 
      (x + y) * z == x * z + y * z) &&
    forall x: int, y: int, z: int {:trigger (x - y) * z} :: 
      (x - y) * z == x * z - y * z
  }

  lemma LemmaMulAuto()
    ensures MulAuto()
  {
    LemmaMulCommutes();
    LemmaMulDistributes();
  }

  lemma LemmaMulInductionAuto(x: int, f: int -> bool)
    requires MulAuto() ==> f(0) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1)) && forall i: int {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1)
    ensures MulAuto()
    ensures f(x)
    decreases x
  {
    LemmaMulCommutes();
    LemmaMulDistributes();
    assert forall i: int {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);
    assert forall i: int {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);
    LemmaMulInduction(f);
    assert f(x);
  }

  lemma LemmaMulInductionAutoForall(f: int -> bool)
    requires MulAuto() ==> f(0) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1)) && forall i: int {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1)
    ensures MulAuto()
    ensures forall i: int {:trigger f(i)} :: f(i)
  {
    LemmaMulCommutes();
    LemmaMulDistributes();
    assert forall i: int {:trigger f(i)} :: IsLe(0, i) && f(i) ==> f(i + 1);
    assert forall i: int {:trigger f(i)} :: IsLe(i, 0) && f(i) ==> f(i - 1);
    LemmaMulInduction(f);
  }

  import opened GeneralInternals

  import opened MulInternalsNonlinear
}

module {:options "-functionSyntax:4"} MulInternalsNonlinear {
  lemma LemmaMulStrictlyPositive(x: int, y: int)
    ensures 0 < x && 0 < y ==> 0 < x * y
    decreases x, y
  {
  }

  lemma LemmaMulNonzero(x: int, y: int)
    ensures x * y != 0 <==> x != 0 && y != 0
    decreases x, y
  {
  }

  lemma LemmaMulIsAssociative(x: int, y: int, z: int)
    ensures x * y * z == x * y * z
    decreases x, y, z
  {
  }

  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
    decreases x, y, z
  {
  }

  lemma LemmaMulOrdering(x: int, y: int)
    requires x != 0
    requires y != 0
    requires 0 <= x * y
    ensures x * y >= x && x * y >= y
    decreases x, y
  {
  }

  lemma LemmaMulStrictInequality(x: int, y: int, z: int)
    requires x < y
    requires z > 0
    ensures x * z < y * z
    decreases x, y, z
  {
  }
}

module {:options "-functionSyntax:4"} GeneralInternals {
  predicate IsLe(x: int, y: int)
    decreases x, y
  {
    x <= y
  }

  lemma LemmaInductionHelper(n: int, f: int -> bool, x: int)
    requires n > 0
    requires forall i: int {:trigger f(i)} :: 0 <= i < n ==> f(i)
    requires forall i: int {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)
    requires forall i: int {:trigger f(i), f(i - n)} :: i < n && f(i) ==> f(i - n)
    ensures f(x)
    decreases if x >= n then x else -x
  {
    if x >= n {
      LemmaInductionHelper(n, f, x - n);
      assert f(x - n + n);
    } else if x < 0 {
      LemmaInductionHelper(n, f, x + n);
      assert f(x + n - n);
    }
  }
}

module {:options "-functionSyntax:4"} Mul {
  lemma LemmaMulIsMulRecursive(x: int, y: int)
    ensures x * y == MulRecursive(x, y)
    decreases x, y
  {
    if x >= 0 {
      LemmaMulIsMulPos(x, y);
    }
    if x <= 0 {
      LemmaMulIsMulPos(-x, y);
    }
    LemmaMulAuto();
  }

  lemma LemmaMulIsMulRecursiveAuto()
    ensures forall x: int, y: int {:trigger MulRecursive(x, y)} :: x * y == MulRecursive(x, y)
  {
    forall x: int, y: int | true
      ensures x * y == MulRecursive(x, y)
    {
      LemmaMulIsMulRecursive(x, y);
    }
  }

  lemma /*{:_inductionTrigger MulPos(x, y)}*/ /*{:_induction x, y}*/ LemmaMulIsMulPos(x: int, y: int)
    requires x >= 0
    ensures x * y == MulPos(x, y)
    decreases x, y
  {
    reveal MulPos();
    LemmaMulInductionAuto(x, (u: int) => u >= 0 ==> u * y == MulPos(u, y));
  }

  lemma LemmaMulBasics(x: int)
    ensures 0 * x == 0
    ensures x * 0 == 0
    ensures 1 * x == x
    ensures x * 1 == x
    decreases x
  {
  }

  lemma LemmaMulBasicsAuto()
    ensures forall x: int {:trigger 0 * x} :: 0 * x == 0
    ensures forall x: int {:trigger x * 0} :: x * 0 == 0
    ensures forall x: int {:trigger 1 * x} :: 1 * x == x
    ensures forall x: int {:trigger x * 1} :: x * 1 == x
  {
  }

  lemma LemmaMulNonzero(x: int, y: int)
    ensures x * y != 0 <==> x != 0 && y != 0
    decreases x, y
  {
    MulINL.LemmaMulNonzero(x, y);
  }

  lemma LemmaMulNonzeroAuto()
    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0
  {
    forall x: int, y: int | true
      ensures x * y != 0 <==> x != 0 && y != 0
    {
      LemmaMulNonzero(x, y);
    }
  }

  lemma LemmaMulByZeroIsZeroAuto()
    ensures forall x: int {:trigger 0 * x} {:trigger x * 0} :: x * 0 == 0 * x && 0 * x == 0
  {
    forall x: int {:trigger 0 * x} {:trigger x * 0} | true
      ensures x * 0 == 0 * x == 0
    {
      LemmaMulBasics(x);
    }
  }

  lemma LemmaMulIsAssociative(x: int, y: int, z: int)
    ensures x * y * z == x * y * z
    decreases x, y, z
  {
    MulINL.LemmaMulIsAssociative(x, y, z);
  }

  lemma LemmaMulIsAssociativeAuto()
    ensures forall x: int, y: int, z: int {:trigger x * y * z} {:trigger x * y * z} :: x * y * z == x * y * z
  {
    forall x: int, y: int, z: int | true
      ensures x * y * z == x * y * z
    {
      LemmaMulIsAssociative(x, y, z);
    }
  }

  lemma LemmaMulIsCommutative(x: int, y: int)
    ensures x * y == y * x
    decreases x, y
  {
  }

  lemma LemmaMulIsCommutativeAuto()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
  {
  }

  lemma LemmaMulOrdering(x: int, y: int)
    requires x != 0
    requires y != 0
    requires 0 <= x * y
    ensures x * y >= x && x * y >= y
    decreases x, y
  {
    MulINL.LemmaMulOrdering(x, y);
  }

  lemma LemmaMulOrderingAuto()
    ensures forall x: int, y: int {:trigger x * y} :: (0 != x && 0 != y && x * y >= 0 ==> x * y >= x) && (0 != x && 0 != y && x * y >= 0 ==> x * y >= y)
  {
    forall x: int, y: int | 0 != x && 0 != y && x * y >= 0
      ensures x * y >= x && x * y >= y
    {
      LemmaMulOrdering(x, y);
    }
  }

  lemma LemmaMulEquality(x: int, y: int, z: int)
    requires x == y
    ensures x * z == y * z
    decreases x, y, z
  {
  }

  lemma LemmaMulEqualityAuto()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x == y ==> x * z == y * z
  {
    forall x: int, y: int, z: int | x == y
      ensures x * z == y * z
    {
      LemmaMulEquality(x, y, z);
    }
  }

  lemma LemmaMulInequality(x: int, y: int, z: int)
    requires x <= y
    requires z >= 0
    ensures x * z <= y * z
    decreases x, y, z
  {
    LemmaMulInductionAuto(z, (u: int) => u >= 0 ==> x * u <= y * u);
  }

  lemma LemmaMulInequalityAuto()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z
  {
    forall x: int, y: int, z: int | x <= y && z >= 0
      ensures x * z <= y * z
    {
      LemmaMulInequality(x, y, z);
    }
  }

  lemma LemmaMulStrictInequality(x: int, y: int, z: int)
    requires x < y
    requires z > 0
    ensures x * z < y * z
    decreases x, y, z
  {
    MulINL.LemmaMulStrictInequality(x, y, z);
  }

  lemma LemmaMulStrictInequalityAuto()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z
  {
    forall x: int, y: int, z: int | x < y && z > 0
      ensures x * z < y * z
    {
      LemmaMulStrictInequality(x, y, z);
    }
  }

  lemma LemmaMulUpperBound(x: int, XBound: int, y: int, YBound: int)
    requires x <= XBound
    requires y <= YBound
    requires 0 <= x
    requires 0 <= y
    ensures x * y <= XBound * YBound
    decreases x, XBound, y, YBound
  {
    LemmaMulInequality(x, XBound, y);
    LemmaMulInequality(y, YBound, XBound);
  }

  lemma LemmaMulUpperBoundAuto()
    ensures forall YBound: int, y: int, XBound: int, x: int {:trigger x * y, XBound * YBound} :: x <= XBound && y <= YBound && 0 <= x && 0 <= y ==> x * y <= XBound * YBound
  {
    forall x: int, XBound: int, y: int, YBound: int | x <= XBound && y <= YBound && 0 <= x && 0 <= y
      ensures x * y <= XBound * YBound
    {
      LemmaMulUpperBound(x, XBound, y, YBound);
    }
  }

  lemma LemmaMulStrictUpperBound(x: int, XBound: int, y: int, YBound: int)
    requires x < XBound
    requires y < YBound
    requires 0 < x
    requires 0 < y
    ensures x * y <= (XBound - 1) * (YBound - 1)
    decreases x, XBound, y, YBound
  {
    LemmaMulInequality(x, XBound - 1, y);
    LemmaMulInequality(y, YBound - 1, XBound - 1);
  }

  lemma LemmaMulStrictUpperBoundAuto()
    ensures forall YBound: int, y: int, XBound: int, x: int {:trigger x * y, (XBound - 1) * (YBound - 1)} :: x < XBound && y < YBound && 0 < x && 0 < y ==> x * y <= (XBound - 1) * (YBound - 1)
  {
    forall x: int, XBound: int, y: int, YBound: int {:trigger (XBound - 1) * (YBound - 1), x * y} {:trigger YBound - 1, XBound - 1, 0 < y, 0 < x} {:trigger YBound - 1, 0 < y, x < XBound} {:trigger XBound - 1, 0 < x, y < YBound} {:trigger y < YBound, x < XBound} | x < XBound && y < YBound && 0 < x && 0 < y
      ensures x * y <= (XBound - 1) * (YBound - 1)
    {
      LemmaMulStrictUpperBound(x, XBound, y, YBound);
    }
  }

  lemma LemmaMulLeftInequality(x: int, y: int, z: int)
    requires 0 < x
    ensures y <= z ==> x * y <= x * z
    ensures y < z ==> x * y < x * z
    decreases x, y, z
  {
    LemmaMulInductionAuto(x, (u: int) => u > 0 ==> y <= z ==> u * y <= u * z);
    LemmaMulInductionAuto(x, (u: int) => u > 0 ==> y < z ==> u * y < u * z);
  }

  lemma LemmaMulLeftInequalityAuto()
    ensures forall x: int, y: int, z: int {:trigger x * y, x * z} :: (x > 0 ==> y <= z ==> x * y <= x * z) && (x > 0 ==> y < z ==> x * y < x * z)
  {
    forall x: int, y: int, z: int | (y <= z || y < z) && 0 < x
      ensures (y <= z ==> x * y <= x * z) && (y < z ==> x * y < x * z)
    {
      LemmaMulLeftInequality(x, y, z);
    }
  }

  lemma LemmaMulEqualityConverse(m: int, x: int, y: int)
    requires m != 0
    requires m * x == m * y
    ensures x == y
    decreases m, x, y
  {
    LemmaMulInductionAuto(m, (u: int) => x > y && 0 < u ==> x * u > y * u);
    LemmaMulInductionAuto(m, (u: int) => x > y && 0 > u ==> x * u < y * u);
    LemmaMulInductionAuto(m, (u: int) => x < y && 0 < u ==> x * u < y * u);
    LemmaMulInductionAuto(m, (u: int) => x < y && 0 > u ==> x * u > y * u);
  }

  lemma LemmaMulEqualityConverseAuto()
    ensures forall m: int, x: int, y: int {:trigger m * x, m * y} :: m != 0 && m * x == m * y ==> x == y
  {
    forall m: int, x: int, y: int | m != 0 && m * x == m * y
      ensures x == y
    {
      LemmaMulEqualityConverse(m, x, y);
    }
  }

  lemma LemmaMulInequalityConverse(x: int, y: int, z: int)
    requires x * z <= y * z
    requires z > 0
    ensures x <= y
    decreases x, y, z
  {
    LemmaMulInductionAuto(z, (u: int) => x * u <= y * u && u > 0 ==> x <= y);
  }

  lemma LemmaMulInequalityConverseAuto()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z <= y * z && z > 0 ==> x <= y
  {
    forall x: int, y: int, z: int | x * z <= y * z && z > 0
      ensures x <= y
    {
      LemmaMulInequalityConverse(x, y, z);
    }
  }

  lemma LemmaMulStrictInequalityConverse(x: int, y: int, z: int)
    requires x * z < y * z
    requires z >= 0
    ensures x < y
    decreases x, y, z
  {
    LemmaMulInductionAuto(z, (u: int) => x * u < y * u && u >= 0 ==> x < y);
  }

  lemma LemmaMulStrictInequalityConverseAuto()
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x * z < y * z && z >= 0 ==> x < y
  {
    forall x: int, y: int, z: int | x * z < y * z && z >= 0
      ensures x < y
    {
      LemmaMulStrictInequalityConverse(x, y, z);
    }
  }

  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
    decreases x, y, z
  {
    MulINL.LemmaMulIsDistributiveAdd(x, y, z);
  }

  lemma LemmaMulIsDistributiveAddAuto()
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
  {
    forall x: int, y: int, z: int | true
      ensures x * (y + z) == x * y + x * z
    {
      LemmaMulIsDistributiveAdd(x, y, z);
    }
  }

  lemma LemmaMulIsDistributiveAddOtherWay(x: int, y: int, z: int)
    ensures (y + z) * x == y * x + z * x
    decreases x, y, z
  {
    LemmaMulAuto();
  }

  lemma LemmaMulIsDistributiveAddOtherWayAuto()
    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x
  {
    forall x: int, y: int, z: int | true
      ensures (y + z) * x == y * x + z * x
    {
      LemmaMulIsDistributiveAddOtherWay(x, y, z);
    }
  }

  lemma LemmaMulIsDistributiveSub(x: int, y: int, z: int)
    ensures x * (y - z) == x * y - x * z
    decreases x, y, z
  {
    LemmaMulAuto();
  }

  lemma LemmaMulIsDistributiveSubAuto()
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
  {
    forall x: int, y: int, z: int | true
      ensures x * (y - z) == x * y - x * z
    {
      LemmaMulIsDistributiveSub(x, y, z);
    }
  }

  lemma LemmaMulIsDistributive(x: int, y: int, z: int)
    ensures x * (y + z) == x * y + x * z
    ensures x * (y - z) == x * y - x * z
    ensures (y + z) * x == y * x + z * x
    ensures (y - z) * x == y * x - z * x
    ensures x * (y + z) == (y + z) * x
    ensures x * (y - z) == (y - z) * x
    ensures x * y == y * x
    ensures x * z == z * x
    decreases x, y, z
  {
    LemmaMulAuto();
  }

  lemma LemmaMulIsDistributiveAuto()
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x
    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x
  {
    LemmaMulIsDistributiveAddAuto();
    LemmaMulIsDistributiveSubAuto();
    LemmaMulIsCommutativeAuto();
  }

  lemma LemmaMulStrictlyPositive(x: int, y: int)
    ensures 0 < x && 0 < y ==> 0 < x * y
    decreases x, y
  {
    MulINL.LemmaMulStrictlyPositive(x, y);
  }

  lemma LemmaMulStrictlyPositiveAuto()
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> 0 < x * y
  {
    forall x: int, y: int | 0 < x && 0 < y
      ensures 0 < x * y
    {
      LemmaMulStrictlyPositive(x, y);
    }
  }

  lemma LemmaMulStrictlyIncreases(x: int, y: int)
    requires 1 < x
    requires 0 < y
    ensures y < x * y
    decreases x, y
  {
    LemmaMulInductionAuto(x, (u: int) => 1 < u ==> y < u * y);
  }

  lemma LemmaMulStrictlyIncreasesAuto()
    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y ==> y < x * y
  {
    forall x: int, y: int | 1 < x && 0 < y
      ensures y < x * y
    {
      LemmaMulStrictlyIncreases(x, y);
    }
  }

  lemma LemmaMulIncreases(x: int, y: int)
    requires 0 < x
    requires 0 < y
    ensures y <= x * y
    decreases x, y
  {
    LemmaMulInductionAuto(x, (u: int) => 0 < u ==> y <= u * y);
  }

  lemma LemmaMulIncreasesAuto()
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> y <= x * y
  {
    forall x: int, y: int | 0 < x && 0 < y
      ensures y <= x * y
    {
      LemmaMulIncreases(x, y);
    }
  }

  lemma LemmaMulNonnegative(x: int, y: int)
    requires 0 <= x
    requires 0 <= y
    ensures 0 <= x * y
    decreases x, y
  {
    LemmaMulInductionAuto(x, (u: int) => 0 <= u ==> 0 <= u * y);
  }

  lemma LemmaMulNonnegativeAuto()
    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y
  {
    forall x: int, y: int | 0 <= x && 0 <= y
      ensures 0 <= x * y
    {
      LemmaMulNonnegative(x, y);
    }
  }

  lemma LemmaMulUnaryNegation(x: int, y: int)
    ensures -x * y == -(x * y) == x * -y
    decreases x, y
  {
    LemmaMulInductionAuto(x, (u: int) => -u * y == -(u * y) == u * -y);
  }

  lemma LemmaMulUnaryNegationAuto()
    ensures forall x: int, y: int {:trigger -x * y} {:trigger x * -y} :: -x * y == -(x * y) && -(x * y) == x * -y
  {
    forall x: int, y: int | true
      ensures -x * y == -(x * y) == x * -y
    {
      LemmaMulUnaryNegation(x, y);
    }
  }

  lemma LemmaMulCancelsNegatives(x: int, y: int)
    ensures x * y == -x * -y
    decreases x, y
  {
    LemmaMulUnaryNegationAuto();
  }

  lemma LemmaMulCancelsNegativesAuto()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == -x * -y
  {
    forall x: int, y: int | true
      ensures x * y == -x * -y
    {
      LemmaMulCancelsNegatives(x, y);
    }
  }

  lemma LemmaMulProperties()
    ensures forall x: int, y: int {:trigger x * y} :: x * y == y * x
    ensures forall x: int {:trigger x * 1} {:trigger 1 * x} :: x * 1 == 1 * x && 1 * x == x
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x < y && z > 0 ==> x * z < y * z
    ensures forall x: int, y: int, z: int {:trigger x * z, y * z} :: x <= y && z >= 0 ==> x * z <= y * z
    ensures forall x: int, y: int, z: int {:trigger x * (y + z)} :: x * (y + z) == x * y + x * z
    ensures forall x: int, y: int, z: int {:trigger x * (y - z)} :: x * (y - z) == x * y - x * z
    ensures forall x: int, y: int, z: int {:trigger (y + z) * x} :: (y + z) * x == y * x + z * x
    ensures forall x: int, y: int, z: int {:trigger (y - z) * x} :: (y - z) * x == y * x - z * x
    ensures forall x: int, y: int, z: int {:trigger x * y * z} {:trigger x * y * z} :: x * y * z == x * y * z
    ensures forall x: int, y: int {:trigger x * y} :: x * y != 0 <==> x != 0 && y != 0
    ensures forall x: int, y: int {:trigger x * y} :: 0 <= x && 0 <= y ==> 0 <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: (0 < x && 0 < y && 0 <= x * y ==> x <= x * y) && (0 < x && 0 < y && 0 <= x * y ==> y <= x * y)
    ensures forall x: int, y: int {:trigger x * y} :: 1 < x && 0 < y ==> y < x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> y <= x * y
    ensures forall x: int, y: int {:trigger x * y} :: 0 < x && 0 < y ==> 0 < x * y
  {
    LemmaMulStrictInequalityAuto();
    LemmaMulInequalityAuto();
    LemmaMulIsDistributiveAuto();
    LemmaMulIsAssociativeAuto();
    LemmaMulOrderingAuto();
    LemmaMulNonzeroAuto();
    LemmaMulNonnegativeAuto();
    LemmaMulStrictlyIncreasesAuto();
    LemmaMulIncreasesAuto();
  }

  import MulINL = MulInternalsNonlinear

  import opened MulInternals
}

module {:options "-functionSyntax:4"} DivMod {
  lemma LemmaDivIsDivRecursive(x: int, d: int)
    requires 0 < d
    ensures DivRecursive(x, d) == x / d
    decreases x, d
  {
    reveal DivPos();
    reveal DivRecursive();
    LemmaDivInductionAuto(d, x, (u: int) => DivRecursive(u, d) == u / d);
  }

  lemma LemmaDivIsDivRecursiveAuto()
    ensures forall x: int, d: int {:trigger x / d} :: d > 0 ==> DivRecursive(x, d) == x / d
  {
    reveal DivPos();
    reveal DivRecursive();
    forall x: int, d: int | d > 0
      ensures DivRecursive(x, d) == x / d
    {
      LemmaDivIsDivRecursive(x, d);
    }
  }

  lemma LemmaDivBySelf(d: int)
    requires d != 0
    ensures d / d == 1
    decreases d
  {
    DivINL.LemmaDivBySelf(d);
  }

  lemma LemmaDivOf0(d: int)
    requires d != 0
    ensures 0 / d == 0
    decreases d
  {
    DivINL.LemmaDivOf0(d);
  }

  lemma LemmaDivBasics(x: int)
    ensures x != 0 ==> 0 / x == 0
    ensures x / 1 == x
    ensures x != 0 ==> x / x == 1
    decreases x
  {
    if x != 0 {
      LemmaDivBySelf(x);
      LemmaDivOf0(x);
    }
  }

  lemma LemmaDivBasicsAuto()
    ensures forall x: int {:trigger 0 / x} :: x != 0 ==> 0 / x == 0
    ensures forall x: int {:trigger x / 1} :: x / 1 == x
    ensures forall x: int, y: int {:trigger x / y} :: x >= 0 && y > 0 ==> x / y >= 0
    ensures forall x: int, y: int {:trigger x / y} :: x >= 0 && y > 0 ==> x / y <= x
  {
    forall x: int | true
      ensures x != 0 ==> 0 / x == 0
      ensures x / 1 == x
    {
      LemmaDivBasics(x);
    }
    forall x: int, y: int | x >= 0 && y > 0
      ensures 0 <= x / y <= x
    {
      LemmaDivPosIsPos(x, y);
      LemmaDivIsOrderedByDenominator(x, 1, y);
    }
  }

  lemma LemmaSmallDivConverseAuto()
    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d && x / d == 0 ==> x < d
  {
    forall x: int, d: int | 0 <= x && 0 < d && x / d == 0
      ensures x < d
    {
      LemmaDivInductionAuto(d, x, (u: int) => 0 <= u && 0 < d && u / d == 0 ==> u < d);
    }
  }

  lemma LemmaDivNonZero(x: int, d: int)
    requires x >= d > 0
    ensures x / d > 0
    decreases x, d
  {
    LemmaDivPosIsPosAuto();
    if x / d == 0 {
      LemmaSmallDivConverseAuto();
    }
  }

  lemma LemmaDivNonZeroAuto()
    ensures forall x: int, d: int {:trigger x / d} | x >= d > 0 :: x / d > 0
  {
    forall x: int, d: int | x >= d > 0 {
      LemmaDivNonZero(x, d);
    }
  }

  lemma LemmaDivIsOrderedByDenominator(x: int, y: int, z: int)
    requires 0 <= x
    requires 1 <= y <= z
    ensures x / y >= x / z
    decreases x
  {
    reveal DivPos();
    reveal DivRecursive();
    LemmaDivIsDivRecursiveAuto();
    assert forall u: int, d: int {:trigger u / d} {:trigger DivRecursive(u, d)} :: d > 0 ==> DivRecursive(u, d) == u / d;
    if x < z {
      LemmaDivIsOrdered(0, x, y);
    } else {
      LemmaDivIsOrdered(x - z, x - y, y);
      LemmaDivIsOrderedByDenominator(x - z, y, z);
    }
  }

  lemma LemmaDivIsOrderedByDenominatorAuto()
    ensures forall z: int, y: int, x: int {:trigger x / y, x / z} :: 0 <= x && 1 <= y <= z ==> x / y >= x / z
  {
    forall x: int, y: int, z: int | 0 <= x && 1 <= y <= z
      ensures x / y >= x / z
    {
      LemmaDivIsOrderedByDenominator(x, y, z);
    }
  }

  lemma LemmaDivIsStrictlyOrderedByDenominator(x: int, d: int)
    requires 0 < x
    requires 1 < d
    ensures x / d < x
    decreases x
  {
    LemmaDivInductionAuto(d, x, (u: int) => 0 < u ==> u / d < u);
  }

  lemma LemmaDivIsStrictlyOrderedByDenominatorAuto()
    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x
  {
    forall x: int, d: int | 0 < x && 1 < d
      ensures x / d < x
    {
      LemmaDivIsStrictlyOrderedByDenominator(x, d);
    }
  }

  lemma LemmaDividingSums(a: int, b: int, d: int, R: int)
    requires 0 < d
    requires R == a % d + b % d - (a + b) % d
    ensures d * (a + b) / d - R == d * a / d + d * b / d
    decreases a, b, d, R
  {
    calc ==> {
      a % d + b % d == R + (a + b) % d;
      a + b - (a + b) % d - R == a - a % d + b - b % d;
      {
        LemmaFundamentalDivMod(a + b, d);
        LemmaFundamentalDivMod(a, d);
        LemmaFundamentalDivMod(b, d);
      }
      d * (a + b) / d - R == d * a / d + d * b / d;
    }
  }

  lemma LemmaDividingSumsAuto()
    ensures forall a: int, b: int, d: int, R: int {:trigger d * (a + b) / d - R, d * a / d + d * b / d} :: 0 < d && R == a % d + b % d - (a + b) % d ==> d * (a + b) / d - R == d * a / d + d * b / d
  {
    forall a: int, b: int, d: int, R: int {:trigger d * (a + b) / d - R, d * a / d + d * b / d} | 0 < d && R == a % d + b % d - (a + b) % d
      ensures d * (a + b) / d - R == d * a / d + d * b / d
    {
      LemmaDividingSums(a, b, d, R);
    }
  }

  lemma LemmaDivPosIsPos(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures 0 <= x / d
    decreases x, d
  {
    LemmaDivInductionAuto(d, x, (u: int) => 0 <= u ==> u / d >= 0);
  }

  lemma LemmaDivPosIsPosAuto()
    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d ==> 0 <= x / d
  {
    forall x: int, d: int | 0 <= x && 0 < d
      ensures 0 <= x / d
    {
      LemmaDivPosIsPos(x, d);
    }
  }

  lemma LemmaDivPlusOne(x: int, d: int)
    requires 0 < d
    ensures 1 + x / d == (d + x) / d
    decreases x, d
  {
    LemmaDivAuto(d);
  }

  lemma LemmaDivPlusOneAuto()
    ensures forall x: int, d: int {:trigger 1 + x / d, (d + x) / d} :: 0 < d ==> 1 + x / d == (d + x) / d
  {
    forall x: int, d: int | 0 < d
      ensures 1 + x / d == (d + x) / d
    {
      LemmaDivPlusOne(x, d);
    }
  }

  lemma LemmaDivMinusOne(x: int, d: int)
    requires 0 < d
    ensures -1 + x / d == (-d + x) / d
    decreases x, d
  {
    LemmaDivAuto(d);
  }

  lemma LemmaDivMinusOneAuto()
    ensures forall x: int, d: int {:trigger -1 + x / d, (-d + x) / d} :: 0 < d ==> -1 + x / d == (-d + x) / d
  {
    forall x: int, d: int | 0 < d
      ensures -1 + x / d == (-d + x) / d
    {
      LemmaDivMinusOne(x, d);
    }
  }

  lemma LemmaBasicDiv(d: int)
    requires 0 < d
    ensures forall x: int {:trigger x / d} :: 0 <= x < d ==> x / d == 0
    decreases d
  {
    LemmaDivAuto(d);
  }

  lemma LemmaBasicDivAuto()
    ensures forall d: int, x: int {:trigger x / d} :: 0 <= x < d ==> x / d == 0
  {
    forall x: int, d: int | 0 <= x < d
      ensures x / d == 0
    {
      LemmaBasicDiv(d);
    }
  }

  lemma LemmaDivIsOrdered(x: int, y: int, z: int)
    requires x <= y
    requires 0 < z
    ensures x / z <= y / z
    decreases x, y, z
  {
    LemmaDivInductionAuto(z, x - y, (xy: int) => xy <= 0 ==> (xy + y) / z <= y / z);
  }

  lemma LemmaDivIsOrderedAuto()
    ensures forall x: int, y: int, z: int {:trigger x / z, y / z} :: x <= y && 0 < z ==> x / z <= y / z
  {
    forall x: int, y: int, z: int | x <= y && 0 < z
      ensures x / z <= y / z
    {
      LemmaDivIsOrdered(x, y, z);
    }
  }

  lemma LemmaDivDecreases(x: int, d: int)
    requires 0 < x
    requires 1 < d
    ensures x / d < x
    decreases x, d
  {
    LemmaDivInductionAuto(d, x, (u: int) => 0 < u ==> u / d < u);
  }

  lemma LemmaDivDecreasesAuto()
    ensures forall x: int, d: int {:trigger x / d} :: 0 < x && 1 < d ==> x / d < x
  {
    forall x: int, d: int | 0 < x && 1 < d
      ensures x / d < x
    {
      LemmaDivDecreases(x, d);
    }
  }

  lemma LemmaDivNonincreasing(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures x / d <= x
    decreases x, d
  {
    LemmaDivInductionAuto(d, x, (u: int) => 0 <= u ==> u / d <= u);
  }

  lemma LemmaDivNonincreasingAuto()
    ensures forall x: int, d: int {:trigger x / d} :: 0 <= x && 0 < d ==> x / d <= x
  {
    forall x: int, d: int | 0 <= x && 0 < d
      ensures x / d <= x
    {
      LemmaDivNonincreasing(x, d);
    }
  }

  lemma LemmaSmallMod(x: nat, m: nat)
    requires x < m
    requires 0 < m
    ensures x % m == x
    decreases x, m
  {
    ModINL.LemmaSmallMod(x, m);
  }

  lemma LemmaBreakdown(x: int, y: int, z: int)
    requires 0 <= x
    requires 0 < y
    requires 0 < z
    ensures 0 < y * z
    ensures x % (y * z) == y * x / y % z + x % y
    decreases x, y, z
  {
    LemmaMulStrictlyPositiveAuto();
    LemmaDivPosIsPos(x, y);
    assert 0 <= x / y;
    calc {
      y * x / y % (y * z) + x % y % (y * z);
    <=
      {
        LemmaPartBound1(x, y, z);
      }
      y * (z - 1) + x % y % (y * z);
    <
      {
        LemmaPartBound2(x, y, z);
      }
      y * (z - 1) + y;
      {
        LemmaMulBasicsAuto();
      }
      y * (z - 1) + y * 1;
      {
        LemmaMulIsDistributiveAuto();
      }
      y * (z - 1 + 1);
      y * z;
    }
    calc {
      x % (y * z);
      {
        LemmaFundamentalDivMod(x, y);
      }
      (y * x / y + x % y) % (y * z);
      {
        LemmaModPropertiesAuto();
        assert 0 <= x % y;
        LemmaMulNonnegative(y, x / y);
        assert y * x / y % (y * z) + x % y % (y * z) < y * z;
        LemmaModAdds(y * x / y, x % y, y * z);
      }
      y * x / y % (y * z) + x % y % (y * z);
      {
        LemmaModPropertiesAuto();
        LemmaMulIncreases(z, y);
        LemmaMulIsCommutativeAuto();
        assert x % y < y <= y * z;
        LemmaSmallMod(x % y, y * z);
        assert x % y % (y * z) == x % y;
      }
      y * x / y % (y * z) + x % y;
      {
        LemmaTruncateMiddle(x / y, y, z);
      }
      y * x / y % z + x % y;
    }
  }

  lemma LemmaBreakdownAuto()
    ensures forall x: int, y: int, z: int {:trigger y * z, x % (y * z), y * x / y % z + x % y} :: (0 <= x && 0 < y && 0 < z ==> 0 < y * z) && (0 <= x && 0 < y && 0 < z ==> x % (y * z) == y * x / y % z + x % y)
  {
    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z
      ensures 0 < y * z && x % (y * z) == y * x / y % z + x % y
    {
      LemmaBreakdown(x, y, z);
    }
  }

  lemma LemmaRemainderUpper(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures x - d < x / d * d
    decreases x, d
  {
    LemmaMulAuto();
    LemmaDivInductionAuto(d, x, (u: int) => 0 <= u ==> u - d < u / d * d);
  }

  lemma LemmaRemainderUpperAuto()
    ensures forall x: int, d: int {:trigger x - d, d * d} :: 0 <= x && 0 < d ==> x - d < x / d * d
  {
    forall x: int, d: int | 0 <= x && 0 < d
      ensures x - d < x / d * d
    {
      LemmaRemainderUpper(x, d);
    }
  }

  lemma LemmaRemainderLower(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures x >= x / d * d
    decreases x, d
  {
    LemmaMulAuto();
    LemmaDivInductionAuto(d, x, (u: int) => 0 <= u ==> u >= u / d * d);
  }

  lemma LemmaRemainderLowerAuto()
    ensures forall x: int, d: int {:trigger x / d * d} :: 0 <= x && 0 < d ==> x >= x / d * d
  {
    forall x: int, d: int | 0 <= x && 0 < d
      ensures x >= x / d * d
    {
      LemmaRemainderLower(x, d);
    }
  }

  lemma LemmaRemainder(x: int, d: int)
    requires 0 <= x
    requires 0 < d
    ensures 0 <= x - x / d * d < d
    decreases x, d
  {
    LemmaMulAuto();
    LemmaDivInductionAuto(d, x, (u: int) => 0 <= u - u / d * d < d);
  }

  lemma LemmaRemainderAuto()
    ensures forall x: int, d: int {:trigger x - x / d * d} :: (0 <= x && 0 < d ==> 0 <= x - x / d * d) && (0 <= x && 0 < d ==> x - x / d * d < d)
  {
    forall x: int, d: int | 0 <= x && 0 < d
      ensures 0 <= x - x / d * d < d
    {
      LemmaRemainder(x, d);
    }
  }

  lemma LemmaFundamentalDivMod(x: int, d: int)
    requires d != 0
    ensures x == d * x / d + x % d
    decreases x, d
  {
    ModINL.LemmaFundamentalDivMod(x, d);
  }

  lemma LemmaFundamentalDivModAuto()
    ensures forall x: int, d: int {:trigger d * x / d + x % d} :: d != 0 ==> x == d * x / d + x % d
  {
    forall x: int, d: int | d != 0
      ensures x == d * x / d + x % d
    {
      LemmaFundamentalDivMod(x, d);
    }
  }

  lemma LemmaDivDenominator(x: int, c: nat, d: nat)
    requires 0 <= x
    requires 0 < c
    requires 0 < d
    ensures c * d != 0
    ensures x / c / d == x / (c * d)
    decreases x, c, d
  {
    LemmaMulStrictlyPositiveAuto();
    ghost var R := x % (c * d);
    LemmaModPropertiesAuto();
    LemmaDivPosIsPos(R, c);
    if R / c >= d {
      LemmaFundamentalDivMod(R, c);
      LemmaMulInequality(d, R / c, c);
      LemmaMulIsCommutativeAuto();
      assert false;
    }
    assert R / c < d;
    LemmaMulBasicsAuto();
    LemmaFundamentalDivModConverse(R / c, d, 0, R / c);
    assert R / c % d == R / c;
    LemmaFundamentalDivMod(R, c);
    assert c * R / c + R % c == R;
    assert c * R / c % d + R % c == R;
    ghost var k := x / (c * d);
    LemmaFundamentalDivMod(x, c * d);
    assert x == c * d * x / (c * d) + x % (c * d);
    assert R == x - c * d * x / (c * d);
    assert R == x - c * d * k;
    calc {
      c * x / c % d + x % c;
      {
        LemmaModMultiplesVanish(-k, x / c, d);
        LemmaMulIsCommutativeAuto();
      }
      c * (x / c + -k * d) % d + x % c;
      {
        LemmaHoistOverDenominator(x, -k * d, c);
      }
      c * (x + -k * d * c) / c % d + x % c;
      {
        LemmaMulIsAssociative(-k, d, c);
      }
      c * (x + -k * d * c) / c % d + x % c;
      {
        LemmaMulUnaryNegation(k, d * c);
      }
      c * (x + -(k * d * c)) / c % d + x % c;
      {
        LemmaMulIsAssociative(k, d, c);
      }
      c * (x + -(k * d * c)) / c % d + x % c;
      c * (x - k * d * c) / c % d + x % c;
      {
        LemmaMulIsAssociativeAuto();
        LemmaMulIsCommutativeAuto();
      }
      c * R / c % d + x % c;
      c * R / c + x % c;
      {
        LemmaFundamentalDivMod(R, c);
        assert R == c * R / c + R % c;
        LemmaModMod(x, c, d);
        assert R % c == x % c;
      }
      R;
      {
        LemmaModIsModRecursiveAuto();
      }
      R % (c * d);
      (x - c * d * k) % (c * d);
      {
        LemmaMulUnaryNegation(c * d, k);
      }
      (x + c * d * -k) % (c * d);
      {
        LemmaModMultiplesVanish(-k, x, c * d);
      }
      x % (c * d);
    }
    calc ==> {
      c * x / c + x % c - R == c * x / c - c * x / c % d;
      {
        LemmaFundamentalDivMod(x, c);
      }
      x - R == c * x / c - c * x / c % d;
    }
    calc ==> {
      true;
      {
        LemmaFundamentalDivMod(x / c, d);
      }
      d * x / c / d == x / c - x / c % d;
      c * d * x / c / d == c * (x / c - x / c % d);
      {
        LemmaMulIsAssociativeAuto();
      }
      c * d * x / c / d == c * (x / c - x / c % d);
      {
        LemmaMulIsDistributiveAuto();
      }
      c * d * x / c / d == c * x / c - c * x / c % d;
      c * d * x / c / d == x - R;
      {
        LemmaFundamentalDivMod(x, c * d);
      }
      c * d * x / c / d == c * d * x / (c * d) + x % (c * d) - R;
      c * d * x / c / d == c * d * x / (c * d);
      {
        LemmaMulEqualityConverse(c * d, x / c / d, x / (c * d));
      }
      x / c / d == x / (c * d);
    }
  }

  lemma LemmaDivDenominatorAuto()
    ensures forall c: nat, d: nat {:trigger c * d} :: 0 < c && 0 < d ==> c * d != 0
    ensures forall x: int, c: nat, d: nat {:trigger x / c / d} :: 0 <= x && 0 < c && 0 < d ==> x / c / d == x / (c * d)
  {
    LemmaMulNonzeroAuto();
    forall x: int, c: nat, d: nat | 0 <= x && 0 < c && 0 < d
      ensures x / c / d == x / (c * d)
    {
      LemmaDivDenominator(x, c, d);
    }
  }

  lemma LemmaMulHoistInequality(x: int, y: int, z: int)
    requires 0 <= x
    requires 0 < z
    ensures x * y / z <= x * y / z
    decreases x, y, z
  {
    calc {
      x * y / z;
      {
        LemmaFundamentalDivMod(y, z);
      }
      x * (z * y / z + y % z) / z;
      {
        LemmaMulIsDistributiveAuto();
      }
      (x * z * y / z + x * y % z) / z;
    >=
      {
        LemmaModPropertiesAuto();
        LemmaMulNonnegative(x, y % z);
        LemmaDivIsOrdered(x * z * y / z, x * z * y / z + x * y % z, z);
      }
      x * z * y / z / z;
      {
        LemmaMulIsAssociativeAuto();
        LemmaMulIsCommutativeAuto();
      }
      z * x * y / z / z;
      {
        LemmaDivMultiplesVanish(x * y / z, z);
      }
      x * y / z;
    }
  }

  lemma LemmaMulHoistInequalityAuto()
    ensures forall x: int, y: int, z: int {:trigger x * y / z, x * y / z} :: 0 <= x && 0 < z ==> x * y / z <= x * y / z
  {
    forall x: int, y: int, z: int | 0 <= x && 0 < z
      ensures x * y / z <= x * y / z
    {
      LemmaMulHoistInequality(x, y, z);
    }
  }

  lemma LemmaIndistinguishableQuotients(a: int, b: int, d: int)
    requires 0 < d
    requires 0 <= a - a % d <= b < a + d - a % d
    ensures a / d == b / d
    decreases a, b, d
  {
    LemmaDivInductionAuto(d, a - b, (ab: int) => ghost var u: int := ab + b; 0 <= u - u % d <= b < u + d - u % d ==> u / d == b / d);
  }

  lemma LemmaIndistinguishableQuotientsAuto()
    ensures forall a: int, b: int, d: int {:trigger a / d, b / d} :: 0 < d && 0 <= a - a % d <= b < a + d - a % d ==> a / d == b / d
  {
    forall a: int, b: int, d: int | 0 < d && 0 <= a - a % d <= b < a + d - a % d
      ensures a / d == b / d
    {
      LemmaIndistinguishableQuotients(a, b, d);
    }
  }

  lemma LemmaTruncateMiddle(x: int, b: int, c: int)
    requires 0 <= x
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures b * x % (b * c) == b * x % c
    decreases x, b, c
  {
    LemmaMulStrictlyPositiveAuto();
    LemmaMulNonnegativeAuto();
    calc {
      b * x;
      {
        LemmaFundamentalDivMod(b * x, b * c);
      }
      b * c * b * x / (b * c) + b * x % (b * c);
      {
        LemmaDivDenominator(b * x, b, c);
      }
      b * c * b * x / b / c + b * x % (b * c);
      {
        LemmaMulIsCommutativeAuto();
        LemmaDivByMultiple(x, b);
      }
      b * c * x / c + b * x % (b * c);
    }
    calc ==> {
      true;
      {
        LemmaFundamentalDivMod(x, c);
      }
      x == c * x / c + x % c;
      b * x == b * (c * x / c + x % c);
      {
        LemmaMulIsDistributiveAuto();
      }
      b * x == b * c * x / c + b * x % c;
      {
        LemmaMulIsAssociativeAuto();
      }
      b * x == b * c * x / c + b * x % c;
    }
  }

  lemma LemmaTruncateMiddleAuto()
    ensures forall x: int, b: int, c: int {:trigger b * x % c} :: 0 <= x && 0 < b && 0 < c && 0 < b * c ==> b * x % (b * c) == b * x % c
  {
    forall x: int, b: int, c: int | 0 <= x && 0 < b && 0 < c && 0 < b * c
      ensures b * x % (b * c) == b * x % c
    {
      LemmaTruncateMiddle(x, b, c);
    }
  }

  lemma LemmaDivMultiplesVanishQuotient(x: int, a: int, d: int)
    requires 0 < x
    requires 0 <= a
    requires 0 < d
    ensures 0 < x * d
    ensures a / d == x * a / (x * d)
    decreases x, a, d
  {
    LemmaMulStrictlyPositive(x, d);
    calc {
      x * a / (x * d);
      {
        LemmaMulNonnegative(x, a);
        LemmaDivDenominator(x * a, x, d);
      }
      x * a / x / d;
      {
        LemmaDivMultiplesVanish(a, x);
      }
      a / d;
    }
  }

  lemma LemmaDivMultiplesVanishQuotientAuto()
    ensures (forall x: int, a: int, d: int {:trigger a / d, x * d, x * a} :: 0 < x && 0 <= a && 0 < d ==> 0 < x * d) && forall x: int, a: int, d: int {:trigger a / d, x * d, x * a} :: 0 < x && 0 <= a && 0 < d ==> a / d == x * a / (x * d)
  {
    forall x: int, a: int, d: int {:nowarn} | 0 < x && 0 <= a && 0 < d
      ensures 0 < x * d && a / d == x * a / (x * d)
    {
      LemmaDivMultiplesVanishQuotient(x, a, d);
    }
  }

  lemma LemmaRoundDown(a: int, r: int, d: int)
    requires 0 < d
    requires a % d == 0
    requires 0 <= r < d
    ensures a == d * (a + r) / d
    decreases a, r, d
  {
    LemmaMulAuto();
    LemmaDivInductionAuto(d, a, (u: int) => u % d == 0 ==> u == d * (u + r) / d);
  }

  lemma LemmaRoundDownAuto()
    ensures forall d: int, r: int, a: int {:trigger d * (a + r) / d} :: 0 < d && a % d == 0 && 0 <= r < d ==> a == d * (a + r) / d
  {
    forall a: int, r: int, d: int {:trigger d * (a + r) / d} | 0 < d && a % d == 0 && 0 <= r < d
      ensures a == d * (a + r) / d
    {
      LemmaRoundDown(a, r, d);
    }
  }

  lemma LemmaDivMultiplesVanishFancy(x: int, b: int, d: int)
    requires 0 < d
    requires 0 <= b < d
    ensures (d * x + b) / d == x
    decreases x, b, d
  {
    LemmaDivAuto(d);
    ghost var f := (u: int) => (d * u + b) / d == u;
    LemmaMulInductionAuto(x, f);
    assert f(x);
  }

  lemma LemmaDivMultiplesVanishFancyAuto()
    ensures forall d: int, b: int, x: int {:trigger (d * x + b) / d} :: 0 < d && 0 <= b < d ==> (d * x + b) / d == x
  {
    forall x: int, b: int, d: int {:trigger (d * x + b) / d} | 0 < d && 0 <= b < d
      ensures (d * x + b) / d == x
    {
      LemmaDivMultiplesVanishFancy(x, b, d);
    }
  }

  lemma LemmaDivMultiplesVanish(x: int, d: int)
    requires 0 < d
    ensures d * x / d == x
    decreases x, d
  {
    LemmaDivMultiplesVanishFancy(x, 0, d);
  }

  lemma LemmaDivMultiplesVanishAuto()
    ensures forall x: int, d: int {:trigger d * x / d} :: 0 < d ==> d * x / d == x
  {
    forall x: int, d: int | 0 < d
      ensures d * x / d == x
    {
      LemmaDivMultiplesVanish(x, d);
    }
  }

  lemma LemmaDivByMultiple(b: int, d: int)
    requires 0 <= b
    requires 0 < d
    ensures b * d / d == b
    decreases b, d
  {
    LemmaDivMultiplesVanish(b, d);
  }

  lemma LemmaDivByMultipleAuto()
    ensures forall b: int, d: int {:trigger b * d / d} :: 0 <= b && 0 < d ==> b * d / d == b
  {
    forall b: int, d: int | 0 <= b && 0 < d
      ensures b * d / d == b
    {
      LemmaDivByMultiple(b, d);
    }
  }

  lemma LemmaDivByMultipleIsStronglyOrdered(x: int, y: int, m: int, z: int)
    requires x < y
    requires y == m * z
    requires 0 < z
    ensures x / z < y / z
    decreases x, y, m, z
  {
    LemmaModMultiplesBasic(m, z);
    LemmaDivInductionAuto(z, y - x, (yx: int) => ghost var u: int := yx + x; x < u && u % z == 0 ==> x / z < u / z);
  }

  lemma LemmaDivByMultipleIsStronglyOrderedAuto()
    ensures forall z: int, m: int, y: int, x: int {:trigger x / z, m * z, y / z} :: x < y && y == m * z && 0 < z ==> x / z < y / z
  {
    forall x: int, y: int, m: int, z: int | x < y && y == m * z && 0 < z
      ensures x / z < y / z
    {
      LemmaDivByMultipleIsStronglyOrdered(x, y, m, z);
    }
  }

  lemma LemmaMultiplyDivideLe(a: int, b: int, c: int)
    requires 0 < b
    requires a <= b * c
    ensures a / b <= c
    decreases a, b, c
  {
    LemmaModMultiplesBasic(c, b);
    LemmaDivInductionAuto(b, b * c - a, (i: int) => 0 <= i && (i + a) % b == 0 ==> a / b <= (i + a) / b);
    LemmaDivMultiplesVanish(c, b);
  }

  lemma LemmaMultiplyDivideLeAuto()
    ensures forall a: int, b: int, c: int {:trigger a / b, b * c} :: 0 < b && a <= b * c ==> a / b <= c
  {
    forall a: int, b: int, c: int | 0 < b && a <= b * c
      ensures a / b <= c
    {
      LemmaMultiplyDivideLe(a, b, c);
    }
  }

  lemma LemmaMultiplyDivideLt(a: int, b: int, c: int)
    requires 0 < b
    requires a < b * c
    ensures a / b < c
    decreases a, b, c
  {
    LemmaModMultiplesBasic(c, b);
    LemmaDivInductionAuto(b, b * c - a, (i: int) => 0 < i && (i + a) % b == 0 ==> a / b < (i + a) / b);
    LemmaDivMultiplesVanish(c, b);
  }

  lemma LemmaMultiplyDivideLtAuto()
    ensures forall a: int, b: int, c: int {:trigger a / b, b * c} :: 0 < b && a < b * c ==> a / b < c
  {
    forall a: int, b: int, c: int | 0 < b && a < b * c
      ensures a / b < c
    {
      LemmaMultiplyDivideLt(a, b, c);
    }
  }

  lemma LemmaHoistOverDenominator(x: int, j: int, d: nat)
    requires 0 < d
    ensures x / d + j == (x + j * d) / d
    decreases x, j, d
  {
    LemmaDivAuto(d);
    LemmaMulInductionAuto(j, (u: int) => x / d + u == (x + u * d) / d);
  }

  lemma LemmaHoistOverDenominatorAuto()
    ensures forall x: int, j: int, d: nat {:trigger x / d + j} :: 0 < d ==> x / d + j == (x + j * d) / d
  {
    forall x: int, j: int, d: nat | 0 < d
      ensures x / d + j == (x + j * d) / d
    {
      LemmaHoistOverDenominator(x, j, d);
    }
  }

  lemma LemmaPartBound1(a: int, b: int, c: int)
    requires 0 <= a
    requires 0 < b
    requires 0 < c
    ensures 0 < b * c
    ensures b * a / b % (b * c) <= b * (c - 1)
    decreases a, b, c
  {
    LemmaMulStrictlyPositiveAuto();
    calc {
      b * a / b % (b * c);
      {
        LemmaFundamentalDivMod(b * a / b, b * c);
      }
      b * a / b - b * c * b * a / b / (b * c);
      {
        LemmaMulIsAssociativeAuto();
      }
      b * a / b - b * c * b * a / b / (b * c);
      {
        LemmaMulIsDistributiveAuto();
      }
      b * (a / b - c * b * a / b / (b * c));
    }
    calc ==> {
      true;
      {
        LemmaModPropertiesAuto();
      }
      b * a / b % (b * c) < b * c;
      b * (a / b - c * b * a / b / (b * c)) < b * c;
      {
        LemmaMulIsCommutativeAuto();
        LemmaMulStrictInequalityConverseAuto();
      }
      a / b - c * b * a / b / (b * c) < c;
      a / b - c * b * a / b / (b * c) <= c - 1;
      {
        LemmaMulIsCommutativeAuto();
        LemmaMulInequalityAuto();
      }
      b * (a / b - c * b * a / b / (b * c)) <= b * (c - 1);
      b * a / b % (b * c) <= b * (c - 1);
    }
  }

  lemma LemmaPartBound1Auto()
    ensures (forall a: int, b: int, c: int {:trigger b * a / b % (b * c)} :: 0 <= a && 0 < b && 0 < c ==> 0 < b * c) && forall a: int, b: int, c: int {:trigger b * a / b % (b * c)} :: 0 <= a && 0 < b && 0 < c ==> b * a / b % (b * c) <= b * (c - 1)
  {
    forall a: int, b: int, c: int {:nowarn} | 0 <= a && 0 < b && 0 < c
      ensures 0 < b * c && b * a / b % (b * c) <= b * (c - 1)
    {
      LemmaPartBound1(a, b, c);
    }
  }

  lemma /*{:_inductionTrigger ModRecursive(x, m)}*/ /*{:_induction x, m}*/ LemmaModIsModRecursive(x: int, m: int)
    requires m > 0
    ensures ModRecursive(x, m) == x % m
    decreases if x < 0 then -x + m else x
  {
    reveal ModRecursive();
    if x < 0 {
      calc {
        ModRecursive(x, m);
        ModRecursive(x + m, m);
        {
          LemmaModIsModRecursive(x + m, m);
        }
        (x + m) % m;
        {
          LemmaAddModNoop(x, m, m);
        }
        (x % m + m % m) % m;
        {
          LemmaModBasicsAuto();
        }
        x % m % m;
        {
          LemmaModBasicsAuto();
        }
        x % m;
      }
    } else if x < m {
      LemmaSmallMod(x, m);
    } else {
      calc {
        ModRecursive(x, m);
        ModRecursive(x - m, m);
        {
          LemmaModIsModRecursive(x - m, m);
        }
        (x - m) % m;
        {
          LemmaSubModNoop(x, m, m);
        }
        (x % m - m % m) % m;
        {
          LemmaModBasicsAuto();
        }
        x % m % m;
        {
          LemmaModBasicsAuto();
        }
        x % m;
      }
    }
  }

  lemma LemmaModIsModRecursiveAuto()
    ensures forall x: int, d: int {:trigger x % d} :: d > 0 ==> ModRecursive(x, d) == x % d
  {
    reveal ModRecursive();
    forall x: int, d: int | d > 0
      ensures ModRecursive(x, d) == x % d
    {
      LemmaModIsModRecursive(x, d);
    }
  }

  lemma LemmaModBasicsAuto()
    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0
    ensures forall x: int, m: int {:trigger x % m % m} :: m > 0 ==> x % m % m == x % m
  {
    forall m: int | m > 0
      ensures m % m == 0
    {
      LemmaModAuto(m);
    }
    forall x: int, m: int | m > 0
      ensures x % m % m == x % m
    {
      LemmaModAuto(m);
    }
  }

  lemma LemmaModPropertiesAuto()
    ensures forall m: int {:trigger m % m} :: m > 0 ==> m % m == 0
    ensures forall x: int, m: int {:trigger x % m % m} :: m > 0 ==> x % m % m == x % m
    ensures forall x: int, m: int {:trigger x % m} :: (m > 0 ==> 0 <= x % m) && (m > 0 ==> x % m < m)
  {
    LemmaModBasicsAuto();
    forall x: int, m: int | m > 0
      ensures 0 <= x % m < m
    {
      LemmaModAuto(m);
    }
  }

  lemma LemmaModDecreases(x: nat, m: nat)
    requires 0 < m
    ensures x % m <= x
    decreases x, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaModDecreasesAuto()
    ensures forall x: nat, m: nat {:trigger x % m} :: 0 < m ==> x % m <= x
  {
    forall x: nat, m: nat | 0 < m
      ensures x % m <= x
    {
      LemmaModDecreases(x, m);
    }
  }

  lemma LemmaModIsZero(x: nat, m: nat)
    requires x > 0 && m > 0
    requires x % m == 0
    ensures x >= m
    decreases x, m
  {
    calc ==> {
      x < m;
      {
        LemmaSmallMod(x, m);
      }
      x % m == x;
      false;
    }
  }

  lemma LemmaModIsZeroAuto()
    ensures forall m: nat, x: nat {:trigger x % m} :: x > 0 && m > 0 && x % m == 0 ==> x >= m
  {
    forall x: nat, m: nat | x > 0 && m > 0 && x % m == 0
      ensures x >= m
    {
      LemmaModIsZero(x, m);
    }
  }

  lemma LemmaModMultiplesBasic(x: int, m: int)
    requires m > 0
    ensures x * m % m == 0
    decreases x, m
  {
    LemmaModAuto(m);
    LemmaMulInductionAuto(x, (u: int) => u * m % m == 0);
  }

  lemma LemmaModMultiplesBasicAuto()
    ensures forall x: int, m: int {:trigger x * m % m} :: m > 0 ==> x * m % m == 0
  {
    forall x: int, m: int | m > 0
      ensures x * m % m == 0
    {
      LemmaModMultiplesBasic(x, m);
    }
  }

  lemma LemmaModAddMultiplesVanish(b: int, m: int)
    requires 0 < m
    ensures (m + b) % m == b % m
    decreases b, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaModAddMultiplesVanishAuto()
    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (m + b) % m == b % m
  {
    forall b: int, m: int | 0 < m
      ensures (m + b) % m == b % m
    {
      LemmaModAddMultiplesVanish(b, m);
    }
  }

  lemma LemmaModSubMultiplesVanish(b: int, m: int)
    requires 0 < m
    ensures (-m + b) % m == b % m
    decreases b, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaModSubMultiplesVanishAuto()
    ensures forall b: int, m: int {:trigger b % m} :: 0 < m ==> (-m + b) % m == b % m
  {
    forall b: int, m: int | 0 < m
      ensures (-m + b) % m == b % m
    {
      LemmaModSubMultiplesVanish(b, m);
    }
  }

  lemma LemmaModMultiplesVanish(a: int, b: int, m: int)
    requires 0 < m
    ensures (m * a + b) % m == b % m
    decreases if a > 0 then a else -a
  {
    LemmaModAuto(m);
    LemmaMulInductionAuto(a, (u: int) => (m * u + b) % m == b % m);
  }

  lemma LemmaModMultiplesVanishAuto()
    ensures forall a: int, b: int, m: int {:trigger (m * a + b) % m} :: 0 < m ==> (m * a + b) % m == b % m
  {
    forall a: int, b: int, m: int | 0 < m
      ensures (m * a + b) % m == b % m
    {
      LemmaModMultiplesVanish(a, b, m);
    }
  }

  lemma LemmaModSubtraction(x: nat, s: nat, d: nat)
    requires 0 < d
    requires 0 <= s <= x % d
    ensures x % d - s % d == (x - s) % d
    decreases x, s, d
  {
    LemmaModAuto(d);
  }

  lemma LemmaModSubtractionAuto()
    ensures forall x: nat, s: nat, d: nat {:trigger (x - s) % d} :: 0 < d && 0 <= s <= x % d ==> x % d - s % d == (x - s) % d
  {
    forall x: nat, s: nat, d: nat | 0 < d && 0 <= s <= x % d
      ensures x % d - s % d == (x - s) % d
    {
      LemmaModSubtraction(x, s, d);
    }
  }

  lemma LemmaAddModNoop(x: int, y: int, m: int)
    requires 0 < m
    ensures (x % m + y % m) % m == (x + y) % m
    decreases x, y, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaAddModNoopAuto()
    ensures forall x: int, y: int, m: int {:trigger (x + y) % m} :: 0 < m ==> (x % m + y % m) % m == (x + y) % m
  {
    forall x: int, y: int, m: int | 0 < m
      ensures (x % m + y % m) % m == (x + y) % m
    {
      LemmaAddModNoop(x, y, m);
    }
  }

  lemma LemmaAddModNoopRight(x: int, y: int, m: int)
    requires 0 < m
    ensures (x + y % m) % m == (x + y) % m
    decreases x, y, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaAddModNoopRightAuto()
    ensures forall x: int, y: int, m: int {:trigger (x + y) % m} :: 0 < m ==> (x + y % m) % m == (x + y) % m
  {
    forall x: int, y: int, m: int {:trigger (x + y) % m} | 0 < m
      ensures (x + y % m) % m == (x + y) % m
    {
      LemmaAddModNoopRight(x, y, m);
    }
  }

  lemma LemmaSubModNoop(x: int, y: int, m: int)
    requires 0 < m
    ensures (x % m - y % m) % m == (x - y) % m
    decreases x, y, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaSubModNoopAuto()
    ensures forall x: int, y: int, m: int {:trigger (x - y) % m} :: 0 < m ==> (x % m - y % m) % m == (x - y) % m
  {
    forall x: int, y: int, m: int | 0 < m
      ensures (x % m - y % m) % m == (x - y) % m
    {
      LemmaSubModNoop(x, y, m);
    }
  }

  lemma LemmaSubModNoopRight(x: int, y: int, m: int)
    requires 0 < m
    ensures (x - y % m) % m == (x - y) % m
    decreases x, y, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaSubModNoopRightAuto()
    ensures forall x: int, y: int, m: int {:trigger (x - y) % m} :: 0 < m ==> (x - y % m) % m == (x - y) % m
  {
    forall x: int, y: int, m: int {:trigger (x - y) % m} | 0 < m
      ensures (x - y % m) % m == (x - y) % m
    {
      LemmaSubModNoopRight(x, y, m);
    }
  }

  lemma LemmaModAdds(a: int, b: int, d: int)
    requires 0 < d
    ensures a % d + b % d == (a + b) % d + d * (a % d + b % d) / d
    ensures a % d + b % d < d ==> a % d + b % d == (a + b) % d
    decreases a, b, d
  {
    LemmaMulAuto();
    LemmaDivAuto(d);
  }

  lemma LemmaModAddsAuto()
    ensures forall a: int, b: int, d: int {:trigger (a + b) % d} :: (0 < d ==> a % d + b % d == (a + b) % d + d * (a % d + b % d) / d) && (0 < d ==> a % d + b % d < d ==> a % d + b % d == (a + b) % d)
  {
    forall a: int, b: int, d: int | 0 < d
      ensures a % d + b % d == (a + b) % d + d * (a % d + b % d) / d && (a % d + b % d < d ==> a % d + b % d == (a + b) % d)
    {
      LemmaModAdds(a, b, d);
    }
  }

  lemma {:vcs_split_on_every_assert} LemmaModNegNeg(x: int, d: int)
    requires 0 < d
    ensures x % d == x * (1 - d) % d
    decreases x, d
  {
    assert (x - x * d) % d == x % d by {
      LemmaModAuto(d);
      ghost var f := (i: int) => (x - i * d) % d == x % d;
      assert MulAuto() ==> f(0) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + 1)) && forall i: int {:trigger IsLe(i, 0)} :: IsLe(i, 0) && f(i) ==> f(i - 1);
      LemmaMulInductionAuto(x, f);
    }
    LemmaMulAuto();
  }

  lemma {:timeLimitMultiplier 5} /*{:_timeLimit 150}*/ LemmaFundamentalDivModConverse(x: int, d: int, q: int, r: int)
    requires d != 0
    requires 0 <= r < d
    requires x == q * d + r
    ensures q == x / d
    ensures r == x % d
    decreases x, d, q, r
  {
    LemmaDivAuto(d);
    LemmaMulInductionAuto(q, (u: int) => u == (u * d + r) / d);
    LemmaMulInductionAuto(q, (u: int) => r == (u * d + r) % d);
  }

  lemma {:timeLimitMultiplier 5} /*{:_timeLimit 150}*/ LemmaFundamentalDivModConverseAuto()
    ensures forall x: int, d: int, q: int, r: int {:trigger q * d + r, x % d} :: (d != 0 && 0 <= r < d && x == q * d + r ==> q == x / d) && (d != 0 && 0 <= r < d && x == q * d + r ==> r == x % d)
  {
    forall x: int, d: int, q: int, r: int {:nowarn} | d != 0 && 0 <= r < d && x == q * d + r
      ensures q == x / d && r == x % d
    {
      LemmaFundamentalDivModConverse(x, d, q, r);
    }
  }

  lemma LemmaModPosBound(x: int, m: int)
    requires 0 <= x
    requires 0 < m
    ensures 0 <= x % m < m
    decreases x
  {
    LemmaModAuto(m);
  }

  lemma LemmaModPosBoundAuto()
    ensures forall x: int, m: int {:trigger x % m} :: (0 <= x && 0 < m ==> 0 <= x % m) && (0 <= x && 0 < m ==> x % m < m)
  {
    forall x: int, m: int | 0 <= x && 0 < m
      ensures 0 <= x % m < m
    {
      LemmaModPosBound(x, m);
    }
  }

  lemma LemmaMulModNoopLeft(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m == x * y % m
    decreases x, y, m
  {
    LemmaModAuto(m);
    LemmaMulInductionAuto(y, (u: int) => x % m * u % m == x * u % m);
  }

  lemma LemmaMulModNoopLeftAuto()
    ensures forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> x % m * y % m == x * y % m
  {
    forall x: int, y: int, m: int | 0 < m
      ensures x % m * y % m == x * y % m
    {
      LemmaMulModNoopLeft(x, y, m);
    }
  }

  lemma LemmaMulModNoopRight(x: int, y: int, m: int)
    requires 0 < m
    ensures x * y % m % m == x * y % m
    decreases x, y, m
  {
    LemmaModAuto(m);
    LemmaMulInductionAuto(x, (u: int) => u * y % m % m == u * y % m);
  }

  lemma LemmaMulModNoopRightAuto()
    ensures forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> x * y % m % m == x * y % m
  {
    forall x: int, y: int, m: int | 0 < m
      ensures x * y % m % m == x * y % m
    {
      LemmaMulModNoopRight(x, y, m);
    }
  }

  lemma LemmaMulModNoopGeneral(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m == x * y % m
    ensures x * y % m % m == x * y % m
    ensures x % m * y % m % m == x * y % m
    decreases x, y, m
  {
    LemmaModPropertiesAuto();
    LemmaMulModNoopLeft(x, y, m);
    LemmaMulModNoopRight(x, y, m);
    LemmaMulModNoopRight(x % m, y, m);
  }

  lemma LemmaMulModNoopGeneralAuto()
    ensures (forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> x % m * y % m == x * y % m % m) && forall x: int, y: int, m: int {:trigger x * y % m} :: (0 < m ==> x * y % m % m == x % m * y % m % m) && (0 < m ==> x % m * y % m % m == x * y % m)
  {
    forall x: int, y: int, m: int | 0 < m
      ensures x % m * y % m == x * y % m % m == x % m * y % m % m == x * y % m
    {
      LemmaMulModNoopGeneral(x, y, m);
    }
  }

  lemma LemmaMulModNoop(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m * y % m % m == x * y % m
    decreases x, y, m
  {
    LemmaMulModNoopGeneral(x, y, m);
  }

  lemma LemmaMulModNoopAuto()
    ensures forall x: int, y: int, m: int {:trigger x * y % m} :: 0 < m ==> x % m * y % m % m == x * y % m
  {
    forall x: int, y: int, m: int | 0 < m
      ensures x % m * y % m % m == x * y % m
    {
      LemmaMulModNoop(x, y, m);
    }
  }

  lemma LemmaModEquivalence(x: int, y: int, m: int)
    requires 0 < m
    ensures x % m == y % m <==> (x - y) % m == 0
    decreases x, y, m
  {
    LemmaModAuto(m);
  }

  lemma LemmaModEquivalenceAuto()
    ensures forall x: int, y: int, m: int {:trigger x % m, y % m} :: 0 < m && x % m == y % m <==> 0 < m && (x - y) % m == 0
  {
    forall x: int, y: int, m: int | 0 < m
      ensures x % m == y % m <==> 0 < m && (x - y) % m == 0
    {
      LemmaModEquivalence(x, y, m);
    }
  }

  predicate IsModEquivalent(x: int, y: int, m: int)
    requires m > 0
    ensures x % m == y % m <==> (x - y) % m == 0
    decreases x, y, m
  {
    LemmaModEquivalence(x, y, m);
    (x - y) % m == 0
  }

  lemma LemmaModMulEquivalent(x: int, y: int, z: int, m: int)
    requires m > 0
    requires IsModEquivalent(x, y, m)
    ensures IsModEquivalent(x * z, y * z, m)
    decreases x, y, z, m
  {
    LemmaMulModNoopLeft(x, z, m);
    LemmaMulModNoopLeft(y, z, m);
  }

  lemma LemmaModMulEquivalentAuto()
    ensures forall x: int, y: int, z: int, m: int {:trigger IsModEquivalent(x * z, y * z, m)} :: m > 0 && IsModEquivalent(x, y, m) ==> IsModEquivalent(x * z, y * z, m)
  {
    forall x: int, y: int, z: int, m: int | m > 0 && IsModEquivalent(x, y, m)
      ensures IsModEquivalent(x * z, y * z, m)
    {
      LemmaModMulEquivalent(x, y, z, m);
    }
  }

  lemma LemmaModOrdering(x: int, k: int, d: int)
    requires 1 < d
    requires 0 < k
    ensures 0 < d * k
    ensures x % d <= x % (d * k)
    decreases x, k, d
  {
    LemmaMulStrictlyIncreases(d, k);
    calc {
      x % d + d * x / d;
      {
        LemmaFundamentalDivMod(x, d);
      }
      x;
      {
        LemmaFundamentalDivMod(x, d * k);
      }
      x % (d * k) + d * k * x / (d * k);
      {
        LemmaMulIsAssociativeAuto();
      }
      x % (d * k) + d * k * x / (d * k);
    }
    calc {
      x % d;
      {
        LemmaModPropertiesAuto();
      }
      x % d % d;
      {
        LemmaModMultiplesVanish(x / d - k * x / (d * k), x % d, d);
      }
      (x % d + d * (x / d - k * x / (d * k))) % d;
      {
        LemmaMulIsDistributiveSubAuto();
      }
      (x % d + d * x / d - d * k * x / (d * k)) % d;
      x % (d * k) % d;
    <=
      {
        LemmaModPropertiesAuto();
        LemmaModDecreases(x % (d * k), d);
      }
      x % (d * k);
    }
  }

  lemma LemmaModOrderingAuto()
    ensures forall x: int, k: int, d: int {:trigger x % (d * k)} :: (1 < d && 0 < k ==> 0 < d * k) && (1 < d && 0 < k ==> x % d <= x % (d * k))
  {
    forall x: int, k: int, d: int {:nowarn} | 1 < d && 0 < k
      ensures d * k > 0 && x % d <= x % (d * k)
    {
      LemmaModOrdering(x, k, d);
    }
  }

  lemma LemmaModMod(x: int, a: int, b: int)
    requires 0 < a
    requires 0 < b
    ensures 0 < a * b
    ensures x % (a * b) % a == x % a
    decreases x, a, b
  {
    LemmaMulStrictlyPositiveAuto();
    calc {
      x;
      {
        LemmaFundamentalDivMod(x, a * b);
      }
      a * b * x / (a * b) + x % (a * b);
      {
        LemmaMulIsAssociativeAuto();
      }
      a * b * x / (a * b) + x % (a * b);
      {
        LemmaFundamentalDivMod(x % (a * b), a);
      }
      a * b * x / (a * b) + a * x % (a * b) / a + x % (a * b) % a;
      {
        LemmaMulIsDistributiveAuto();
      }
      a * (b * x / (a * b) + x % (a * b) / a) + x % (a * b) % a;
    }
    LemmaModPropertiesAuto();
    LemmaMulIsCommutativeAuto();
    LemmaFundamentalDivModConverse(x, a, b * x / (a * b) + x % (a * b) / a, x % (a * b) % a);
  }

  lemma LemmaModModAuto()
    ensures (forall x: int, a: int, b: int {:trigger a * b, x % a} :: 0 < a && 0 < b ==> 0 < a * b) && forall x: int, a: int, b: int {:trigger a * b, x % a} :: 0 < a && 0 < b ==> x % (a * b) % a == x % a
  {
    forall x: int, a: int, b: int | 0 < a && 0 < b
      ensures 0 < a * b && x % (a * b) % a == x % a
    {
      LemmaModMod(x, a, b);
    }
  }

  lemma LemmaPartBound2(x: int, y: int, z: int)
    requires 0 <= x
    requires 0 < y
    requires 0 < z
    ensures y * z > 0
    ensures x % y % (y * z) < y
    decreases x, y, z
  {
    LemmaMulStrictlyPositiveAuto();
    LemmaModPropertiesAuto();
    assert x % y < y;
    LemmaMulIncreasesAuto();
    LemmaMulIsCommutativeAuto();
    assert y <= y * z;
    assert 0 <= x % y < y * z;
    LemmaModPropertiesAuto();
    LemmaSmallMod(x % y, y * z);
    assert x % y % (y * z) == x % y;
  }

  lemma LemmaPartBound2Auto()
    ensures (forall x: int, y: int, z: int {:trigger y * z, x % y} :: 0 <= x && 0 < y && 0 < z ==> y * z > 0) && forall x: int, y: int, z: int {:trigger y * z, x % y} :: 0 <= x && 0 < y && 0 < z ==> x % y % (y * z) < y
  {
    forall x: int, y: int, z: int {:nowarn} | 0 <= x && 0 < y && 0 < z
      ensures y * z > 0 && x % y % (y * z) < y
    {
      LemmaPartBound2(x, y, z);
    }
  }

  lemma LemmaModBreakdown(x: int, y: int, z: int)
    requires 0 <= x
    requires 0 < y
    requires 0 < z
    ensures y * z > 0
    ensures x % (y * z) == y * x / y % z + x % y
    decreases x, y, z
  {
    LemmaMulStrictlyPositiveAuto();
    LemmaDivPosIsPos(x, y);
    assert 0 <= x / y;
    calc {
      y * x / y % (y * z) + x % y % (y * z);
    <=
      {
        LemmaPartBound1(x, y, z);
      }
      y * (z - 1) + x % y % (y * z);
    <
      {
        LemmaPartBound2(x, y, z);
      }
      y * (z - 1) + y;
      {
        LemmaMulBasicsAuto();
      }
      y * (z - 1) + y * 1;
      {
        LemmaMulIsDistributiveAuto();
      }
      y * (z - 1 + 1);
      y * z;
    }
    calc {
      x % (y * z);
      {
        LemmaFundamentalDivMod(x, y);
      }
      (y * x / y + x % y) % (y * z);
      {
        LemmaModPropertiesAuto();
        assert 0 <= x % y;
        LemmaMulNonnegative(y, x / y);
        assert y * x / y % (y * z) + x % y % (y * z) < y * z;
        LemmaModAdds(y * x / y, x % y, y * z);
      }
      y * x / y % (y * z) + x % y % (y * z);
      {
        LemmaModPropertiesAuto();
        LemmaMulIncreases(z, y);
        LemmaMulIsCommutativeAuto();
        assert x % y < y <= y * z;
        LemmaSmallMod(x % y, y * z);
        assert x % y % (y * z) == x % y;
      }
      y * x / y % (y * z) + x % y;
      {
        LemmaTruncateMiddle(x / y, y, z);
      }
      y * x / y % z + x % y;
    }
  }

  lemma LemmaModBreakdownAuto()
    ensures forall x: int, y: int, z: int {:trigger x % (y * z)} :: (0 <= x && 0 < y && 0 < z ==> y * z > 0) && (0 <= x && 0 < y && 0 < z ==> x % (y * z) == y * x / y % z + x % y)
  {
    forall x: int, y: int, z: int | 0 <= x && 0 < y && 0 < z
      ensures y * z > 0 && x % (y * z) == y * x / y % z + x % y
    {
      LemmaModBreakdown(x, y, z);
    }
  }

  import opened DivInternals

  import DivINL = DivInternalsNonlinear

  import opened ModInternals

  import ModINL = ModInternalsNonlinear

  import opened MulInternals

  import opened Mul

  import opened GeneralInternals
}

module {:options "-functionSyntax:4"} DivInternals {
  function method {:opaque} DivPos(x: int, d: int): int
    requires d > 0
    decreases if x < 0 then d - x else x
  {
    if x < 0 then
      -1 + DivPos(x + d, d)
    else if x < d then
      0
    else
      1 + DivPos(x - d, d)
  }

  function method {:opaque} DivRecursive(x: int, d: int): int
    requires d != 0
    decreases x, d
  {
    reveal DivPos();
    if d > 0 then
      DivPos(x, d)
    else
      -1 * DivPos(x, -1 * d)
  }

  lemma LemmaDivBasics(n: int)
    requires n > 0
    ensures n / n == -(-n / n) == 1
    ensures forall x: int {:trigger x / n} :: 0 <= x < n <==> x / n == 0
    ensures forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1
    ensures forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1
    decreases n
  {
    LemmaModAuto(n);
    LemmaModBasics(n);
    LemmaSmallDiv();
    LemmaDivBySelf(n);
    forall x: int | x / n == 0
      ensures 0 <= x < n
    {
      LemmaFundamentalDivMod(x, n);
    }
  }

  predicate DivAuto(n: int)
    requires n > 0
    decreases n
  {
    ModAuto(n) &&
    n / n == -(-n / n) == 1 &&
    (forall x: int {:trigger x / n} :: 
      0 <= x < n <==> x / n == 0) &&
    (forall x: int, y: int {:trigger (x + y) / n} :: 
      ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) / n == x / n + y / n) || (n <= z < n + n && (x + y) / n == x / n + y / n + 1)) &&
    forall x: int, y: int {:trigger (x - y) / n} :: 
      ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) / n == x / n - y / n) || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1)
  }

  lemma LemmaDivAuto(n: int)
    requires n > 0
    ensures DivAuto(n)
    decreases n
  {
    LemmaModAuto(n);
    LemmaDivBasics(n);
    assert (0 + n) / n == 1;
    assert (0 - n) / n == -1;
    forall x: int, y: int {:trigger (x + y) / n} | true
      ensures ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) / n == x / n + y / n) || (n <= z < 2 * n && (x + y) / n == x / n + y / n + 1)
    {
      ghost var f := (xx: int, yy: int) => ghost var z: int := xx % n + yy % n; (0 <= z < n && (xx + yy) / n == xx / n + yy / n) || (n <= z < 2 * n && (xx + yy) / n == xx / n + yy / n + 1);
      forall i: int, j: int | true
        ensures j >= 0 && f(i, j) ==> f(i, j + n)
        ensures i < n && f(i, j) ==> f(i - n, j)
        ensures j < n && f(i, j) ==> f(i, j - n)
        ensures i >= 0 && f(i, j) ==> f(i + n, j)
      {
        assert (i + n + j) / n == (i + j + n) / n;
        assert (i + j + n) / n == (i + j + n) / n;
        assert (i - n + j) / n == (i + j - n) / n;
        assert (i + j - n) / n == (i + j - n) / n;
      }
      forall i: int, j: int | true
        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)
      {
        assert (i + n + j) / n == (i + j + n) / n;
        assert (i + j + n) / n == (i + j + n) / n;
        assert (i - n + j) / n == (i + j - n) / n;
        assert (i + j - n) / n == (i + j - n) / n;
      }
      LemmaModInductionForall2(n, f);
      assert f(x, y);
    }
    forall x: int, y: int {:trigger (x - y) / n} | true
      ensures ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) / n == x / n - y / n) || (-n <= z < 0 && (x - y) / n == x / n - y / n - 1)
    {
      ghost var f := (xx: int, yy: int) => ghost var z: int := xx % n - yy % n; (0 <= z < n && (xx - yy) / n == xx / n - yy / n) || (-n <= z < 0 && (xx - yy) / n == xx / n - yy / n - 1);
      forall i: int, j: int | true
        ensures j >= 0 && f(i, j) ==> f(i, j + n)
        ensures i < n && f(i, j) ==> f(i - n, j)
        ensures j < n && f(i, j) ==> f(i, j - n)
        ensures i >= 0 && f(i, j) ==> f(i + n, j)
      {
        assert (i + n - j) / n == (i - j + n) / n;
        assert (i - (j - n)) / n == (i - j + n) / n;
        assert (i - n - j) / n == (i - j - n) / n;
        assert (i - (j + n)) / n == (i - j - n) / n;
      }
      forall i: int, j: int | true
        ensures 0 <= i < n && 0 <= j < n ==> f(i, j)
      {
        assert (i + n - j) / n == (i - j + n) / n;
        assert (i - (j - n)) / n == (i - j + n) / n;
        assert (i - n - j) / n == (i - j - n) / n;
        assert (i - (j + n)) / n == (i - j - n) / n;
      }
      LemmaModInductionForall2(n, f);
      assert f(x, y);
    }
  }

  lemma LemmaDivInductionAuto(n: int, x: int, f: int -> bool)
    requires n > 0
    requires DivAuto(n) ==> (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n)
    ensures DivAuto(n)
    ensures f(x)
    decreases n, x
  {
    LemmaDivAuto(n);
    assert forall i: int {:trigger f(i)} {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i);
    assert forall i: int {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);
    assert forall i: int {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);
    LemmaModInductionForall(n, f);
    assert f(x);
  }

  lemma LemmaDivInductionAutoForall(n: int, f: int -> bool)
    requires n > 0
    requires DivAuto(n) ==> (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n)
    ensures DivAuto(n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
    LemmaDivAuto(n);
    assert forall i: int {:trigger f(i)} {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i);
    assert forall i: int {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);
    assert forall i: int {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);
    LemmaModInductionForall(n, f);
  }

  import opened GeneralInternals

  import opened ModInternals

  import opened ModInternalsNonlinear

  import opened DivInternalsNonlinear

  import opened MulInternals
}

module {:options "-functionSyntax:4"} ModInternals {
  function method {:opaque} ModRecursive(x: int, d: int): int
    requires d > 0
    decreases if x < 0 then d - x else x
  {
    if x < 0 then
      ModRecursive(d + x, d)
    else if x < d then
      x
    else
      ModRecursive(x - d, d)
  }

  lemma LemmaModInductionForall(n: int, f: int -> bool)
    requires n > 0
    requires forall i: int {:trigger f(i)} :: 0 <= i < n ==> f(i)
    requires forall i: int {:trigger f(i), f(i + n)} :: i >= 0 && f(i) ==> f(i + n)
    requires forall i: int {:trigger f(i), f(i - n)} :: i < n && f(i) ==> f(i - n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
    forall i: int | true
      ensures f(i)
    {
      LemmaInductionHelper(n, f, i);
    }
  }

  lemma LemmaModInductionForall2(n: int, f: (int, int) -> bool)
    requires n > 0
    requires forall i: int, j: int {:trigger f(i, j)} :: 0 <= i < n && 0 <= j < n ==> f(i, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i + n, j)} :: i >= 0 && f(i, j) ==> f(i + n, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i, j + n)} :: j >= 0 && f(i, j) ==> f(i, j + n)
    requires forall i: int, j: int {:trigger f(i, j), f(i - n, j)} :: i < n && f(i, j) ==> f(i - n, j)
    requires forall i: int, j: int {:trigger f(i, j), f(i, j - n)} :: j < n && f(i, j) ==> f(i, j - n)
    ensures forall i: int, j: int {:trigger f(i, j)} :: f(i, j)
    decreases n
  {
    forall x: int, y: int | true
      ensures f(x, y)
    {
      forall i: int | 0 <= i < n
        ensures f(i, y)
      {
        ghost var fj := (j: int) => f(i, j);
        LemmaModInductionForall(n, fj);
        assert fj(y);
      }
      ghost var fi := (i: int) => f(i, y);
      LemmaModInductionForall(n, fi);
      assert fi(x);
    }
  }

  lemma LemmaDivAddDenominator(n: int, x: int)
    requires n > 0
    ensures (x + n) / n == x / n + 1
    decreases n, x
  {
    LemmaFundamentalDivMod(x, n);
    LemmaFundamentalDivMod(x + n, n);
    assert x + n == n * (x + n) / n + (x + n) % n;
    ghost var zp := (x + n) / n - x / n - 1;
    assert 0 == n * zp + (x + n) % n - x % n by {
      LemmaMulDistributes();
    }
    if zp > 0 {
      assert (x + n) / n == x / n + 1 by {
        LemmaMulInequality(1, zp, n);
        assert n <= zp * n;
        assert n <= x;
      }
    }
    if zp < 0 {
      assert (x + n) / n == x / n + 1 by {
        LemmaMulInequality(zp, -1, n);
        assert zp * n <= -n;
        assert n <= x;
      }
    }
  }

  lemma LemmaDivSubDenominator(n: int, x: int)
    requires n > 0
    ensures (x - n) / n == x / n - 1
    decreases n, x
  {
    LemmaFundamentalDivMod(x, n);
    LemmaFundamentalDivMod(x - n, n);
    assert x - n == n * (x - n) / n + (x - n) % n;
    ghost var zm := (x - n) / n - x / n + 1;
    assert 0 == n * zm + (x - n) % n - x % n by {
      LemmaMulDistributes();
    }
    if zm > 0 {
      assert (x - n) / n == x / n - 1 by {
        LemmaMulInequality(1, zm, n);
        assert n <= zm * n;
        assert n <= x;
      }
    }
    if zm < 0 {
      assert (x - n) / n == x / n - 1 by {
        LemmaMulInequality(zm, -1, n);
        assert n <= zm * -n;
        assert n <= x;
      }
    }
  }

  lemma LemmaModAddDenominator(n: int, x: int)
    requires n > 0
    ensures (x + n) % n == x % n
    decreases n, x
  {
    LemmaFundamentalDivMod(x, n);
    LemmaFundamentalDivMod(x + n, n);
    assert x + n == n * (x + n) / n + (x + n) % n;
    ghost var zp := (x + n) / n - x / n - 1;
    assert 0 == n * zp + (x + n) % n - x % n by {
      LemmaMulDistributes();
    }
    if zp > 0 {
      assert (x + n) % n == x % n by {
        LemmaMulInequality(1, zp, n);
        assert n <= zp * n;
        assert n <= x;
      }
    }
    if zp < 0 {
      assert (x + n) % n == x % n by {
        LemmaMulInequality(zp, -1, n);
        assert zp * n <= -n;
        assert n <= x;
      }
    }
  }

  lemma LemmaModSubDenominator(n: int, x: int)
    requires n > 0
    ensures (x - n) % n == x % n
    decreases n, x
  {
    LemmaFundamentalDivMod(x, n);
    LemmaFundamentalDivMod(x - n, n);
    assert x - n == n * (x - n) / n + (x - n) % n;
    ghost var zm := (x - n) / n - x / n + 1;
    assert 0 == n * zm + (x - n) % n - x % n by {
      LemmaMulDistributes();
    }
    if zm > 0 {
      assert (x - n) % n == x % n by {
        LemmaMulInequality(1, zm, n);
        assert n <= zm * n;
        assert n <= x;
      }
    }
    if zm < 0 {
      assert (x - n) % n == x % n by {
        LemmaMulInequality(zm, -1, n);
        assert n <= zm * -n;
        assert n <= x;
      }
    }
  }

  lemma LemmaModBelowDenominator(n: int, x: int)
    requires n > 0
    ensures 0 <= x < n <==> x % n == x
    decreases n, x
  {
    forall x: int | true
      ensures 0 <= x < n <==> x % n == x
    {
      if 0 <= x < n {
        LemmaSmallMod(x, n);
      }
      LemmaModRange(x, n);
    }
  }

  lemma LemmaModBasics(n: int)
    requires n > 0
    ensures forall x: int {:trigger (x + n) % n} :: (x + n) % n == x % n
    ensures forall x: int {:trigger (x - n) % n} :: (x - n) % n == x % n
    ensures forall x: int {:trigger (x + n) / n} :: (x + n) / n == x / n + 1
    ensures forall x: int {:trigger (x - n) / n} :: (x - n) / n == x / n - 1
    ensures forall x: int {:trigger x % n} :: 0 <= x < n <==> x % n == x
    decreases n
  {
    forall x: int | true
      ensures (x + n) % n == x % n
      ensures (x - n) % n == x % n
      ensures (x + n) / n == x / n + 1
      ensures (x - n) / n == x / n - 1
      ensures 0 <= x < n <==> x % n == x
    {
      LemmaModBelowDenominator(n, x);
      LemmaModAddDenominator(n, x);
      LemmaModSubDenominator(n, x);
      LemmaDivAddDenominator(n, x);
      LemmaDivSubDenominator(n, x);
    }
  }

  lemma {:vcs_split_on_every_assert} LemmaQuotientAndRemainder(x: int, q: int, r: int, n: int)
    requires n > 0
    requires 0 <= r < n
    requires x == q * n + r
    ensures q == x / n
    ensures r == x % n
    decreases if q > 0 then q else -q
  {
    LemmaModBasics(n);
    if q > 0 {
      MulInternalsNonlinear.LemmaMulIsDistributiveAdd(n, q - 1, 1);
      LemmaMulIsCommutativeAuto();
      assert q * n + r == (q - 1) * n + n + r;
      LemmaQuotientAndRemainder(x - n, q - 1, r, n);
    } else if q < 0 {
      Mul.LemmaMulIsDistributiveSub(n, q + 1, 1);
      LemmaMulIsCommutativeAuto();
      assert q * n + r == (q + 1) * n - n + r;
      LemmaQuotientAndRemainder(x + n, q + 1, r, n);
    } else {
      LemmaSmallDiv();
      assert r / n == 0;
    }
  }

  predicate ModAuto(n: int)
    requires n > 0
    decreases n
  {
    n % n == -n % n == 0 &&
    (forall x: int {:trigger x % n % n} :: 
      x % n % n == x % n) &&
    (forall x: int {:trigger x % n} :: 
      0 <= x < n <==> x % n == x) &&
    (forall x: int, y: int {:trigger (x + y) % n} :: 
      ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) % n == z) || (n <= z < n + n && (x + y) % n == z - n)) &&
    forall x: int, y: int {:trigger (x - y) % n} :: 
      ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) % n == z) || (-n <= z < 0 && (x - y) % n == z + n)
  }

  lemma LemmaModAuto(n: int)
    requires n > 0
    ensures ModAuto(n)
    decreases n
  {
    LemmaModBasics(n);
    LemmaMulIsCommutativeAuto();
    LemmaMulIsDistributiveAddAuto();
    LemmaMulIsDistributiveSubAuto();
    forall x: int, y: int {:trigger (x + y) % n} | true
      ensures ghost var z: int := x % n + y % n; (0 <= z < n && (x + y) % n == z) || (n <= z < 2 * n && (x + y) % n == z - n)
    {
      ghost var xq, xr := x / n, x % n;
      LemmaFundamentalDivMod(x, n);
      assert x == xq * n + xr;
      ghost var yq, yr := y / n, y % n;
      LemmaFundamentalDivMod(y, n);
      assert y == yq * n + yr;
      if xr + yr < n {
        LemmaQuotientAndRemainder(x + y, xq + yq, xr + yr, n);
      } else {
        LemmaQuotientAndRemainder(x + y, xq + yq + 1, xr + yr - n, n);
      }
    }
    forall x: int, y: int {:trigger (x - y) % n} | true
      ensures ghost var z: int := x % n - y % n; (0 <= z < n && (x - y) % n == z) || (-n <= z < 0 && (x - y) % n == z + n)
    {
      ghost var xq, xr := x / n, x % n;
      LemmaFundamentalDivMod(x, n);
      assert x == xq * n + xr;
      ghost var yq, yr := y / n, y % n;
      LemmaFundamentalDivMod(y, n);
      assert y == yq * n + yr;
      if xr - yr >= 0 {
        LemmaQuotientAndRemainder(x - y, xq - yq, xr - yr, n);
      } else {
        LemmaQuotientAndRemainder(x - y, xq - yq - 1, xr - yr + n, n);
      }
    }
  }

  lemma LemmaModInductionAuto(n: int, x: int, f: int -> bool)
    requires n > 0
    requires ModAuto(n) ==> (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n)
    ensures ModAuto(n)
    ensures f(x)
    decreases n, x
  {
    LemmaModAuto(n);
    assert forall i: int {:trigger f(i)} {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i);
    assert forall i: int {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);
    assert forall i: int {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);
    LemmaModInductionForall(n, f);
    assert f(x);
  }

  lemma LemmaModInductionAutoForall(n: int, f: int -> bool)
    requires n > 0
    requires ModAuto(n) ==> (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i)) && (forall i: int {:trigger IsLe(0, i)} :: IsLe(0, i) && f(i) ==> f(i + n)) && forall i: int {:trigger IsLe(i + 1, n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n)
    ensures ModAuto(n)
    ensures forall i: int {:trigger f(i)} :: f(i)
    decreases n
  {
    LemmaModAuto(n);
    assert forall i: int {:trigger f(i)} {:trigger IsLe(0, i)} :: IsLe(0, i) && i < n ==> f(i);
    assert forall i: int {:trigger f(i), f(i + n)} :: IsLe(0, i) && f(i) ==> f(i + n);
    assert forall i: int {:trigger f(i), f(i - n)} :: IsLe(i + 1, n) && f(i) ==> f(i - n);
    LemmaModInductionForall(n, f);
  }

  import opened GeneralInternals

  import opened Mul

  import opened MulInternalsNonlinear

  import opened MulInternals

  import opened ModInternalsNonlinear

  import opened DivInternalsNonlinear
}

module {:options "-functionSyntax:4"} DivInternalsNonlinear {
  lemma LemmaDivOf0(d: int)
    requires d != 0
    ensures 0 / d == 0
    decreases d
  {
  }

  lemma LemmaDivBySelf(d: int)
    requires d != 0
    ensures d / d == 1
    decreases d
  {
  }

  lemma LemmaSmallDiv()
    ensures forall d: int, x: int {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0
  {
  }

  lemma LemmaRealDivGt(x: real, y: real)
    requires x > y
    requires x >= 0.0
    requires y > 0.0
    ensures x / y > 1 as real
    decreases x, y
  {
  }
}

module {:options "-functionSyntax:4"} ModInternalsNonlinear {
  lemma LemmaModOfZeroIsZero(m: int)
    requires 0 < m
    ensures 0 % m == 0
    decreases m
  {
  }

  lemma LemmaFundamentalDivMod(x: int, d: int)
    requires d != 0
    ensures x == d * x / d + x % d
    decreases x, d
  {
  }

  lemma Lemma0ModAnything()
    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0
  {
  }

  lemma LemmaSmallMod(x: nat, m: nat)
    requires x < m
    requires 0 < m
    ensures x % m == x
    decreases x, m
  {
  }

  lemma LemmaModRange(x: int, m: int)
    requires m > 0
    ensures 0 <= x % m < m
    decreases x, m
  {
  }
}

module {:options "-functionSyntax:4"} Logarithm {
  function method {:opaque} Log(base: nat, pow: nat): nat
    requires base > 1
    decreases pow
  {
    if pow < base then
      0
    else
      LemmaDivPosIsPosAuto(); LemmaDivDecreasesAuto(); 1 + Log(base, pow / base)
  }

  lemma {:induction false} LemmaLog0(base: nat, pow: nat)
    requires base > 1
    requires pow < base
    ensures Log(base, pow) == 0
    decreases base, pow
  {
    reveal Log();
  }

  lemma {:induction false} LemmaLogS(base: nat, pow: nat)
    requires base > 1
    requires pow >= base
    ensures pow / base >= 0
    ensures Log(base, pow) == 1 + Log(base, pow / base)
    decreases base, pow
  {
    LemmaDivPosIsPosAuto();
    reveal Log();
  }

  lemma {:induction false} LemmaLogSAuto()
    ensures forall pow: nat, base: nat {:trigger Log(base, pow / base)} | base > 1 && pow >= base :: pow / base >= 0 && Log(base, pow) == 1 + Log(base, pow / base)
  {
    forall base: nat, pow: nat | base > 1 && pow >= base
      ensures pow / base >= 0 && Log(base, pow) == 1 + Log(base, pow / base)
    {
      LemmaLogS(base, pow);
    }
  }

  lemma {:induction false} LemmaLogIsOrdered(base: nat, pow: nat, pow': nat)
    requires base > 1
    requires pow <= pow'
    ensures Log(base, pow) <= Log(base, pow')
    decreases pow
  {
    reveal Log();
    if pow' < base {
      assert Log(base, pow) == 0 == Log(base, pow');
    } else if pow < base {
      assert Log(base, pow) == 0;
    } else {
      LemmaDivPosIsPosAuto();
      LemmaDivDecreasesAuto();
      LemmaDivIsOrderedAuto();
      LemmaLogIsOrdered(base, pow / base, pow' / base);
    }
  }

  lemma {:induction false} LemmaLogPow(base: nat, n: nat)
    requires base > 1
    ensures (LemmaPowPositive(base, n); Log(base, Pow(base, n)) == n)
    decreases base, n
  {
    if n == 0 {
      reveal Pow();
      reveal Log();
    } else {
      LemmaPowPositive(base, n);
      calc {
        Log(base, Pow(base, n));
        {
          reveal Pow();
        }
        Log(base, base * Pow(base, n - 1));
        {
          LemmaPowPositive(base, n - 1);
          LemmaMulIncreases(Pow(base, n - 1), base);
          LemmaMulIsCommutative(Pow(base, n - 1), base);
          LemmaLogS(base, base * Pow(base, n - 1));
        }
        1 + Log(base, base * Pow(base, n - 1) / base);
        {
          LemmaDivMultiplesVanish(Pow(base, n - 1), base);
        }
        1 + Log(base, Pow(base, n - 1));
        {
          LemmaLogPow(base, n - 1);
        }
        1 + n - 1;
      }
    }
  }

  import opened Mul

  import opened DivMod

  import opened Power
}

module StandardLibraryInterop {

  import opened Wrappers
  class WrappersInterop {
    static function method CreateStringSome(s: string): Option<string>
      decreases s
    {
      Some(s)
    }

    static function method CreateStringNone(): Option<string>
    {
      None
    }

    static function method CreateBooleanSome(b: bool): Option<bool>
      decreases b
    {
      Some(b)
    }

    static function method CreateBooleanNone(): Option<bool>
    {
      None
    }
  }
}

module {:extern "UUID"} UUID {
  function method {:extern "ToByteArray"} ToByteArray(s: string): (res: Result<seq<uint8>, string>)
    ensures res.Success? ==> |res.value| == 16
    ensures res.Success? ==> FromByteArray(res.value).Success? && FromByteArray(res.value).value == s
    decreases s

  function method {:extern "FromByteArray"} FromByteArray(b: seq<uint8>): (res: Result<string, string>)
    requires |b| == 16
    decreases b

  method {:extern "GenerateUUID"} GenerateUUID() returns (res: Result<string, string>)
    ensures res.Success? ==> 0 < |res.value|

  function method CreateBytesSuccess(bytes: seq<uint8>): Result<seq<uint8>, string>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateBytesFailure(error: string): Result<seq<uint8>, string>
    decreases error
  {
    Failure(error)
  }

  function method CreateStringSuccess(s: string): Result<string, string>
    decreases s
  {
    Success(s)
  }

  function method CreateStringFailure(error: string): Result<string, string>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt
}

module StandardLibrary {
  lemma SeqTakeAppend<A>(s: seq<A>, i: int)
    requires 0 <= i < |s|
    ensures s[..i] + [s[i]] == s[..i + 1]
    decreases s, i
  {
  }

  function Join<T>(ss: seq<seq<T>>, joiner: seq<T>): (s: seq<T>)
    requires 0 < |ss|
    decreases ss, joiner
  {
    if |ss| == 1 then
      ss[0]
    else
      ss[0] + joiner + Join(ss[1..], joiner)
  } by method {
    SequenceIsSafeBecauseItIsInMemory(ss);
    var size := |ss| as uint64;
    var result: seq<T> := ss[size - 1];
    var i: uint64 := size - 1;
    while i > 0
      invariant result == Join(ss[i..], joiner)
      decreases i
    {
      i := i - 1;
      result := ss[i] + joiner + result;
    }
    return result;
  }

  function method {:tailrecursion} Split<T(==)>(s: seq<T>, delim: T): (res: seq<seq<T>>)
    ensures delim !in s ==> res == [s]
    ensures s == [] ==> res == [[]]
    ensures 0 < |res|
    ensures forall i: int {:trigger res[i]} :: 0 <= i < |res| ==> delim !in res[i]
    ensures Join(res, [delim]) == s
    decreases |s|
  {
    var i: Option<uint64> := FindIndexMatching(s, delim, 0);
    if i.Some? then
      [s[..i.value]] + Split(s[Add(i.value, 1)..], delim)
    else
      [s]
  }

  function method {:tailrecursion} SplitOnce<T(==)>(s: seq<T>, delim: T): (res: (seq<T>, seq<T>))
    requires delim in s
    ensures res.0 + [delim] + res.1 == s
    ensures !(delim in res.0)
    decreases s
  {
    var i: Option<uint64> := FindIndexMatching(s, delim, 0);
    assert i.Some?;
    (s[..i.value], s[Add(i.value, 1)..])
  }

  function method {:tailrecursion} SplitOnce?<T(==)>(s: seq<T>, delim: T): (res: Option<(seq<T>, seq<T>)>)
    ensures res.Some? ==> res.value.0 + [delim] + res.value.1 == s
    ensures res.None? ==> !(delim in s)
    ensures res.Some? ==> !(delim in res.value.0)
    decreases s
  {
    var i: uint64 :- FindIndexMatching(s, delim, 0); Some((s[..i], s[Add(i, 1)..]))
  }

  lemma {:vcs_split_on_every_assert} /*{:_inductionTrigger s[|prefix|]}*/ /*{:_inductionTrigger |s|}*/ /*{:_induction s}*/ WillSplitOnDelim<T>(s: seq<T>, delim: T, prefix: seq<T>)
    requires |prefix| < |s|
    requires forall i: int {:trigger s[i]} {:trigger prefix[i]} :: 0 <= i < |prefix| ==> prefix[i] == s[i]
    requires delim !in prefix && s[|prefix|] == delim
    ensures Split(s, delim) == [prefix] + Split(s[|prefix| + 1..], delim)
    decreases s, prefix
  {
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<uint64> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[Add(i.value, 1)..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |prefix| as uint64);
        assert FindIndexMatching(s, delim, 0).Some?;
      }
      [s[..|prefix|]] + Split(s[|prefix| + 1..], delim);
    ==
      {
        assert s[..|prefix|] == prefix;
      }
      [prefix] + Split(s[|prefix| + 1..], delim);
    }
  }

  lemma /*{:_inductionTrigger [s]}*/ /*{:_inductionTrigger Split(s, delim)}*/ /*{:_inductionTrigger delim in s}*/ /*{:_induction s}*/ WillNotSplitWithOutDelim<T>(s: seq<T>, delim: T)
    requires delim !in s
    ensures Split(s, delim) == [s]
    decreases s
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    calc {
      Split(s, delim);
    ==
      ghost var i: Option<uint64> := FindIndexMatching(s, delim, 0); if i.Some? then [s[..i.value]] + Split(s[i.value + 1..], delim) else [s];
    ==
      {
        FindIndexMatchingLocatesElem(s, delim, 0, |s| as uint64);
      }
      [s];
    }
  }

  lemma FindIndexMatchingLocatesElem<T>(s: seq<T>, c: T, start: uint64, elemIndex: uint64)
    requires start as nat <= elemIndex as nat <= |s|
    requires forall i: BoundedInts.uint64 {:trigger s[i]} :: start <= i < elemIndex ==> s[i] != c
    requires elemIndex as nat == |s| || s[elemIndex] == c
    ensures FindIndexMatching(s, c, start) == if elemIndex as nat == |s| then None else Some(elemIndex)
    decreases elemIndex - start
  {
  }

  function method FindIndexMatching<T(==)>(s: seq<T>, c: T, i: uint64): (index: Option<uint64>)
    requires i as nat <= |s|
    ensures index.Some? ==> i as nat <= index.value as nat < |s| && s[index.value] == c && c !in s[i .. index.value]
    ensures index.None? ==> c !in s[i..]
    decreases |s| - i as nat
  {
    FindIndex(s, (x: T) => x == c, i)
  }

  function method {:tailrecursion} FindIndex<T>(s: seq<T>, f: T -> bool, i: uint64): (index: Option<uint64>)
    requires i as nat <= |s|
    ensures index.Some? ==> i as nat <= index.value as nat < |s| && f(s[index.value]) && forall j: BoundedInts.uint64 {:trigger s[j]} :: i <= j < index.value ==> !f(s[j])
    ensures index.None? ==> forall j: int {:trigger s[j]} :: i as nat <= j < |s| ==> !f(s[j])
    decreases |s| - i as nat
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    if i == |s| as uint64 then
      None
    else if f(s[i]) then
      Some(i)
    else
      FindIndex(s, f, i + 1)
  }

  function Filter<T>(s: seq<T>, f: T -> bool): (res: seq<T>)
    ensures forall i: int {:trigger s[i]} :: 0 <= i < |s| && f(s[i]) ==> s[i] in res
    ensures forall i: int {:trigger res[i]} :: (0 <= i < |res| ==> res[i] in s) && (0 <= i < |res| ==> f(res[i]))
    ensures |res| <= |s|
    decreases s
  {
    if |s| == 0 then
      []
    else if f(s[0]) then
      [s[0]] + Filter(s[1..], f)
    else
      Filter(s[1..], f)
  } by method {
    SequenceIsSafeBecauseItIsInMemory(s);
    var result: seq<T> := [];
    var i: uint64 := |s| as uint64;
    while i > 0
      invariant result == Filter(s[i..], f)
      decreases i
    {
      i := i - 1;
      if f(s[i]) {
        result := [s[i]] + result;
      }
    }
    return result;
  }

  lemma /*{:_inductionTrigger Filter(s, f) + Filter(s', f)}*/ /*{:_inductionTrigger Filter(s + s', f)}*/ /*{:_induction s, s'}*/ FilterIsDistributive<T>(s: seq<T>, s': seq<T>, f: T -> bool)
    ensures Filter(s + s', f) == Filter(s, f) + Filter(s', f)
    decreases s, s'
  {
    if s == [] {
      assert s + s' == s';
    } else {
      ghost var S := s + s';
      ghost var s1 := s[1..];
      calc {
        Filter(S, f);
      ==
        if f(S[0]) then [S[0]] + Filter(S[1..], f) else Filter(S[1..], f);
      ==
        {
          assert S[0] == s[0] && S[1..] == s1 + s';
        }
        if f(s[0]) then [s[0]] + Filter(s1 + s', f) else Filter(s1 + s', f);
      ==
        {
          FilterIsDistributive(s1, s', f);
        }
        if f(s[0]) then [s[0]] + (Filter(s1, f) + Filter(s', f)) else Filter(s1, f) + Filter(s', f);
      ==
        if f(s[0]) then [s[0]] + Filter(s1, f) + Filter(s', f) else Filter(s1, f) + Filter(s', f);
      ==
        (if f(s[0]) then [s[0]] + Filter(s1, f) else Filter(s1, f)) + Filter(s', f);
      ==
        Filter(s, f) + Filter(s', f);
      }
    }
  }

  function method Min(a: int, b: int): int
    decreases a, b
  {
    if a < b then
      a
    else
      b
  }

  function method Fill<T>(value: T, n: nat): seq<T>
    ensures |Fill(value, n)| == n as nat
    ensures forall i: int {:trigger Fill(value, n)[i]} :: 0 <= i < n ==> Fill(value, n)[i] == value
    decreases n
  {
    seq(n, (_ /* _v0 */: int) => value)
  }

  method SeqToArray<T>(s: seq<T>) returns (a: array<T>)
    ensures fresh(a)
    ensures a.Length == |s|
    ensures forall i: int {:trigger s[i]} {:trigger a[i]} :: 0 <= i < |s| ==> a[i] == s[i]
    decreases s
  {
    a := new T[|s|] ((i: int) requires 0 <= i < |s| => s[i]);
  }

  lemma SeqPartsMakeWhole<T>(s: seq<T>, i: nat)
    requires 0 <= i <= |s|
    ensures s[..i] + s[i..] == s
    decreases s, i
  {
  }

  predicate method LexicographicLessOrEqual<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    decreases a, b
  {
    exists k: int {:trigger LexicographicLessOrEqualAux<T>(a, b, less, k)} :: 
      0 <= k <= |a| &&
      LexicographicLessOrEqualAux(a, b, less, k)
  }

  predicate method LexicographicLessOrEqualAux<T(==)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool, lengthOfCommonPrefix: nat)
    requires 0 <= lengthOfCommonPrefix <= |a|
    decreases a, b, lengthOfCommonPrefix
  {
    lengthOfCommonPrefix <= |b| &&
    (forall i: int {:trigger b[i]} {:trigger a[i]} :: 
      0 <= i < lengthOfCommonPrefix ==>
        a[i] == b[i]) &&
    (lengthOfCommonPrefix == |a| || (lengthOfCommonPrefix < |b| && less(a[lengthOfCommonPrefix], b[lengthOfCommonPrefix])))
  }

  predicate Trichotomous<T(!new)>(less: (T, T) -> bool)
  {
    (forall x: T, y: T {:trigger less(y, x)} {:trigger less(x, y)} :: 
      less(x, y) || x == y || less(y, x)) &&
    (forall x: T, y: T {:trigger less(y, x)} {:trigger less(x, y)} :: 
      less(x, y) &&
      less(y, x) ==>
        false) &&
    forall x: T, y: T {:trigger less(x, y)} :: 
      less(x, y) ==>
        x != y
  }

  predicate Transitive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T, z: T {:trigger R(x, z), R(y, z)} {:trigger R(y, z), R(x, y)} :: 
      R(x, y) &&
      R(y, z) ==>
        R(x, z)
  }

  lemma UInt8LessIsTrichotomousTransitive()
    ensures Trichotomous(UInt8Less)
    ensures Transitive(UInt8Less)
  {
  }

  lemma LexIsReflexive<T>(a: seq<T>, less: (T, T) -> bool)
    ensures LexicographicLessOrEqual(a, a, less)
    decreases a
  {
    assert LexicographicLessOrEqualAux(a, a, less, |a|);
  }

  lemma LexIsAntisymmetric<T(!new)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, a, less)
    ensures a == b
    decreases a, b
  {
    assert LessIrreflexive: forall x: T, y: T {:trigger less(x, y)} :: less(x, y) ==> x != y by {
      reveal Trich;
    }
    assert ASymmetric: forall x: T, y: T {:trigger less(y, x)} {:trigger less(x, y)} :: less(x, y) && less(y, x) ==> false by {
      reveal Trich;
    }
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, a, less, k1);
    ghost var max := if k0 < k1 then k1 else k0;
    assert max <= |a| && max <= |b|;
    assert SameUntilMax: forall i: int {:trigger b[i]} {:trigger a[i]} :: 0 <= i < max ==> a[i] == b[i];
    assert AA: k0 == |a| || (k0 < |b| && less(a[k0], b[k0]));
    assert BB: k1 == |b| || (k1 < |a| && less(b[k1], a[k1]));
    calc {
      true;
    ==>
      {
        reveal AA, BB;
      }
      (k0 == |a| || (k0 < |b| && less(a[k0], b[k0]))) &&
      (k1 == |b| || (k1 < |a| && less(b[k1], a[k1])));
    ==
      (k0 == |a| && k1 == |b|) || (k0 == |a| && k1 < |a| && less(b[k1], a[k1])) || (k0 < |b| && less(a[k0], b[k0]) && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==
      {
        reveal LessIrreflexive, SameUntilMax;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]));
    ==>
      {
        reveal LessIrreflexive, SameUntilMax;
        assert max <= k0 && max <= k1;
      }
      (k0 == |a| && k1 == |b|) || (k0 < |b| && less(a[k0], b[k0]) && k1 < |a| && less(b[k1], a[k1]) && k0 == k1 == max);
    ==
      {
        reveal ASymmetric;
      }
      k0 == |a| &&
      k1 == |b|;
    ==>
      {
        assert |a| == k0 <= max && |b| == k1 <= max ==> k0 == k1;
      }
      max == |a| == |b|;
    ==>
      {
        reveal SameUntilMax;
      }
      a == b;
    }
  }

  lemma LexIsTransitive<T(!new)>(a: seq<T>, b: seq<T>, c: seq<T>, less: (T, T) -> bool)
    requires Transitive(less)
    requires LexicographicLessOrEqual(a, b, less)
    requires LexicographicLessOrEqual(b, c, less)
    ensures LexicographicLessOrEqual(a, c, less)
    decreases a, b, c
  {
    ghost var k0 :| 0 <= k0 <= |a| && LexicographicLessOrEqualAux(a, b, less, k0);
    ghost var k1 :| 0 <= k1 <= |b| && LexicographicLessOrEqualAux(b, c, less, k1);
    ghost var k := if k0 < k1 then k0 else k1;
    assert LexicographicLessOrEqualAux(a, c, less, k);
  }

  lemma LexIsTotal<T(!new)>(a: seq<T>, b: seq<T>, less: (T, T) -> bool)
    requires Trich: Trichotomous(less)
    ensures LexicographicLessOrEqual(a, b, less) || LexicographicLessOrEqual(b, a, less)
    decreases a, b
  {
    ghost var m := 0;
    while m < |a| && m < |b| && a[m] == b[m]
      invariant m <= |a| && m <= |b|
      invariant forall i: int {:trigger b[i]} {:trigger a[i]} :: 0 <= i < m ==> a[i] == b[i]
      decreases |a| - m, if m < |a| then |b| - m else 0 - 1
    {
      m := m + 1;
    }
    if m == |a| == |b| {
      assert a == b;
      LexIsReflexive(a, less);
    } else if m == |a| < |b| {
      assert LexicographicLessOrEqualAux(a, b, less, m);
    } else if m == |b| < |a| {
      assert LexicographicLessOrEqualAux(b, a, less, m);
    } else {
      assert m < |a| && m < |b|;
      reveal Trich;
      if
      case less(a[m], b[m]) =>
        assert LexicographicLessOrEqualAux(a, b, less, m);
      case less(b[m], a[m]) =>
        assert LexicographicLessOrEqualAux(b, a, less, m);
    }
  }

  function SetToOrderedSequence<T(!new)>(s: set<seq<T>>, less: (T, T) -> bool): (q: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures |s| == |q|
    ensures forall i: int {:trigger q[i]} :: 0 <= i < |q| ==> q[i] in s
    ensures forall k: seq<T> {:trigger k in q} {:trigger k in s} :: k in s ==> k in q
    ensures forall i: int, _t#0: int {:trigger q[i], q[_t#0]} | _t#0 == i - 1 :: 0 < i && i < |q| ==> LexicographicLessOrEqual(q[_t#0], q[i], less)
    ensures forall i: int, j: int {:trigger q[j], q[i]} | 0 <= i < j < |q| :: q[i] != q[j]
    decreases s
  {
    if s == {} then
      []
    else
      ThereIsAMinimum(s, less); assert forall a: seq<T>, b: seq<T> {:trigger IsMinimum(b, s, less), IsMinimum(a, s, less)} :: IsMinimum(a, s, less) && IsMinimum(b, s, less) ==> a == b by {
    forall a: seq<T>, b: seq<T> | IsMinimum(a, s, less) && IsMinimum(b, s, less) {
      MinimumIsUnique(a, b, s, less);
    }
  } ghost var a: seq<T> /*{:_delayTriggerWarning}*/ {:trigger IsMinimum(a, s, less)} {:trigger a in s} :| a in s && IsMinimum(a, s, less); [a] + SetToOrderedSequence(s - {a}, less)
  }

  predicate method IsMinimum<T(==)>(a: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    decreases a, s
  {
    a in s &&
    forall z: seq<T> {:trigger LexicographicLessOrEqual<T>(a, z, less)} {:trigger z in s} :: 
      z in s ==>
        LexicographicLessOrEqual(a, z, less)
  }

  lemma ThereIsAMinimum<T(!new)>(s: set<seq<T>>, less: (T, T) -> bool)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures exists a: seq<T> {:trigger IsMinimum<T>(a, s, less)} :: IsMinimum(a, s, less)
    decreases s
  {
    ghost var a := FindMinimum(s, less);
  }

  lemma MinimumIsUnique<T(!new)>(a: seq<T>, b: seq<T>, s: set<seq<T>>, less: (T, T) -> bool)
    requires IsMinimum(a, s, less) && IsMinimum(b, s, less)
    requires Trichotomous(less)
    ensures a == b
    decreases a, b, s
  {
    LexIsAntisymmetric(a, b, less);
  }

  lemma FindMinimum<T(!new)>(s: set<seq<T>>, less: (T, T) -> bool) returns (a: seq<T>)
    requires s != {}
    requires Trichotomous(less) && Transitive(less)
    ensures IsMinimum(a, s, less)
    decreases s
  {
    a :| a in s;
    if s == {a} {
      LexIsReflexive(a, less);
    } else {
      ghost var s' := s - {a};
      assert forall x: seq<T> {:trigger x in s'} {:trigger x in s} :: x in s <==> x == a || x in s';
      ghost var a' := FindMinimum(s', less);
      if LexicographicLessOrEqual(a', a, less) {
        a := a';
      } else {
        assert LexicographicLessOrEqual(a, a', less) by {
          LexIsTotal(a, a', less);
        }
        forall z: seq<T> | z in s
          ensures LexicographicLessOrEqual(a, z, less)
        {
          if z == a {
            LexIsReflexive(a, less);
          } else {
            calc {
              true;
            ==
              z in s';
            ==>
              LexicographicLessOrEqual(a', z, less);
            ==>
              {
                LexIsTransitive(a, a', z, less);
              }
              LexicographicLessOrEqual(a, z, less);
            }
          }
        }
      }
    }
  }

  import opened Wrappers

  import opened U = UInt

  import opened MemoryMath

  module {:options "--function-syntax:4"} MemoryMath {
    lemma {:axiom} ValueIsSafeBecauseItIsInMemory(value: nat)
      ensures HasUint64Size(value)
      decreases value

    lemma SequenceIsSafeBecauseItIsInMemory<T>(value: seq<T>)
      ensures HasUint64Len(value)
      decreases value
    {
      ValueIsSafeBecauseItIsInMemory(|value|);
    }

    lemma SetIsSafeBecauseItIsInMemory<T>(value: set<T>)
      ensures HasUint64Size(|value|)
      decreases value
    {
      ValueIsSafeBecauseItIsInMemory(|value|);
    }

    lemma OptionalSequenceIsSafeBecauseItIsInMemory<T>(value: Option<seq<T>>)
      ensures value.Some? ==> HasUint64Len(value.value)
      decreases value
    {
      if value.Some? {
        SequenceIsSafeBecauseItIsInMemory(value.value);
      }
    }

    lemma MapIsSafeBecauseItIsInMemory<K, V>(value: map<K, V>)
      ensures HasUint64Size(|value|)
      decreases value
    {
      ValueIsSafeBecauseItIsInMemory(|value|);
    }

    lemma OptionalMapIsSafeBecauseItIsInMemory<K, V>(value: Option<map<K, V>>)
      ensures value.Some? ==> HasUint64Size(|value.value|)
      decreases value
    {
      if value.Some? {
        ValueIsSafeBecauseItIsInMemory(|value.value|);
      }
    }

    lemma ArrayIsSafeBecauseItIsInMemory<T>(value: array<T>)
      ensures HasUint64Size(value.Length)
      decreases value
    {
      ValueIsSafeBecauseItIsInMemory(value.Length);
    }

    function method {:opaque} Add(x: uint64, y: uint64): (ret: uint64)
      ensures ret as nat == x as nat + y as nat
      decreases x, y
    {
      ValueIsSafeBecauseItIsInMemory(x as nat + y as nat);
      x + y
    }

    function method {:opaque} Add3(x: uint64, y: uint64, z: uint64): (ret: uint64)
      ensures ret as nat == x as nat + y as nat + z as nat
      decreases x, y, z
    {
      ValueIsSafeBecauseItIsInMemory(x as nat + y as nat + z as nat);
      x + y + z
    }

    function method {:opaque} Add4(w: uint64, x: uint64, y: uint64, z: uint64): (ret: uint64)
      ensures ret as nat == w as nat + x as nat + y as nat + z as nat
      decreases w, x, y, z
    {
      ValueIsSafeBecauseItIsInMemory(w as nat + x as nat + y as nat + z as nat);
      w + x + y + z
    }

    import opened UInt

    import opened Wrappers
  }

  module UInt {
    const UINT16_LIMIT := BoundedInts.UINT16_MAX as int + 1
    const UINT32_LIMIT := BoundedInts.UINT32_MAX as int + 1
    const UINT64_LIMIT := BoundedInts.UINT64_MAX as int + 1
    const INT32_MAX_LIMIT := BoundedInts.INT32_MAX as int
    const INT64_MAX_LIMIT := BoundedInts.INT64_MAX as int
    const UINT64_MAX_LIMIT := BoundedInts.UINT64_MAX as int

    predicate method UInt8Less(a: uint8, b: uint8)
      decreases a, b
    {
      a < b
    }

    predicate method HasUint16Len<T>(s: seq<T>)
      decreases s
    {
      |s| < UINT16_LIMIT
    }

    predicate method HasUint32Len<T>(s: seq<T>)
      decreases s
    {
      |s| < UINT32_LIMIT
    }

    predicate method HasUint64Len<T>(s: seq<T>)
      decreases s
    {
      |s| < UINT64_LIMIT
    }

    predicate method HasUint16Size(s: nat)
      decreases s
    {
      s < UINT16_LIMIT
    }

    predicate method HasUint32Size(s: nat)
      decreases s
    {
      s < UINT32_LIMIT
    }

    predicate method HasUint64Size(s: nat)
      decreases s
    {
      s < UINT64_LIMIT
    }

    function method UInt16ToSeq(x: uint16): (ret: seq<uint8>)
      ensures |ret| == 2
      ensures 256 * ret[0] as uint16 + ret[1] as uint16 == x
      decreases x
    {
      var b0: uint8 := (x / 256) as uint8;
      var b1: uint8 := (x % 256) as uint8;
      [b0, b1]
    }

    function method SeqToUInt16(s: seq<uint8>): (x: uint16)
      requires |s| == 2
      ensures UInt16ToSeq(x) == s
      ensures x >= 0
      decreases s
    {
      var x0: BoundedInts.uint16 := s[0 as uint32] as uint16 * 256;
      x0 + s[1 as uint32] as uint16
    }

    function method SeqPosToUInt16(s: seq<uint8>, pos: uint64): (x: uint16)
      requires HasUint64Len(s)
      requires |s| >= pos as nat + 2
      ensures UInt16ToSeq(x) == s[pos .. pos + 2]
      ensures x >= 0
      decreases s, pos
    {
      var x0: BoundedInts.uint16 := s[pos] as uint16 * 256;
      x0 + s[pos + 1] as uint16
    }

    function method SeqPosToUInt32(s: seq<uint8>, pos: uint64): (x: uint32)
      requires HasUint64Len(s)
      requires |s| >= pos as nat + 4
      ensures UInt32ToSeq(x) == s[pos .. pos + 4]
      decreases s, pos
    {
      var x0: BoundedInts.uint32 := s[pos] as uint32 * 16777216;
      var x1: BoundedInts.uint32 := x0 + s[pos + 1] as uint32 * 65536;
      var x2: BoundedInts.uint32 := x1 + s[pos + 2] as uint32 * 256;
      x2 + s[pos + 3] as uint32
    }

    function method SeqPosToUInt64(s: seq<uint8>, pos: uint64): (x: uint64)
      requires HasUint64Len(s)
      requires pos as nat + 8 <= |s|
      ensures UInt64ToSeq(x) == s[pos .. pos + 8]
      decreases s, pos
    {
      var x0: BoundedInts.uint64 := s[pos] as uint64 * 72057594037927936;
      var x1: BoundedInts.uint64 := x0 + s[pos + 1] as uint64 * 281474976710656;
      var x2: BoundedInts.uint64 := x1 + s[pos + 2] as uint64 * 1099511627776;
      var x3: BoundedInts.uint64 := x2 + s[pos + 3] as uint64 * 4294967296;
      var x4: BoundedInts.uint64 := x3 + s[pos + 4] as uint64 * 16777216;
      var x5: BoundedInts.uint64 := x4 + s[pos + 5] as uint64 * 65536;
      var x6: BoundedInts.uint64 := x5 + s[pos + 6] as uint64 * 256;
      var x: BoundedInts.uint64 := x6 + s[pos + 7] as uint64;
      assert x == SeqToUInt64(s[pos .. pos + 8]);
      x
    }

    lemma SeqPosToUInt16Same(s: seq<uint8>, pos: uint64)
      requires |s| < BoundedInts.UINT64_MAX as nat
      requires |s| >= pos as nat + 2
      ensures UInt16ToSeq(SeqPosToUInt16(s, pos)) == s[pos .. pos + 2]
      ensures SeqToUInt16(s[pos .. pos + 2]) == SeqPosToUInt16(s, pos)
      decreases s, pos
    {
    }

    lemma SeqPosToUInt32Same(s: seq<uint8>, pos: uint64)
      requires |s| < BoundedInts.UINT64_MAX as nat
      requires |s| >= pos as nat + 4
      ensures UInt32ToSeq(SeqPosToUInt32(s, pos)) == s[pos .. pos + 4]
      ensures SeqToUInt32(s[pos .. pos + 4]) == SeqPosToUInt32(s, pos)
      decreases s, pos
    {
    }

    lemma SeqPosToUInt64Same(s: seq<uint8>, pos: uint64)
      requires |s| < BoundedInts.UINT64_MAX as nat
      requires |s| >= pos as nat + 8
      ensures UInt64ToSeq(SeqPosToUInt64(s, pos)) == s[pos .. pos + 8]
      ensures SeqToUInt64(s[pos .. pos + 8]) == SeqPosToUInt64(s, pos)
      decreases s, pos
    {
    }

    lemma UInt16SeqSerializeDeserialize(x: uint16)
      ensures SeqToUInt16(UInt16ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt16SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 2
      ensures UInt16ToSeq(SeqToUInt16(s)) == s
      decreases s
    {
    }

    function method UInt32ToSeq(x: uint32): (ret: seq<uint8>)
      ensures |ret| == 4
      ensures 16777216 * ret[0] as uint32 + 65536 * ret[1] as uint32 + 256 * ret[2] as uint32 + ret[3] as uint32 == x
      decreases x
    {
      var b0: uint8 := (x / 16777216) as uint8;
      var x0: BoundedInts.uint32 := x - b0 as uint32 * 16777216;
      var b1: uint8 := (x0 / 65536) as uint8;
      var x1: BoundedInts.uint32 := x0 - b1 as uint32 * 65536;
      var b2: uint8 := (x1 / 256) as uint8;
      var b3: uint8 := (x1 % 256) as uint8;
      [b0, b1, b2, b3]
    }

    function method SeqToUInt32(s: seq<uint8>): (x: uint32)
      requires |s| == 4
      ensures UInt32ToSeq(x) == s
      decreases s
    {
      var x0: BoundedInts.uint32 := s[0 as uint32] as uint32 * 16777216;
      var x1: BoundedInts.uint32 := x0 + s[1 as uint32] as uint32 * 65536;
      var x2: BoundedInts.uint32 := x1 + s[2 as uint32] as uint32 * 256;
      x2 + s[3 as uint32] as uint32
    }

    lemma UInt32SeqSerializeDeserialize(x: uint32)
      ensures SeqToUInt32(UInt32ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt32SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 4
      ensures UInt32ToSeq(SeqToUInt32(s)) == s
      decreases s
    {
    }

    function method UInt64ToSeq(x: uint64): (ret: seq<uint8>)
      ensures |ret| == 8
      ensures 72057594037927936 * ret[0] as uint64 + 281474976710656 * ret[1] as uint64 + 1099511627776 * ret[2] as uint64 + 4294967296 * ret[3] as uint64 + 16777216 * ret[4] as uint64 + 65536 * ret[5] as uint64 + 256 * ret[6] as uint64 + ret[7] as uint64 == x
      decreases x
    {
      var b0: uint8 := (x / 72057594037927936) as uint8;
      var x0: BoundedInts.uint64 := x - b0 as uint64 * 72057594037927936;
      var b1: uint8 := (x0 / 281474976710656) as uint8;
      var x1: BoundedInts.uint64 := x0 - b1 as uint64 * 281474976710656;
      var b2: uint8 := (x1 / 1099511627776) as uint8;
      var x2: BoundedInts.uint64 := x1 - b2 as uint64 * 1099511627776;
      var b3: uint8 := (x2 / 4294967296) as uint8;
      var x3: BoundedInts.uint64 := x2 - b3 as uint64 * 4294967296;
      var b4: uint8 := (x3 / 16777216) as uint8;
      var x4: BoundedInts.uint64 := x3 - b4 as uint64 * 16777216;
      var b5: uint8 := (x4 / 65536) as uint8;
      var x5: BoundedInts.uint64 := x4 - b5 as uint64 * 65536;
      var b6: uint8 := (x5 / 256) as uint8;
      var b7: uint8 := (x5 % 256) as uint8;
      [b0, b1, b2, b3, b4, b5, b6, b7]
    }

    function method SeqToUInt64(s: seq<uint8>): (x: uint64)
      requires |s| == 8
      ensures UInt64ToSeq(x) == s
      decreases s
    {
      var x0: BoundedInts.uint64 := s[0 as uint32] as uint64 * 72057594037927936;
      var x1: BoundedInts.uint64 := x0 + s[1 as uint32] as uint64 * 281474976710656;
      var x2: BoundedInts.uint64 := x1 + s[2 as uint32] as uint64 * 1099511627776;
      var x3: BoundedInts.uint64 := x2 + s[3 as uint32] as uint64 * 4294967296;
      var x4: BoundedInts.uint64 := x3 + s[4 as uint32] as uint64 * 16777216;
      var x5: BoundedInts.uint64 := x4 + s[5 as uint32] as uint64 * 65536;
      var x6: BoundedInts.uint64 := x5 + s[6 as uint32] as uint64 * 256;
      var x: BoundedInts.uint64 := x6 + s[7 as uint32] as uint64;
      UInt64SeqSerialize(x, s);
      x
    }

    lemma UInt64SeqSerialize(x: uint64, s: seq<uint8>)
      requires |s| == 8
      requires 72057594037927936 * s[0] as uint64 + 281474976710656 * s[1] as uint64 + 1099511627776 * s[2] as uint64 + 4294967296 * s[3] as uint64 + 16777216 * s[4] as uint64 + 65536 * s[5] as uint64 + 256 * s[6] as uint64 + s[7] as uint64 == x
      ensures UInt64ToSeq(x) == s
      decreases x, s
    {
      calc {
        UInt64ToSeq(x);
      ==
        UInt64ToSeq(s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64);
      ==
        ghost var b0: uint8 := ((s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64) / 72057594037927936) as uint8; assert b0 == s[0]; ghost var x0: BoundedInts.uint64 := s[0] as uint64 * 72057594037927936 + s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64 - b0 as uint64 * 72057594037927936; assert x0 == s[1] as uint64 * 281474976710656 + s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b1: uint8 := (x0 / 281474976710656) as uint8; assert b1 == s[1]; ghost var x1: BoundedInts.uint64 := x0 - b1 as uint64 * 281474976710656; assert x1 == s[2] as uint64 * 1099511627776 + s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b2: uint8 := (x1 / 1099511627776) as uint8; assert b2 == s[2]; ghost var x2: BoundedInts.uint64 := x1 - b2 as uint64 * 1099511627776; assert x2 == s[3] as uint64 * 4294967296 + s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b3: uint8 := (x2 / 4294967296) as uint8; assert b3 == s[3]; ghost var x3: BoundedInts.uint64 := x2 - b3 as uint64 * 4294967296; assert x3 == s[4] as uint64 * 16777216 + s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b4: uint8 := (x3 / 16777216) as uint8; assert b4 == s[4]; ghost var x4: BoundedInts.uint64 := x3 - b4 as uint64 * 16777216; assert x4 == s[5] as uint64 * 65536 + s[6] as uint64 * 256 + s[7] as uint64; ghost var b5: uint8 := (x4 / 65536) as uint8; assert b5 == s[5]; ghost var x5: BoundedInts.uint64 := x4 - b5 as uint64 * 65536; assert x5 == s[6] as uint64 * 256 + s[7] as uint64; ghost var b6: uint8 := (x5 / 256) as uint8; assert b6 == s[6]; ghost var b7: uint8 := (x5 % 256) as uint8; assert b7 == s[7]; [b0, b1, b2, b3, b4, b5, b6, b7];
      ==
        [s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7]];
      ==
        s;
      }
    }

    lemma UInt64SeqSerializeDeserialize(x: uint64)
      ensures SeqToUInt64(UInt64ToSeq(x)) == x
      decreases x
    {
    }

    lemma UInt64SeqDeserializeSerialize(s: seq<uint8>)
      requires |s| == 8
      ensures UInt64ToSeq(SeqToUInt64(s)) == s
      decreases s
    {
    }

    function SeqToNat(s: seq<uint8>): nat
      decreases s
    {
      if s == [] then
        0
      else
        ghost var finalIndex: int := |s| - 1; SeqToNat(s[..finalIndex]) * 256 + s[finalIndex] as nat
    }

    lemma /*{:_inductionTrigger [0] + s}*/ /*{:_induction s}*/ SeqToNatZeroPrefix(s: seq<uint8>)
      ensures SeqToNat(s) == SeqToNat([0] + s)
      decreases s
    {
      if s == [] {
      } else {
        ghost var s' := [0] + s;
        ghost var sLength := |s|;
        ghost var sFinalIndex := sLength - 1;
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          SeqToNat([0] + s[..sFinalIndex]) * 256 + s[sFinalIndex] as nat;
        ==
          {
            assert s'[..sLength] == [0] + s[..sFinalIndex] && s'[sLength] == s[sFinalIndex];
          }
          SeqToNat(s'[..sLength]) * 256 + s'[sLength] as nat;
        ==
          SeqToNat(s');
        ==
          SeqToNat([0] + s);
        }
      }
    }

    lemma /*{:_inductionTrigger SeqToNat(s)}*/ /*{:_inductionTrigger |s|}*/ /*{:_induction s}*/ SeqWithUInt32Suffix(s: seq<uint8>, n: nat)
      requires n < UINT32_LIMIT
      requires 4 <= |s|
      requires ghost var suffixStartIndex: int := |s| - 4; s[suffixStartIndex..] == UInt32ToSeq(n as uint32) && forall i: int {:trigger s[i]} :: 0 <= i < suffixStartIndex ==> s[i] == 0
      ensures SeqToNat(s) == n
      decreases s, n
    {
      if |s| == 4 {
        calc {
          SeqToNat(s);
        ==
          SeqToNat(s[..3]) * 256 + s[3] as nat;
        ==
          {
            assert s[..3][..2] == s[..2] && s[..3][2] == s[2];
          }
          (SeqToNat(s[..2]) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..2][..1] == s[..1] && s[..2][1] == s[1];
          }
          ((SeqToNat(s[..1]) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          {
            assert s[..1][..0] == s[..0] && s[..1][0] == s[0];
          }
          (((SeqToNat(s[..0]) * 256 + s[0] as nat) * 256 + s[1] as nat) * 256 + s[2] as nat) * 256 + s[3] as nat;
        ==
          n;
        }
      } else {
        assert s == [0] + s[1..];
        SeqToNatZeroPrefix(s[1..]);
        SeqWithUInt32Suffix(s[1..], n);
      }
    }

    import BoundedInts

    type uint8 = BoundedInts.uint8

    type uint16 = BoundedInts.uint16

    type uint32 = BoundedInts.uint32

    type uint64 = BoundedInts.uint64

    type int32 = BoundedInts.int32

    type int64 = BoundedInts.int64

    type seq16<T> = s: seq<T>
      | HasUint16Len(s)

    type Uint8Seq16 = seq16<uint8>

    type seq32<T> = s: seq<T>
      | HasUint32Len(s)

    type Uint8Seq32 = seq32<uint8>

    type seq64<T> = s: seq<T>
      | HasUint64Len(s)

    type Uint8Seq64 = seq64<uint8>
  }

  module String {
    const Base10: seq<char> := ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

    function method {:tailrecursion} Int2Digits(n: int, base: int): (digits: seq<int>)
      requires base > 1
      requires n >= 0
      ensures forall d: int {:trigger d in digits} | d in digits :: 0 <= d && d < base
      decreases n
    {
      if n == 0 then
        []
      else
        assert n > 0; assert base > 1; assert n < base * n; assert n / base < n; Int2Digits(n / base, base) + [n % base]
    }

    function method {:tailrecursion} Digits2String(digits: seq<int>, chars: seq<char>): string
      requires forall d: int {:trigger d in digits} | d in digits :: 0 <= d && d < |chars|
      decreases digits, chars
    {
      if digits == [] then
        ""
      else
        assert digits[0] in digits; assert forall d: int {:trigger d in digits} {:trigger d in digits[1..]} | d in digits[1..] :: d in digits; [chars[digits[0]]] + Digits2String(digits[1..], chars)
    }

    function method Int2String(n: int, chars: seq<char>): string
      requires |chars| > 1
      decreases n, chars
    {
      var base: int := |chars|;
      if n == 0 then
        "0"
      else if n > 0 then
        Digits2String(Int2Digits(n, base), chars)
      else
        "-" + Digits2String(Int2Digits(-n, base), chars)
    }

    function method Base10Int2String(n: int): string
      decreases n
    {
      Int2String(n, Base10)
    }

    method HasSubString<T(==)>(haystack: seq<T>, needle: seq<T>) returns (o: Wrappers.Option<nat>)
      ensures o.Some? ==> o.value <= |haystack| - |needle| && haystack[o.value .. o.value + |needle|] == needle && forall i: int {:trigger haystack[i..]} | 0 <= i < o.value :: haystack[i..][..|needle|] != needle
      ensures |haystack| < |needle| ==> o.None?
      ensures o.None? && |needle| <= |haystack| && |haystack| <= UINT64_MAX_LIMIT - 1 ==> forall i: int {:trigger haystack[i..]} | 0 <= i <= |haystack| - |needle| :: haystack[i..][..|needle|] != needle
      decreases haystack, needle
    {
      SequenceIsSafeBecauseItIsInMemory(haystack);
      SequenceIsSafeBecauseItIsInMemory(needle);
      if |haystack| as uint64 < |needle| as uint64 {
        return Wrappers.None;
      }
      var size: uint64 := |needle| as uint64;
      var limit: uint64 := Add(|haystack| as uint64 - size, 1);
      for index: BoundedInts.uint64 := 0 to limit
        invariant forall i: BoundedInts.uint64 {:trigger haystack[i..]} | 0 <= i < index :: haystack[i..][..size] != needle
      {
        if SequenceEqual(seq1 := haystack, seq2 := needle, start1 := index, start2 := 0, size := size) {
          return Wrappers.Some(index as nat);
        }
      }
      return Wrappers.None;
    }

    import Wrappers

    import opened UInt

    import opened Sequence

    import opened MemoryMath

    export
      provides Int2String, Base10Int2String, HasSubString, Wrappers, UInt

  }

  module Sequence {
    function method {:opaque} {:tailrecursion} MapWithResult<T, R, E>(f: T ~> Result<R, E>, xs: seq<T>, pos: uint64 := 0, acc: seq<R> := []): (result: Result<seq<R>, E>)
      requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
      requires pos as nat <= |xs|
      requires |acc| == pos as nat
      requires forall i: BoundedInts.uint64 {:trigger acc[i]} {:trigger xs[i]} :: (0 <= i < pos ==> f(xs[i]).Success?) && (0 <= i < pos ==> acc[i] == f(xs[i]).value)
      reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
      ensures result.Success? ==> |result.value| == |xs| && forall i: int {:trigger result.value[i]} {:trigger xs[i]} :: (0 <= i < |xs| ==> f(xs[i]).Success?) && (0 <= i < |xs| ==> result.value[i] == f(xs[i]).value)
      decreases |xs| - pos as nat
    {
      SequenceIsSafeBecauseItIsInMemory(xs);
      if |xs| as uint64 == pos then
        Success(acc)
      else
        var head: R :- f(xs[pos]); MapWithResult(f, xs, pos + 1, acc + [head])
    }

    function method {:tailrecursion} Flatten<T>(xs: seq<seq<T>>, pos: uint64 := 0, acc: seq<T> := []): (ret: seq<T>)
      requires pos as nat <= |xs|
      decreases |xs| - pos as nat
    {
      SequenceIsSafeBecauseItIsInMemory(xs);
      if |xs| as uint64 == pos then
        acc
      else
        Flatten(xs, pos + 1, acc + xs[pos])
    }

    predicate method SequenceEqualNat<T(==)>(seq1: seq<T>, seq2: seq<T>, start1: nat, start2: nat, size: nat): (ret: bool)
      requires start1 + size <= |seq1|
      requires start2 + size <= |seq2|
      ensures ret ==> seq1[start1 .. start1 + size] == seq2[start2 .. start2 + size]
      decreases seq1, seq2, start1, start2, size
    {
      SequenceIsSafeBecauseItIsInMemory(seq1);
      SequenceIsSafeBecauseItIsInMemory(seq2);
      SequenceEqual(seq1, seq2, start1 as uint64, start2 as uint64, size as uint64)
    }

    predicate SequenceEqual<T(==)>(seq1: seq64<T>, seq2: seq64<T>, start1: uint64, start2: uint64, size: uint64): (ret: bool)
      requires start1 as nat + size as nat <= |seq1|
      requires start2 as nat + size as nat <= |seq2|
      ensures ret <==> seq1[start1 .. start1 + size] == seq2[start2 .. start2 + size]
      decreases seq1, seq2, start1, start2, size
    {
      seq1[start1 .. start1 + size] == seq2[start2 .. start2 + size]
    } by method {
      var j: uint64 := start2;
      for i: uint64 := start1 to start1 + size
        invariant j == i - start1 + start2
        invariant forall k: uint64 {:trigger seq1[k]} | start1 <= k < i :: seq1[k] == seq2[k - start1 + start2]
      {
        if seq1[i] != seq2[j] {
          return false;
        }
        j := j + 1;
      }
      return true;
    }

    import opened UInt

    import opened Wrappers

    import opened MemoryMath
  }
}

module {:extern "UTF8"} UTF8 {
  function method {:extern "Encode"} Encode(s: string): (res: Result<ValidUTF8Bytes, string>)
    ensures IsASCIIString(s) ==> res.Success? && |res.value| == |s|
    ensures res.Success? ==> Decode(res.value).Success? && Decode(res.value).value == s
    decreases s

  function method {:extern "Decode"} Decode(b: seq<uint8>): (res: Result<string, string>)
    ensures res.Success? ==> ValidUTF8Seq(b)
    decreases b

  function method CreateEncodeSuccess(bytes: ValidUTF8Bytes): Result<ValidUTF8Bytes, string>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateEncodeFailure(error: string): Result<ValidUTF8Bytes, string>
    decreases error
  {
    Failure(error)
  }

  function method CreateDecodeSuccess(s: string): Result<string, string>
    decreases s
  {
    Success(s)
  }

  function method CreateDecodeFailure(error: string): Result<string, string>
    decreases error
  {
    Failure(error)
  }

  predicate method IsASCIIString(s: string)
    decreases s
  {
    forall i: int {:trigger s[i]} :: 
      0 <= i < |s| ==>
        s[i] as int < 128
  }

  function {:opaque} EncodeAscii(s: string): (ret: ValidUTF8Bytes)
    requires IsASCIIString(s)
    ensures |s| == |ret|
    ensures forall i: int {:trigger ret[i]} {:trigger s[i]} | 0 <= i < |s| :: s[i] as uint8 == ret[i]
    decreases s
  {
    if |s| == 0 then
      []
    else
      ghost var x: seq<BoundedInts.uint8> := [s[0] as uint8]; assert ValidUTF8Seq(x); ValidUTF8Concat(x, EncodeAscii(s[1..])); x + EncodeAscii(s[1..])
  }

  lemma /*{:_inductionTrigger EncodeAscii(y), EncodeAscii(x)}*/ /*{:_inductionTrigger EncodeAscii(y), IsASCIIString(x)}*/ /*{:_inductionTrigger EncodeAscii(x), IsASCIIString(y)}*/ /*{:_inductionTrigger IsASCIIString(y), IsASCIIString(x)}*/ /*{:_induction x, y}*/ EncodeAsciiUnique2(x: string, y: string)
    requires IsASCIIString(x) && IsASCIIString(y)
    requires x != y
    ensures EncodeAscii(x) != EncodeAscii(y)
    decreases x, y
  {
    reveal EncodeAscii();
    if EncodeAscii(x) == EncodeAscii(y) {
      if |EncodeAscii(x)| == 0 && |EncodeAscii(y)| == 0 {
      } else if EncodeAscii(x)[0] == EncodeAscii(y)[0] {
        assert EncodeAscii(x)[1..] != EncodeAscii(y)[1..] by {
          EncodeAsciiUnique2(x[1..], y[1..]);
        }
      } else {
      }
    }
  }

  lemma {:opaque} EncodeAsciiUnique()
    ensures forall x: string, y: string {:trigger EncodeAscii(y), EncodeAscii(x)} {:trigger EncodeAscii(y), IsASCIIString(x)} {:trigger EncodeAscii(x), IsASCIIString(y)} {:trigger IsASCIIString(y), IsASCIIString(x)} :: IsASCIIString(x) && IsASCIIString(y) && x != y ==> EncodeAscii(x) != EncodeAscii(y)
  {
    forall x: string, y: string | true
      ensures IsASCIIString(x) && IsASCIIString(y) && x != y ==> EncodeAscii(x) != EncodeAscii(y)
    {
      if IsASCIIString(x) && IsASCIIString(y) && x != y {
        EncodeAsciiUnique2(x, y);
      }
    }
  }

  predicate method Uses1Byte(s: seq<uint8>)
    requires |s| >= 1
    decreases s
  {
    0 <= s[0] <= 127
  }

  predicate method Uses2Bytes(s: seq<uint8>)
    requires |s| >= 2
    decreases s
  {
    194 <= s[0] <= 223 &&
    128 <= s[1] <= 191
  }

  predicate method Uses3Bytes(s: seq<uint8>)
    requires |s| >= 3
    decreases s
  {
    (s[0] == 224 && 160 <= s[1] <= 191 && 128 <= s[2] <= 191) || (225 <= s[0] <= 236 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191) || (s[0] == 237 && 128 <= s[1] <= 159 && 128 <= s[2] <= 191) || (238 <= s[0] <= 239 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191)
  }

  predicate method Uses4Bytes(s: seq<uint8>)
    requires |s| >= 4
    decreases s
  {
    (s[0] == 240 && 144 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (241 <= s[0] <= 243 && 128 <= s[1] <= 191 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191) || (s[0] == 244 && 128 <= s[1] <= 143 && 128 <= s[2] <= 191 && 128 <= s[3] <= 191)
  }

  predicate ValidUTF8Range(a: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |a|
    decreases hi - lo
  {
    if lo == hi then
      true
    else
      var r: seq<BoundedInts.uint8> := a[lo .. hi]; if Uses1Byte(r) then ValidUTF8Range(a, lo + 1, hi) else if 2 <= |r| && Uses2Bytes(r) then ValidUTF8Range(a, lo + 2, hi) else if 3 <= |r| && Uses3Bytes(r) then ValidUTF8Range(a, lo + 3, hi) else if 4 <= |r| && Uses4Bytes(r) then ValidUTF8Range(a, lo + 4, hi) else false
  } by method {
    if HasUint64Len(a) {
      return BoundedValidUTF8Range(a, lo as uint64, hi as uint64);
    }
    if lo == hi {
      assert ValidUTF8Range(a, lo, hi);
      return true;
    }
    var i := lo;
    while i < hi
      invariant lo <= i <= hi
      invariant ValidUTF8Range(a, lo, hi) == ValidUTF8Range(a, i, hi)
      decreases hi - i
    {
      if i < hi && 0 <= a[i] <= 127 {
        assert Uses1Byte(a[i .. hi]);
        i := i + 1;
      } else if i + 1 < hi && 194 <= a[i] <= 223 && 128 <= a[i + 1] <= 191 {
        assert Uses2Bytes(a[i .. hi]);
        i := i + 2;
      } else if i + 2 < hi && ((a[i] == 224 && 160 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191) || (225 <= a[i] <= 236 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191) || (a[i] == 237 && 128 <= a[i + 1] <= 159 && 128 <= a[i + 2] <= 191) || (238 <= a[i] <= 239 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191)) {
        assert Uses3Bytes(a[i .. hi]);
        i := i + 3;
      } else if i + 3 < hi && ((a[i] == 240 && 144 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191) || (241 <= a[i] <= 243 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191) || (a[i] == 244 && 128 <= a[i + 1] <= 143 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191)) {
        assert Uses4Bytes(a[i .. hi]);
        i := i + 4;
      } else {
        assert i < hi;
        return false;
      }
    }
    return true;
  }

  predicate BoundedValidUTF8Range(a: seq64<uint8>, lo: uint64, hi: uint64)
    requires lo <= hi <= |a| as uint64
    decreases hi - lo
  {
    ValidUTF8Range(a, lo as nat, hi as nat)
  } by method {
    if lo == hi {
      assert ValidUTF8Range(a, lo as nat, hi as nat);
      return true;
    }
    var i := lo;
    while i < hi
      invariant lo <= i <= hi
      invariant ValidUTF8Range(a, lo as nat, hi as nat) == ValidUTF8Range(a, i as nat, hi as nat)
      decreases hi - i
    {
      if i < hi && 0 <= a[i] <= 127 {
        assert Uses1Byte(a[i .. hi]);
        i := i + 1;
      } else if i < hi - 1 && 194 <= a[i] <= 223 && 128 <= a[i + 1] <= 191 {
        assert Uses2Bytes(a[i .. hi]);
        i := i + 2;
      } else if 2 <= hi && i < hi - 2 && ((a[i] == 224 && 160 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191) || (225 <= a[i] <= 236 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191) || (a[i] == 237 && 128 <= a[i + 1] <= 159 && 128 <= a[i + 2] <= 191) || (238 <= a[i] <= 239 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191)) {
        assert Uses3Bytes(a[i .. hi]);
        i := i + 3;
      } else if 3 <= hi && i < hi - 3 && ((a[i] == 240 && 144 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191) || (241 <= a[i] <= 243 && 128 <= a[i + 1] <= 191 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191) || (a[i] == 244 && 128 <= a[i + 1] <= 143 && 128 <= a[i + 2] <= 191 && 128 <= a[i + 3] <= 191)) {
        assert Uses4Bytes(a[i .. hi]);
        i := i + 4;
      } else {
        return false;
      }
    }
    return true;
  }

  lemma ValidUTF8Embed(a: seq<uint8>, b: seq<uint8>, c: seq<uint8>, lo: nat, hi: nat)
    requires lo <= hi <= |b|
    ensures ValidUTF8Range(b, lo, hi) == ValidUTF8Range(a + b + c, |a| + lo, |a| + hi)
    decreases hi - lo
  {
    if lo == hi {
    } else {
      ghost var r := b[lo .. hi];
      ghost var r' := (a + b + c)[|a| + lo .. |a| + hi];
      assert r == r';
      if Uses1Byte(r) {
        ValidUTF8Embed(a, b, c, lo + 1, hi);
      } else if 2 <= |r| && Uses2Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 2, hi);
      } else if 3 <= |r| && Uses3Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 3, hi);
      } else if 4 <= |r| && Uses4Bytes(r) {
        ValidUTF8Embed(a, b, c, lo + 4, hi);
      }
    }
  }

  predicate method ValidUTF8Seq(s: seq<uint8>)
    decreases s
  {
    ValidUTF8Range(s, 0, |s|)
  }

  lemma {:vcs_split_on_every_assert} ValidUTF8Concat(s: seq<uint8>, t: seq<uint8>)
    requires ValidUTF8Seq(s) && ValidUTF8Seq(t)
    ensures ValidUTF8Seq(s + t)
    decreases s, t
  {
    ghost var lo := 0;
    while lo < |s|
      invariant lo <= |s|
      invariant ValidUTF8Range(s, lo, |s|)
      invariant ValidUTF8Range(s + t, 0, |s + t|) ==> ValidUTF8Range(s + t, lo, |s + t|)
      invariant ValidUTF8Range(s + t, lo, |s + t|) ==> ValidUTF8Range(s + t, 0, |s + t|)
      decreases |s| - lo
    {
      ghost var r := (s + t)[lo..];
      if Uses1Byte(r) {
        lo := lo + 1;
      } else if 2 <= |r| && Uses2Bytes(r) {
        lo := lo + 2;
      } else if 3 <= |r| && Uses3Bytes(r) {
        lo := lo + 3;
      } else if 4 <= |r| && Uses4Bytes(r) {
        lo := lo + 4;
      }
    }
    assert ValidUTF8Seq(s + t) by {
      ValidUTF8Embed(s, t, [], 0, |t|);
      assert s + t == s + t + [] && lo == |s|;
    }
  }

  lemma IsASCIIBytesIsValidUTF8(s: seq<uint8>)
    requires forall i: int {:trigger s[i]} | 0 <= i < |s| :: Uses1Byte([s[i]])
    ensures ValidUTF8Seq(s)
    decreases s
  {
    if |s| == 0 {
    } else {
      IsASCIIBytesIsValidUTF8(s[1..]);
      assert ValidUTF8Seq(s[..1]);
      ValidUTF8Concat(s[..1], s[1..]);
      assert s[..1] + s[1..] == s;
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  type ValidUTF8Bytes = i: seq<uint8>
    | ValidUTF8Seq(i)
    witness []
}

module {:extern "Time"} Time {
  method {:extern "CurrentRelativeTime"} GetCurrent() returns (res: int64)
    ensures res >= 0

  method {:extern "CurrentRelativeTimeMilli"} GetCurrentMilli() returns (res: int64)
    ensures res >= 0

  method {:extern "GetProcessCpuTimeMillis"} GetProcessCpuTimeMillis() returns (res: int64)
    ensures res >= 0

  method {:extern "GetCurrentTimeStamp"} GetCurrentTimeStamp() returns (res: Result<string, string>)

  function method FormatMilli(diff: uint64): string
    decreases diff
  {
    var whole: string := String.Base10Int2String((diff / 1000) as int);
    var frac: string := String.Base10Int2String((diff % 1000) as int);
    if |frac| == 1 then
      whole + ".00" + frac
    else if |frac| == 2 then
      whole + ".0" + frac
    else
      whole + "." + frac
  }

  function method FormatMilliDiff(start: int64, end: int64): string
    requires start >= 0
    requires end >= 0
    decreases start, end
  {
    if start <= end then
      FormatMilli((end - start) as uint64)
    else
      "-" + FormatMilli((start - end) as uint64)
  }

  method GetAbsoluteTime() returns (output: AbsoluteTime)
  {
    var ClockTime := GetCurrentMilli();
    var CpuTime := GetProcessCpuTimeMillis();
    return AbsoluteTime(ClockTime := ClockTime as uint64, CpuTime := CpuTime as uint64);
  }

  method PrintTimeSince(start: AbsoluteTime)
    decreases start
  {
    var t := TimeSince(start);
    PrintTime(t);
  }

  method PrintTimeSinceShort(start: AbsoluteTime)
    decreases start
  {
    var t := TimeSince(start);
    PrintTimeShort(t);
  }

  method PrintTimeSinceShortChained(start: AbsoluteTime) returns (x: AbsoluteTime)
    decreases start
  {
    var end := GetAbsoluteTime();
    PrintTimeShort(TimeDiff(start, end));
    return end;
  }

  function method TimeDiff(start: AbsoluteTime, end: AbsoluteTime): RelativeTime
    decreases start, end
  {
    if start.ClockTime <= end.ClockTime && start.CpuTime <= end.CpuTime then
      RelativeTime(ClockTime := end.ClockTime - start.ClockTime, CpuTime := end.CpuTime - start.CpuTime)
    else
      RelativeTime(ClockTime := 0, CpuTime := 0)
  }

  method TimeSince(start: AbsoluteTime) returns (output: RelativeTime)
    decreases start
  {
    var end := GetAbsoluteTime();
    output := TimeDiff(start, end);
  }

  method PrintTime(time: RelativeTime)
    decreases time
  {
    print "Clock Time : ", FormatMilli(time.ClockTime), " CPU Time : ", FormatMilli(time.CpuTime), "\n";
  }

  method PrintTimeSinceLong(start: AbsoluteTime, tag: string, file: Option<string> := None)
    decreases start, tag, file
  {
    var t := TimeSince(start);
    PrintTimeLong(t, tag, file);
  }

  method PrintTimeLong(time: RelativeTime, tag: string, file: Option<string> := None)
    decreases time, tag, file
  {
    var val := tag + " " + OsLang.GetOsShort() + " " + OsLang.GetLanguageShort() + " " + FormatMilli(time.ClockTime) + " " + FormatMilli(time.CpuTime) + "\n";
    print val;
    if file.Some? {
      var utf8_val := UTF8.Encode(val);
      if utf8_val.Success? {
        var _ /* _v0 */ := FileIO.AppendBytesToFile(file.value, utf8_val.value);
      }
    }
  }

  method PrintTimeShort(time: RelativeTime)
    decreases time
  {
    print "CPU:", FormatMilli(time.CpuTime), " ";
  }

  function method CreateGetCurrentTimeStampSuccess(value: string): Result<string, string>
    decreases value
  {
    Success(value)
  }

  function method CreateGetCurrentTimeStampFailure(error: string): Result<string, string>
    decreases error
  {
    Failure(error)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import String = StandardLibrary.String

  import OsLang

  import UTF8

  import FileIO

  datatype AbsoluteTime = AbsoluteTime(ClockTime: uint64, CpuTime: uint64)

  datatype RelativeTime = RelativeTime(ClockTime: uint64, CpuTime: uint64)
}

module {:extern "OsLang"} OsLang {
  function method {:extern} GetOsShort(): string

  function method {:extern} GetLanguageShort(): string

  function method {:extern} GetOsLong(): string

  function method {:extern} GetLanguageLong(): string

  function method GetPlatformShort(): string
  {
    GetLanguageShort() + " " + GetOsShort()
  }

  function method GetPlatformLong(): string
  {
    GetLanguageLong() + " " + GetOsLong()
  }
}

module Streams {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath
  class SeqReader<T> {
    ghost var Repr: set<object>
    const data: seq<T>
    var pos: uint64

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      SequenceIsSafeBecauseItIsInMemory(data);
      this in Repr &&
      pos <= |data| as uint64
    }

    constructor (s: seq<T>)
      ensures pos == 0
      ensures data[..] == s
      ensures Valid() && fresh(Repr)
      decreases s
    {
      data := s;
      pos := 0;
      Repr := {this};
    }

    method ReadElements(n: uint64) returns (elems: seq<T>)
      requires Valid()
      requires n as nat + pos as nat <= |data|
      modifies `pos
      ensures n == 0 ==> elems == []
      ensures n > 0 ==> elems == data[old(pos)..][..n]
      ensures pos == Add(old(pos), n)
      ensures Valid()
      decreases n
    {
      elems := data[pos..][..n];
      pos := Add(pos, n);
      return elems;
    }

    method ReadExact(n: uint64) returns (res: Result<seq<T>, string>)
      requires Valid()
      modifies `pos
      ensures n as nat + old(pos) as nat <= |data| <==> res.Success?
      ensures res.Success? ==> |res.value| == n as nat
      ensures res.Success? ==> pos == Add(old(pos), n)
      ensures res.Success? ==> res.value == data[old(pos) .. old(pos) + n]
      ensures res.Failure? ==> n as nat > |data| - pos as nat
      ensures res.Failure? ==> pos == old(pos)
      ensures Valid()
      decreases n
    {
      SequenceIsSafeBecauseItIsInMemory(data);
      if n > |data| as uint64 - pos {
        return Failure("IO Error: Not enough elements left on stream.");
      } else {
        var elements := ReadElements(n);
        return Success(elements);
      }
    }
  }

  class ByteReader {
    ghost var Repr: set<object>
    const reader: SeqReader<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      reader in Repr &&
      reader.Repr <= Repr &&
      this !in reader.Repr &&
      reader.Valid()
    }

    constructor (s: seq<uint8>)
      ensures reader.data == s
      ensures reader.pos == 0
      ensures Valid() && fresh(Repr)
      decreases s
    {
      var mr := new SeqReader<uint8>(s);
      reader := mr;
      Repr := {this} + mr.Repr;
    }

    method ReadByte() returns (res: Result<uint8, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos as nat < 1
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == Add(old(reader.pos), 1)
      ensures old(reader.pos) as nat + 1 <= |reader.data| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos)]
      ensures Valid()
    {
      var bytes :- reader.ReadExact(1);
      assert |bytes| == 1;
      return Success(bytes[0]);
    }

    method ReadBytes(n: uint64) returns (res: Result<seq<uint8>, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos as nat < n as nat
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> |res.value| == n as nat
      ensures res.Success? && |res.value| == 0 ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == Add(old(reader.pos), n)
      ensures old(reader.pos) as nat + n as nat <= |reader.data| <==> res.Success?
      ensures res.Success? ==> res.value == reader.data[old(reader.pos) .. old(reader.pos) + n]
      ensures Valid()
      decreases n
    {
      var bytes :- reader.ReadExact(n);
      SequenceIsSafeBecauseItIsInMemory(bytes);
      assert |bytes| as uint64 == n;
      return Success(bytes);
    }

    method ReadUInt16() returns (res: Result<uint16, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos as nat < 2
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == Add(old(reader.pos), 2)
      ensures old(reader.pos) as nat + 2 <= |reader.data| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt16(reader.data[old(reader.pos) .. old(reader.pos) + 2])
      ensures Valid()
    {
      var bytes :- reader.ReadExact(2);
      assert |bytes| == 2;
      var n := SeqToUInt16(bytes);
      return Success(n);
    }

    method ReadUInt32() returns (res: Result<uint32, string>)
      requires Valid()
      modifies reader`pos
      ensures Valid()
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == Add(old(reader.pos), 4) && UInt32ToSeq(res.value) == reader.data[old(reader.pos) .. reader.pos]
    {
      var bytes :- reader.ReadExact(4);
      assert |bytes| == 4;
      var n := SeqToUInt32(bytes);
      UInt32SeqDeserializeSerialize(bytes);
      return Success(n);
    }

    method ReadUInt64() returns (res: Result<uint64, string>)
      requires Valid()
      modifies reader`pos
      ensures res.Failure? ==> |reader.data| - reader.pos as nat < 8
      ensures res.Failure? ==> unchanged(reader)
      ensures res.Success? ==> reader.pos == Add(old(reader.pos), 8)
      ensures old(reader.pos) as nat + 8 <= |reader.data| <==> res.Success?
      ensures res.Success? ==> res.value == SeqToUInt64(reader.data[old(reader.pos) .. old(reader.pos) + 8])
      ensures Valid()
    {
      var bytes :- reader.ReadExact(8);
      assert |bytes| == 8;
      var n := SeqToUInt64(bytes);
      return Success(n);
    }

    method IsDoneReading() returns (b: bool)
      requires Valid()
      ensures (b && |reader.data| - reader.pos as nat == 0) || (!b && |reader.data| - reader.pos as nat > 0)
      ensures Valid()
    {
      SequenceIsSafeBecauseItIsInMemory(reader.data);
      return |reader.data| as uint64 == reader.pos;
    }

    method GetSizeRead() returns (n: uint64)
      requires Valid()
      ensures n == reader.pos
      ensures Valid()
    {
      return reader.pos;
    }
  }

  class SeqWriter<T> {
    ghost var Repr: set<object>
    var data: seq<T>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr
    }

    constructor ()
      ensures data == []
      ensures Valid() && fresh(Repr)
    {
      data := [];
      Repr := {this};
    }

    method WriteElements(elems: seq<T>) returns (n: uint64)
      requires Valid()
      modifies `data
      ensures n as nat == |data| - |old(data)| == |elems|
      ensures |elems| == 0 ==> data == old(data)
      ensures |elems| > 0 ==> data == old(data) + elems
      ensures elems == data[|data| - |elems|..]
      ensures Valid()
      decreases elems
    {
      SequenceIsSafeBecauseItIsInMemory(elems);
      data := data + elems;
      return |elems| as uint64;
    }
  }

  class ByteWriter {
    ghost var Repr: set<object>
    const writer: SeqWriter<uint8>

    predicate Valid()
      reads this, Repr
      ensures Valid() ==> this in Repr
      decreases Repr + {this}
    {
      this in Repr &&
      writer in Repr &&
      writer.Repr <= Repr &&
      this !in writer.Repr &&
      writer.Valid()
    }

    constructor ()
      ensures writer.data == []
      ensures Valid() && fresh(Repr)
    {
      var mw := new SeqWriter<uint8>();
      writer := mw;
      Repr := {this} + mw.Repr;
    }

    method WriteByte(n: uint8) returns (r: uint64)
      requires Valid()
      modifies writer`data
      ensures writer.data == old(writer.data) + [n]
      ensures r == 1
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements([n]);
    }

    method WriteBytes(s: seq<uint8>) returns (r: uint64)
      requires Valid()
      modifies writer`data
      ensures writer.data == old(writer.data) + s
      ensures r as nat == |s|
      ensures Valid()
      decreases s
    {
      r := writer.WriteElements(s);
    }

    method WriteUInt16(n: uint16) returns (r: uint64)
      requires Valid()
      modifies writer`data
      ensures writer.data == old(writer.data) + UInt16ToSeq(n)
      ensures r == 2
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt16ToSeq(n));
    }

    method WriteUInt32(n: uint32) returns (r: uint64)
      requires Valid()
      modifies writer`data
      ensures writer.data == old(writer.data) + UInt32ToSeq(n)
      ensures r == 4
      ensures Valid()
      decreases n
    {
      r := writer.WriteElements(UInt32ToSeq(n));
    }

    function method GetDataWritten(): (s: seq<uint8>)
      requires Valid()
      reads Repr
      ensures s == writer.data
      ensures Valid()
      decreases Repr
    {
      writer.data
    }

    function method GetSizeWritten(): (n: uint64)
      requires Valid()
      reads Repr
      ensures n as nat == |writer.data|
      ensures Valid()
      decreases Repr
    {
      SequenceIsSafeBecauseItIsInMemory(writer.data);
      |writer.data| as uint64
    }
  }
}

module Sorting {
  predicate Reflexive<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T {:trigger R(x, x)} :: 
      R(x, x)
  }

  predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      R(x, y) &&
      R(y, x) ==>
        x == y
  }

  predicate Connected<T(!new)>(R: (T, T) -> bool)
  {
    forall x: T, y: T {:trigger R(y, x)} {:trigger R(x, y)} :: 
      R(x, y) || R(y, x)
  }

  predicate TotalOrdering<T(!new)>(R: (T, T) -> bool)
  {
    Reflexive(R) &&
    AntiSymmetric(R) &&
    StandardLibrary.Transitive(R) &&
    Connected(R)
  }

  predicate method LexicographicByteSeqBelow(x: seq<uint8>, y: seq<uint8>)
    decreases x, y
  {
    LexicographicByteSeqBelowAux(x, y, 0)
  }

  predicate method LexicographicByteSeqBelowAux(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    decreases |x| - n
  {
    n == |x| || (n != |y| && x[n] < y[n]) || (n != |y| && x[n] == y[n] && LexicographicByteSeqBelowAux(x, y, n + 1))
  }

  lemma AboutLexicographicByteSeqBelow()
    ensures TotalOrdering(LexicographicByteSeqBelow)
  {
    assert Reflexive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, n: int | 0 <= n <= |x| {
        AboutLexicographicByteSeqBelowAux_Reflexive(x, n);
      }
    }
    assert AntiSymmetric(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| && x[..n] == y[..n] && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n) {
        AboutLexicographicByteSeqBelowAux_AntiSymmetric(x, y, n);
      }
    }
    assert StandardLibrary.Transitive(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat | n <= |x| && n <= |y| && n <= |z| && LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n) {
        AboutLexicographicByteSeqBelowAux_Transitive(x, y, z, n);
      }
    }
    assert Connected(LexicographicByteSeqBelow) by {
      forall x: seq<uint8>, y: seq<uint8>, n: nat | n <= |x| && n <= |y| {
        AboutLexicographicByteSeqBelowAux_Connected(x, y, n);
      }
    }
  }

  lemma /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, x, n)}*/ /*{:_induction x, n}*/ AboutLexicographicByteSeqBelowAux_Reflexive(x: seq<uint8>, n: nat)
    requires n <= |x|
    ensures LexicographicByteSeqBelowAux(x, x, n)
    decreases |x| - n
  {
  }

  lemma /*{:_inductionTrigger LexicographicByteSeqBelowAux(y, x, n)}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, y, n)}*/ /*{:_inductionTrigger y[..n], x[..n]}*/ /*{:_inductionTrigger y[..n], |x|}*/ /*{:_inductionTrigger x[..n], |y|}*/ /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_AntiSymmetric(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    requires x[..n] == y[..n]
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, x, n)
    ensures x == y
    decreases |x| - n
  {
  }

  lemma /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, z, n), LexicographicByteSeqBelowAux(y, z, n)}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, z, n), |y|}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(y, z, n), LexicographicByteSeqBelowAux(x, y, n)}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(y, z, n), |x|}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, y, n), |z|}*/ /*{:_induction x, y, z, n}*/ AboutLexicographicByteSeqBelowAux_Transitive(x: seq<uint8>, y: seq<uint8>, z: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y| && n <= |z|
    requires LexicographicByteSeqBelowAux(x, y, n) && LexicographicByteSeqBelowAux(y, z, n)
    ensures LexicographicByteSeqBelowAux(x, z, n)
    decreases |x| - n
  {
  }

  lemma /*{:_inductionTrigger LexicographicByteSeqBelowAux(y, x, n)}*/ /*{:_inductionTrigger LexicographicByteSeqBelowAux(x, y, n)}*/ /*{:_induction x, y, n}*/ AboutLexicographicByteSeqBelowAux_Connected(x: seq<uint8>, y: seq<uint8>, n: nat)
    requires n <= |x| && n <= |y|
    ensures LexicographicByteSeqBelowAux(x, y, n) || LexicographicByteSeqBelowAux(y, x, n)
    decreases |x| - n
  {
  }

  method {:vcs_split_on_every_assert} SelectionSort<Data(!new)>(a: array<Data>, below: (Data, Data) -> bool)
    requires StandardLibrary.Transitive(below)
    requires Connected(below)
    modifies a
    ensures multiset(a[..]) == old(multiset(a[..]))
    ensures forall i: int, j: int {:trigger a[j], a[i]} :: 0 <= i < j < a.Length ==> below(a[i], a[j])
    decreases a
  {
    var m := 0;
    while m < a.Length
      invariant 0 <= m <= a.Length
      invariant multiset(a[..]) == old(multiset(a[..]))
      invariant forall i: int, j: int {:trigger a[j], a[i]} :: 0 <= i < j < m ==> below(a[i], a[j])
      invariant forall i: int, j: int {:trigger a[j], a[i]} :: 0 <= i < m <= j < a.Length ==> below(a[i], a[j])
      decreases a.Length - m
    {
      var mindex, n := m, m + 1;
      while n < a.Length
        invariant m <= mindex < n <= a.Length
        invariant forall i: int {:trigger a[i]} :: m <= i < n ==> below(a[mindex], a[i])
        decreases a.Length - n
      {
        if !below(a[mindex], a[n]) {
          mindex := n;
        }
        n := n + 1;
      }
      a[m], a[mindex] := a[mindex], a[m];
      m := m + 1;
    }
  }

  export
    reveals Reflexive, AntiSymmetric, Connected, TotalOrdering, LexicographicByteSeqBelow, LexicographicByteSeqBelowAux
    provides AboutLexicographicByteSeqBelow, SelectionSort, StandardLibrary, UInt


  import StandardLibrary

  import opened UInt = StandardLibrary.UInt
}

module {:extern "SortedSets"} SortedSets {
  method {:extern "SetToOrderedSequence"} {:axiom} ComputeSetToOrderedSequence<T(==,!new)>(s: set<seq<T>>, less: (T, T) -> bool) returns (res: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures res == SetToOrderedSequence(s, less)
    decreases s

  function method {:extern "SetToOrderedSequence2"} {:axiom} ComputeSetToOrderedSequence2<T(==,!new)>(s: set<seq<T>>, less: (T, T) -> bool): (res: seq<seq<T>>)
    requires Trichotomous(less) && Transitive(less)
    ensures res == SetToOrderedSequence(s, less)
    ensures Seq.HasNoDuplicates(res)
    ensures forall k: seq<T> {:trigger k in s} {:trigger k in res} | k in res :: k in s
    ensures forall k: seq<T> {:trigger k in res} {:trigger k in s} | k in s :: k in res
    ensures |res| == |s|
    decreases s

  method {:extern "SetToSequence"} {:axiom} ComputeSetToSequence<T(==,!new)>(s: set<T>) returns (res: seq<T>)
    ensures Seq.HasNoDuplicates(res)
    ensures forall k: T {:trigger k in s} {:trigger k in res} | k in res :: k in s
    ensures forall k: T {:trigger k in res} {:trigger k in s} | k in s :: k in res
    ensures |res| == |s|
    decreases s

  import opened StandardLibrary

  import Seq
}

module HexStrings {
  function method HexChar(x: uint8): (res: char)
    requires x < 16
    ensures '0' <= res <= '9' || 'a' <= res <= 'f'
    ensures IsHexChar(res)
    decreases x
  {
    if x < 10 then
      '0' + x as char
    else
      'a' + (x - 10) as char
  }

  predicate method IsLooseHexChar(ch: char)
    decreases ch
  {
    '0' <= ch <= '9' || 'a' <= ch <= 'f' || 'A' <= ch <= 'F'
  }

  predicate method IsHexChar(ch: char)
    decreases ch
  {
    '0' <= ch <= '9' || 'a' <= ch <= 'f'
  }

  lemma PlainIsLooseChar(ch: char)
    requires IsHexChar(ch)
    ensures IsLooseHexChar(ch)
    decreases ch
  {
  }

  lemma PlainIsLooseString(s: string)
    requires IsHexString(s)
    ensures IsLooseHexString(s)
    decreases s
  {
  }

  predicate method IsHexString(s: string)
    decreases s
  {
    forall ch: char {:trigger IsHexChar(ch)} {:trigger ch in s} | ch in s :: 
      IsHexChar(ch)
  }

  predicate method IsLooseHexString(s: string)
    decreases s
  {
    forall ch: char {:trigger IsLooseHexChar(ch)} {:trigger ch in s} | ch in s :: 
      IsLooseHexChar(ch)
  }

  function method HexVal(ch: char): (res: uint8)
    requires IsLooseHexChar(ch)
    ensures 0 <= res < 16
    decreases ch
  {
    if '0' <= ch <= '9' then
      ch as uint8 - '0' as uint8
    else if 'a' <= ch <= 'f' then
      ch as uint8 - 'a' as uint8 + 10
    else
      assert 'A' <= ch <= 'F'; ch as uint8 - 'A' as uint8 + 10
  }

  lemma HexCharRoundTrip(ch: char)
    requires IsHexChar(ch)
    ensures HexChar(HexVal(ch)) == ch
    decreases ch
  {
  }

  lemma HexValRoundTrip(x: uint8)
    requires x < 16
    ensures HexVal(HexChar(x)) == x
    decreases x
  {
  }

  function method HexStr(x: uint8): (ret: string)
    ensures |ret| == 2
    decreases x
  {
    if x < 16 then
      var res: seq<char> := ['0', HexChar(x)];
      res
    else
      var res: seq<char> := [HexChar((x / 16) as uint8), HexChar((x % 16) as uint8)]; res
  }

  function method HexValue(x: string): (ret: uint8)
    requires |x| == 2
    requires IsLooseHexChar(x[0]) && IsLooseHexChar(x[1])
    decreases x
  {
    HexVal(x[0]) * 16 + HexVal(x[1])
  }

  lemma HexValueRoundTrip(x: uint8)
    ensures HexValue(HexStr(x)) == x
    decreases x
  {
  }

  lemma HexStrRoundTrip(x: string)
    requires |x| == 2
    requires IsHexChar(x[0]) && IsHexChar(x[1])
    ensures HexStr(HexValue(x)) == x
    decreases x
  {
  }

  function method {:tailrecursion} ToHexString(val: seq<uint8>): (ret: HexString)
    ensures |ret| == 2 * |val|
    decreases val
  {
    if |val| == 0 then
      []
    else
      HexStr(val[0]) + ToHexString(val[1..])
  }

  function method FromHexString(data: LooseHexString): (ret: seq<uint8>)
    ensures |ret| == (|data| + 1) / 2
    decreases data
  {
    if |data| == 0 then
      []
    else if |data| % 2 == 1 then
      [HexVal(data[0])] + FromHexString(data[1..])
    else
      [HexValue(data[..2])] + FromHexString(data[2..])
  }

  lemma {:vcs_split_on_every_assert} /*{:_inductionTrigger FromHexString(s)}*/ /*{:_inductionTrigger |s|}*/ /*{:_inductionTrigger IsHexString(s)}*/ /*{:_induction s}*/ ToHexStringRoundTrip(s: string)
    requires IsHexString(s)
    requires |s| % 2 == 0
    ensures ToHexString(FromHexString(s)) == s
    decreases s
  {
    if |s| == 0 {
      assert ToHexString(FromHexString(s)) == s;
    } else if |s| == 2 {
      HexStrRoundTrip(s);
      assert FromHexString(s) == [HexValue(s[..2])];
      assert ToHexString(FromHexString(s)) == s;
    } else {
      HexStrRoundTrip(s[..2]);
      assert FromHexString(s[..2]) == [HexValue(s[..2])];
      assert ToHexString(FromHexString(s)) == s;
    }
  }

  lemma /*{:_inductionTrigger ToHexString(x)}*/ /*{:_induction x}*/ FromHexStringRoundTrip(x: seq<uint8>)
    ensures FromHexString(ToHexString(x)) == x
    decreases x
  {
  }

  lemma EmptyHexStrings()
    ensures ToHexString([]) == ""
    ensures FromHexString("") == []
  {
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  type HexString = x: string
    | IsHexString(x)

  type LooseHexString = x: string
    | IsLooseHexString(x)
}

module {:options "-functionSyntax:4"} GetOpt {
  method Example(args: seq<string>) returns (output: Result<bool, string>)
    requires 0 < |args|
    decreases args
  {
    var MyOptions := [Param.Flag("foo", "Does foo things"), Param.Opt("two", "Does bar things to thingy", short := 't', argName := "thingy"), Param.Command(Options("command", "Does command stuff", [Param.Opt("two", "Does bar things to thingy", short := 't', argName := "thingy"), Param.Flag("foo", "Does foo things")]))];
    var opts := Options("myProg", "does prog stuff", MyOptions);
    var x :- GetOptions(opts, args);
    var h := NeedsHelp(opts, x);
    if h.Some? {
      print h.value;
      return Success(true);
    }
    return Success(true);
  }

  function method {:opaque} Filter<T>(f: T ~> bool, xs: seq<T>): (result: seq<T>)
    requires forall i: int {:trigger xs[i]} :: 0 <= i < |xs| ==> f.requires(xs[i])
    reads set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o
    ensures |result| <= |xs|
    ensures forall i: nat {:trigger result[i]} :: i < |result| && f.requires(result[i]) ==> f(result[i])
    decreases set i: int, o: object? {:trigger o in f.reads(xs[i])} | 0 <= i < |xs| && o in f.reads(xs[i]) :: o, xs
  {
    if |xs| == 0 then
      []
    else
      (if f(xs[0]) then [xs[0]] else []) + Filter(f, xs[1..])
  }

  const NullChar: char := 0 as char

  predicate method IsHelp(args: Parsed)
    decreases args
  {
    |args.params| != 0 &&
    args.params[0].name == HELP_STR
  }

  function method {:tailrecursion} NeedsHelp(opts: Options, args: Parsed, prefix: string := ""): Option<string>
    decreases opts, args, prefix
  {
    if IsHelp(args) then
      Some(GetHelp(opts, prefix))
    else if args.subcommand.Some? then
      var pos: nat :- GetSubOptions(opts.params, args.subcommand.value.command); NeedsHelp(opts.params[pos].options, args.subcommand.value, prefix + args.command + " ")
    else
      None
  }

  const HELP_STR: string := "help"
  const HELP_PARAM: Param := Param.Flag(HELP_STR, "This help text.", solo := true, inherit := true)

  function method GetHelp(opts: Options, prefix: string := ""): string
    decreases opts, prefix
  {
    var newOpts: seq<Param> := opts.params + [HELP_PARAM];
    var longLen: nat := GetLongLen(newOpts, 6);
    var commandLen: nat := GetCommandLen(newOpts);
    if commandLen == 0 then
      "USAGE : " + prefix + opts.name + " [args...]\n" + opts.help + "\n" + GetHelp2(newOpts, longLen)
    else
      "USAGE : " + opts.name + " [args...] command [args...]\n" + opts.help + "\n" + "\nAvailable Commands:\n" + GetCmdHelp(newOpts, commandLen) + "\nAvailable Options:\n" + GetHelp2(newOpts, longLen)
  }

  function method OptValue(args: seq<OneArg>, arg: string): Option<string>
    decreases args, arg
  {
    if |args| == 0 then
      None
    else if args[0].name == arg then
      args[0].value
    else
      OptValue(args[1..], arg)
  }

  function method {:tailrecursion} FlagCount(args: seq<OneArg>, arg: string): nat
    decreases args, arg
  {
    if |args| == 0 then
      0
    else if args[0].name == arg then
      1 + FlagCount(args[1..], arg)
    else
      FlagCount(args[1..], arg)
  }

  function method {:tailrecursion} OptMapLast(args: seq<OneArg>, theMap: map<string, string> := map[]): map<string, string>
    decreases args, theMap
  {
    if |args| == 0 then
      theMap
    else if args[0].value.Some? then
      OptMapLast(args[1..], theMap[args[0].name := args[0].value.value])
    else
      OptMapLast(args[1..], theMap)
  }

  function method {:tailrecursion} FlagsSet(args: seq<OneArg>, theSet: set<string> := {}): set<string>
    decreases args, theSet
  {
    if |args| == 0 then
      theSet
    else if args[0].value.Some? then
      FlagsSet(args[1..], theSet)
    else
      FlagsSet(args[1..], theSet + {args[0].name})
  }

  function method {:tailrecursion} OptMapList(args: seq<OneArg>, theMap: map<string, seq<string>> := map[]): (ret: map<string, seq<string>>)
    requires forall k: seq<char> {:trigger theMap[k]} {:trigger k in theMap} | k in theMap :: 0 < |theMap[k]|
    ensures forall k: seq<char> {:trigger ret[k]} {:trigger k in ret} | k in ret :: 0 < |ret[k]|
    decreases args, theMap
  {
    if |args| == 0 then
      theMap
    else if args[0].value.Some? then
      if args[0].name in theMap then
        OptMapList(args[1..], theMap[args[0].name := theMap[args[0].name] + [args[0].value.value]])
      else
        OptMapList(args[1..], theMap[args[0].name := [args[0].value.value]])
    else
      OptMapList(args[1..], theMap)
  }

  function method {:tailrecursion} FlagMapCount(args: seq<OneArg>, theMap: map<string, nat> := map[]): (ret: map<string, nat>)
    requires forall k: seq<char> {:trigger theMap[k]} {:trigger k in theMap} | k in theMap :: 0 < theMap[k]
    ensures forall k: seq<char> {:trigger ret[k]} {:trigger k in ret} | k in ret :: 0 < ret[k]
    decreases args, theMap
  {
    if |args| == 0 then
      theMap
    else if args[0].value.Some? then
      FlagMapCount(args[1..], theMap)
    else if args[0].name in theMap then
      FlagMapCount(args[1..], theMap[args[0].name := theMap[args[0].name] + 1])
    else
      FlagMapCount(args[1..], theMap[args[0].name := 1])
  }

  function method {:tailrecursion} FlagSetCheck(args: seq<OneArg>, theSet: set<string> := {}): Result<set<string>, string>
    decreases args, theSet
  {
    if |args| == 0 then
      Success(theSet)
    else if args[0].value.Some? then
      if args[0].name in theSet then
        Failure("Duplicate arg : " + args[0].name)
      else
        FlagSetCheck(args[1..], theSet + {args[0].name})
    else
      FlagSetCheck(args[1..], theSet)
  }

  function method {:tailrecursion} OptMapCheck(args: seq<OneArg>, theMap: map<string, string> := map[]): Result<map<string, string>, string>
    decreases args, theMap
  {
    if |args| == 0 then
      Success(theMap)
    else if args[0].value.Some? then
      if args[0].name in theMap then
        Failure("Duplicate arg : " + args[0].name)
      else
        OptMapCheck(args[1..], theMap[args[0].name := args[0].value.value])
    else
      OptMapCheck(args[1..], theMap)
  }

  function method GetHelpHelp(opt: Param): string
    decreases opt
  {
    if opt.Command? then
      ""
    else if opt.Flag? then
      opt.help
    else
      opt.help + if opt.Required() then " (required)" else if opt.HasDefault() then " (default : " + opt.unused.val + ")" else ""
  }

  function method OneHelp(opt: Param, longLen: nat): string
    decreases opt, longLen
  {
    if opt.Command? || !opt.ShowHelp() then
      ""
    else
      GetShortHelp(opt) + "  " + GetLongHelp(opt, longLen) + "  " + GetHelpHelp(opt) + "\n"
  }

  function method GetCommandHelp(opt: Param, commandLen: nat): string
    requires opt.Command?
    decreases opt, commandLen
  {
    var name: seq<char> := if |opt.options.name| < commandLen then opt.options.name + seq(commandLen - |opt.options.name|, (i: int) => ' ') else opt.options.name;
    name + "  " + opt.options.help + "\n"
  }

  function method GetShortHelp(opt: Param): (output: string)
    decreases opt
  {
    if opt.Opt? || opt.Flag? then
      if opt.short != NullChar then
        "-" + [opt.short]
      else
        "  "
    else
      ""
  }

  function method GetLongHelp(opt: Param, longLen: nat): string
    decreases opt, longLen
  {
    if opt.Opt? || opt.Flag? then
      var tmp: seq<char> := "--" + opt.name + if opt.Opt? then "=" + opt.argName else "";
      if |tmp| < longLen then
        tmp + seq(longLen - |tmp|, (i: int) => ' ')
      else
        tmp
    else
      ""
  }

  function method GetHelp2(opts: seq<Param>, longLen: nat): string
    decreases opts, longLen
  {
    if |opts| == 0 then
      ""
    else
      var x: string := OneHelp(opts[0], longLen); x + GetHelp2(opts[1..], longLen)
  }

  function method GetCmdHelp(opts: seq<Param>, commandLen: nat): string
    decreases opts, commandLen
  {
    if |opts| == 0 then
      ""
    else
      var x: seq<char> := if opts[0].Command? then GetCommandHelp(opts[0], commandLen) else ""; x + GetCmdHelp(opts[1..], commandLen)
  }

  function method GetLongLen(opts: seq<Param>, max: nat := 0): nat
    decreases opts, max
  {
    if |opts| == 0 then
      max
    else
      var x: int := |GetLongHelp(opts[0], 0)|; var newMax: int := if x > max then x else max; GetLongLen(opts[1..], newMax)
  }

  function method GetCommandLen(opts: seq<Param>, max: nat := 0): nat
    decreases opts, max
  {
    if |opts| == 0 then
      max
    else
      var x: int := if opts[0].Command? then |opts[0].options.name| else 0; var newMax: int := if x > max then x else max; GetCommandLen(opts[1..], newMax)
  }

  function method AddShortAlias(aliases: seq<char>, shortMap: map<char, string>, name: string, ghost origLongMap: map<string, Param>, ghost origAliases: seq<char> := aliases, ghost origShortMap: map<char, string> := shortMap): (ret: Result<map<char, string>, string>)
    requires name in origLongMap
    requires forall x: char {:trigger shortMap[x]} {:trigger x in shortMap} | x in shortMap :: shortMap[x] in origLongMap
    requires forall k: char {:trigger origShortMap[k]} {:trigger shortMap[k]} {:trigger k in shortMap} {:trigger k in origShortMap} | k in origShortMap :: k in shortMap && shortMap[k] == origShortMap[k]
    requires forall k: char {:trigger shortMap[k]} {:trigger k in shortMap} {:trigger k in aliases} {:trigger k in origAliases} | k in origAliases :: (k in aliases || k in shortMap) && (k in aliases || shortMap[k] == name)
    requires forall k: char {:trigger origShortMap[k]} {:trigger shortMap[k]} {:trigger k in origShortMap} {:trigger k in shortMap} | k in shortMap :: (k in origShortMap && shortMap[k] == origShortMap[k]) || shortMap[k] == name
    ensures ret.Success? ==> (forall k: char {:trigger origShortMap[k]} {:trigger ret.value[k]} {:trigger k in ret.value} {:trigger k in origShortMap} | k in origShortMap :: k in ret.value && ret.value[k] == origShortMap[k]) && (forall k: char {:trigger ret.value[k]} {:trigger k in ret.value} {:trigger k in origAliases} | k in origAliases :: k in ret.value && ret.value[k] == name) && forall x: char {:trigger ret.value[x]} {:trigger x in ret.value} | x in ret.value :: ret.value[x] in origLongMap
    decreases aliases, shortMap, name, origLongMap, origAliases, origShortMap
  {
    if |aliases| == 0 then
      Success(shortMap)
    else if aliases[0] in shortMap then
      Failure("Short alias '" + aliases[0 .. 1] + "' for '" + name + "' already in use as a short option.")
    else
      AddShortAlias(aliases[1..], shortMap[aliases[0] := name], name, origLongMap, origAliases, origShortMap)
  }

  function method AddLongAlias(aliases: seq<string>, longMap: map<string, Param>, opt: Param): (ret: Result<map<string, Param>, string>)
    ensures ret.Success? ==> forall k: seq<char> {:trigger k in ret.value} {:trigger k in longMap} | k in longMap :: k in ret.value
    decreases aliases, longMap, opt
  {
    if |aliases| == 0 then
      Success(longMap)
    else if aliases[0] in longMap then
      Failure("Long alias '" + aliases[0] + "' already in use as a long option.")
    else
      AddLongAlias(aliases[1..], longMap[aliases[0] := opt], opt)
  }

  function method {:tailrecursion} GetMaps(opts: seq<Param>, longMap: map<string, Param> := map[], shortMap: map<char, string> := map[], commandMap: CommandMap := map[]): (ret: Result<(map<string, Param>, map<char, string>, CommandMap), string>)
    requires forall x: char {:trigger shortMap[x]} {:trigger x in shortMap} | x in shortMap :: shortMap[x] in longMap
    ensures ret.Success? ==> forall x: char {:trigger ret.value.1[x]} {:trigger x in ret.value.1} | x in ret.value.1 :: ret.value.1[x] in ret.value.0
    decreases opts, longMap, shortMap, commandMap
  {
    if |opts| == 0 then
      Success((longMap, shortMap, commandMap))
    else
      var opt: Param := opts[0]; if opt.Command? then :- Need(opt.options.name !in commandMap, "Duplicate command in options : " + opt.options.name); GetMaps(opts[1..], longMap, shortMap, commandMap[opt.options.name := opt.options]) else :- Need(opt.name !in longMap, "Duplicate long name in options : " + opt.name); var newLongMap: map<string, Param> := longMap[opt.name := opt]; var newShortMap: map<char, string> :- AddShortAlias(opt.ShortAlias(), shortMap, opt.name, newLongMap); var newLongMap: map<string, Param> :- AddLongAlias(opt.LongAlias(), newLongMap, opt); if opt.short != NullChar then var short: char := opt.short; if short in newShortMap then Failure("Duplicate short char in options : '" + [short] + "' for " + opt.name + " and " + newShortMap[short]) else GetMaps(opts[1..], newLongMap[opt.name := opt], newShortMap[short := opt.name], commandMap) else GetMaps(opts[1..], newLongMap[opt.name := opt], newShortMap, commandMap)
  }

  function Print<T>(x: T): Outcome<string>
  {
    Pass
  } by method {
    print x, "\n";
    return Pass;
  }

  predicate method {:tailrecursion} ArgExists(args: seq<OneArg>, name: string)
    decreases args, name
  {
    if |args| == 0 then
      false
    else if args[0].name == name then
      true
    else
      ArgExists(args[1..], name)
  }

  function method {:tailrecursion} PostProcess2(opts: seq<Param>, args: seq<OneArg>, newArgs: seq<OneArg> := []): Result<seq<OneArg>, string>
    decreases opts, args, newArgs
  {
    if |opts| == 0 then
      Success(newArgs)
    else if opts[0].Opt? && opts[0].Required() && !ArgExists(args, opts[0].name) then
      Failure("Option '" + opts[0].name + "' is required, but was not used.")
    else if opts[0].Opt? && opts[0].HasDefault() && !ArgExists(args, opts[0].name) then
      PostProcess2(opts[1..], args, newArgs + [OneArg(opts[0].name, Some(opts[0].unused.val))])
    else
      PostProcess2(opts[1..], args, newArgs)
  }

  function method {:tailrecursion} GetSubOptions(opts: seq<Param>, name: string, pos: nat := 0): (ret: Option<nat>)
    requires pos <= |opts|
    ensures ret.Some? ==> 0 < |opts| && ret.value < |opts| && opts[ret.value].Command? && opts[ret.value].options.name == name
    decreases |opts| - pos
  {
    if |opts| == pos then
      None
    else if opts[pos].Command? && opts[pos].options.name == name then
      Some(pos)
    else
      GetSubOptions(opts, name, pos + 1)
  }

  function method PostProcess(opts: Options, args: Parsed): Result<Parsed, string>
    decreases opts, args
  {
    if IsHelp(args) then
      Success(args)
    else
      var newParams: seq<OneArg> :- PostProcess2(opts.params, args.params); if args.subcommand.Some? then var optPos: Option<nat> := GetSubOptions(opts.params, args.subcommand.value.command); if optPos.Some? then var sub: Parsed :- PostProcess(opts.params[optPos.value].options, args.subcommand.value); Success(args.(params := args.params + newParams, subcommand := Some(sub))) else Failure("Internal error in GetOpt::PostProcess") else Success(args.(params := args.params + newParams))
  }

  predicate method AllDigits(s: string)
    decreases s
  {
    if |s| == 0 then
      true
    else if '0' <= s[0] <= '9' then
      AllDigits(s[1..])
    else
      false
  }

  predicate method ValidPositional(s: string)
    decreases s
  {
    if |s| == 0 then
      true
    else if s[0] != '-' then
      true
    else
      AllDigits(s[1..])
  }

  function method TestPositionals(opts: seq<Param>, optional: Option<string> := None): Outcome<string>
    decreases opts, optional
  {
    if |opts| == 0 then
      Pass
    else if !opts[0].Opt? then
      TestPositionals(opts[1..], optional)
    else if opts[0].positional == No then
      TestPositionals(opts[1..], optional)
    else if opts[0].positional == Maybe then
      TestPositionals(opts[1..], Some(opts[0].name))
    else if optional.None? then
      TestPositionals(opts[1..], optional)
    else
      Fail("Required positional argument '" + opts[0].name + "' follows optional positional argument '" + optional.value + "'.")
  }

  function method GetPositionals(opts: seq<Param>, args: seq<string>, params: seq<OneArg> := []): (ret: Result<(seq<string>, seq<OneArg>), string>)
    ensures ret.Success? ==> |ret.value.0| <= |args|
    decreases opts, args, params
  {
    if |opts| == 0 then
      Success((args, params))
    else if !opts[0].Opt? then
      GetPositionals(opts[1..], args, params)
    else if opts[0].positional == No then
      GetPositionals(opts[1..], args, params)
    else if opts[0].positional == Yes then
      if |args| == 0 then
        Failure("Positional arg '" + opts[0].name + "' is required, but we've run out of arguments.")
      else if ValidPositional(args[0]) then
        GetPositionals(opts[1..], args[1..], params + [OneArg(opts[0].name, Some(args[0]))])
      else
        Failure("Positional arg " + opts[0].name + " matched with invalid positional value '" + args[0] + "'.")
    else
      assert opts[0].positional == Maybe; if |args| == 0 then Success((args, params)) else if ValidPositional(args[0]) then GetPositionals(opts[1..], args[1..], params + [OneArg(opts[0].name, Some(args[0]))]) else Success((args, params))
  }

  function method GetOptions(opts: Options, args: seq<string>): Result<Parsed, string>
    requires 0 < |args|
    decreases args
  {
    var newOpts: seq<Param> := opts.params + [HELP_PARAM];
    var inherits: seq<Param> := Filter((o: Param) => o.Inherits(), newOpts);
    :- TestPositionals(newOpts); var (newArgs: seq<string>, params: seq<OneArg>) :- GetPositionals(newOpts, args[1..]); var (longMap: map<string, Param>, shortMap: map<char, string>, commandMap: CommandMap) :- GetMaps(newOpts); var context: Context := Context(longMap, shortMap, inherits, commandMap, args[0]); var result: Parsed :- GetOptions2(newArgs, context, params); PostProcess(opts, result)
  }

  function method {:opaque} IndexOf<T(==)>(xs: seq<T>, v: T): (i: nat)
    requires v in xs
    ensures i < |xs| && xs[i] == v
    ensures forall j: int {:trigger xs[j]} :: 0 <= j < i ==> xs[j] != v
    decreases xs
  {
    if xs[0] == v then
      0
    else
      1 + IndexOf(xs[1..], v)
  }

  function method SplitOnce<T(==)>(s: seq<T>, delim: T): (res: (seq<T>, seq<T>))
    requires delim in s
    ensures res.0 + [delim] + res.1 == s
    ensures !(delim in res.0)
    decreases s
  {
    var i: nat := IndexOf(s, delim);
    (s[..i], s[i + 1..])
  }

  function method GetOptions2(args: seq<string>, context: Context, parms: seq<OneArg> := [], files: seq<string> := []): Result<Parsed, string>
    requires forall x: char {:trigger context.shortMap[x]} {:trigger x in context.shortMap} | x in context.shortMap :: context.shortMap[x] in context.longMap
    decreases args
  {
    if |args| == 0 then
      Success(Parsed(context.command, parms, files, None))
    else if args[0] in context.commands then
      var inherits: seq<Param> := Filter((o: Param) => o.Inherits(), context.commands[args[0]].params);
      var newOpts: seq<Param> := context.commands[args[0]].params + context.inherits;
      :- TestPositionals(newOpts); var (newArgs: seq<string>, params: seq<OneArg>) :- GetPositionals(newOpts, args[1..]); var (longMap: map<string, Param>, shortMap: map<char, string>, commandSet: CommandMap) :- GetMaps(newOpts); var newContext: Context := Context(longMap, shortMap, context.inherits + inherits, commandSet, args[0]); var lostArgs: int := |args| - |newArgs|; var result: Parsed :- GetOptions2(args[lostArgs..], newContext, params); Success(Parsed(context.command, parms, files, Some(result)))
    else if args[0] == "--" then
      Success(Parsed(context.command, parms, files + args[1..], None))
    else if "--" < args[0] then
      var longOpt: seq<char> := args[0][2..];
      if '=' in longOpt then
        var (opt: seq<char>, arg: seq<char>) := SplitOnce(longOpt, '=');
        if opt in context.longMap then
          if context.longMap[opt].NeedsArg() then
            GetOptions2(args[1..], context, parms + context.longMap[opt].MakeArg(Some(arg)), files)
          else
            Failure("Option " + opt + " does not take an argument, but it got one.")
        else
          Failure("Option " + opt + " not recognized.")
      else if longOpt in context.longMap then
        var opt: Param := context.longMap[longOpt];
        if opt.NeedsArg() then
          if |args| < 2 then
            Failure("Option " + longOpt + " requires an argument, but didn't get one.")
          else
            GetOptions2(args[2..], context, parms + opt.MakeArg(Some(args[1])), files)
        else if opt.Flag? && opt.solo && (|args| != 1 || |parms| != 0 || |files| != 0) then
          Failure("Option '" + longOpt + "' used with other stuff, but must only be used alone.")
        else
          GetOptions2(args[1..], context, parms + opt.MakeArg(None), files)
      else
        Failure("Option " + longOpt + " not recognized.")
    else if "-" == args[0] then
      GetOptions2(args[1..], context, parms, files + [args[0]])
    else if "-" < args[0] then
      var (newParms: seq<OneArg>, nextParm: Option<char>) :- GetShort(args[0][1..], context.longMap, context.shortMap); if nextParm.None? then GetOptions2(args[1..], context, parms + newParms, files) else if |args| == 1 then Failure("Short option " + [nextParm.value] + " requires argument but didn't get one.") else var longOpt: seq<char> := context.shortMap[nextParm.value]; var opt: Param := context.longMap[longOpt]; GetOptions2(args[2..], context, parms + newParms + opt.MakeArg(Some(args[1])), files)
    else if |context.commands| == 0 then
      GetOptions2(args[1..], context, parms, files + [args[0]])
    else
      Failure("Unrecognized command " + args[0] + " for " + context.command + "\nRun '" + context.command + " --help' for usage.")
  }

  function method GetShort(arg: string, longMap: map<string, Param>, shortMap: map<char, string>, parms: seq<OneArg> := []): (res: Result<(seq<OneArg>, Option<char>), string>)
    requires forall x: char {:trigger shortMap[x]} {:trigger x in shortMap} | x in shortMap :: shortMap[x] in longMap
    ensures res.Success? && res.value.1.Some? ==> res.value.1.value in shortMap
    decreases arg, longMap, shortMap, parms
  {
    if |arg| == 0 then
      Success((parms, None))
    else
      var ch: char := arg[0]; if ch in shortMap then var opt: seq<char> := shortMap[ch]; if longMap[opt].NeedsArg() then if |arg| == 1 then Success((parms, Some(ch))) else Success((parms + longMap[opt].MakeArg(Some(arg[1..])), None)) else GetShort(arg[1..], longMap, shortMap, parms + longMap[opt].MakeArg(None)) else Failure("Short option '" + [ch] + "' not recognized.")
  }

  import opened Wrappers

  datatype Tri = Yes | No | Maybe

  datatype Visibility = Normal | Hidden | Deprecated

  datatype Options = Options(name: string, help: string, params: seq<Param>)

  datatype Unused = UnusedOk | Required | Default(val: string)

  datatype Param = Opt(name: string, help: string, nameonly argName: string := "arg", nameonly short: char := NullChar, nameonly unused: Unused := UnusedOk, nameonly inherit: bool := false, nameonly vis: Visibility := Normal, nameonly shortAlias: seq<char> := [], nameonly longAlias: seq<string> := [], nameonly positional: Tri := No) | Flag(name: string, help: string, nameonly short: char := NullChar, nameonly solo: bool := false, nameonly inherit: bool := false, nameonly vis: Visibility := Normal, nameonly shortAlias: seq<char> := [], nameonly longAlias: seq<string> := []) | Command(options: Options) {
    predicate method NeedsArg()
      decreases this
    {
      this.Opt?
    }

    predicate method Inherits()
      decreases this
    {
      (this.Opt? || this.Flag?) &&
      this.inherit
    }

    predicate method ShowHelp()
      decreases this
    {
      this.Command? || this.vis == Normal
    }

    predicate method KeepResult()
      decreases this
    {
      this.Command? || this.vis != Deprecated
    }

    function method Name(): string
      decreases this
    {
      if this.Command? then
        options.name
      else
        name
    }

    function method MakeArg(value: Option<string>): seq<OneArg>
      decreases this, value
    {
      if this.KeepResult() then
        [OneArg(Name(), value)]
      else
        []
    }

    function method ShortAlias(): seq<char>
      decreases this
    {
      if this.Command? then
        []
      else
        shortAlias
    }

    function method LongAlias(): seq<string>
      decreases this
    {
      if this.Command? then
        []
      else
        longAlias
    }

    predicate method Required()
      decreases this
    {
      this.Opt? &&
      this.unused.Required?
    }

    predicate method HasDefault()
      decreases this
    {
      this.Opt? &&
      this.unused.Default?
    }
  }

  datatype OneArg = OneArg(name: string, value: Option<string>)

  datatype Parsed = Parsed(command: string, params: seq<OneArg>, files: seq<string>, subcommand: Option<Parsed>)

  type CommandMap = x: map<string, Options>
    | forall k: seq<char> | k in x :: x[k].name == k

  datatype Context = Context(longMap: map<string, Param>, shortMap: map<char, string>, inherits: seq<Param>, commands: CommandMap, command: string)
}

module FloatCompare {
  const Less: CompareType := -1
  const Equal: CompareType := 0
  const Greater: CompareType := 1

  function method {:tailrecursion} StrToIntInner(s: string, acc: int := 0): int
    decreases s, acc
  {
    if |s| == 0 then
      acc
    else if '0' <= s[0] <= '9' then
      StrToIntInner(s[1..], acc * 10 + s[0] as int - '0' as int)
    else
      StrToIntInner(s[1..], acc)
  }

  function method {:tailrecursion} SkipLeadingSpace(val: string): (ret: string)
    ensures |ret| == 0 || ret[0] > ' '
    decreases val
  {
    if |val| > 0 && val[0] <= ' ' then
      SkipLeadingSpace(val[1..])
    else
      val
  }

  function method {:tailrecursion} StrToInt(s: string, acc: int := 0): int
    decreases s, acc
  {
    var tmp: string := SkipLeadingSpace(s);
    if |tmp| == 0 then
      0
    else if tmp[0] == '-' then
      -StrToIntInner(s)
    else
      StrToIntInner(s)
  }

  function method SplitE(x: string): Option<(string, string)>
    decreases x
  {
    var parts: Option<(seq<char>, seq<char>)> := SplitOnce?(x, 'e');
    if parts.Some? then
      parts
    else
      SplitOnce?(x, 'E')
  }

  function method SplitExp(x: string): (string, int)
    decreases x
  {
    var parts: Option<(string, string)> := SplitE(x);
    if parts.Some? then
      (parts.value.0, StrToInt(parts.value.1))
    else
      (x, 0)
  }

  function method {:tailrecursion} SkipLeadingZeros(val: string): (ret: string)
    ensures |ret| == 0 || ret[0] != '0'
    decreases val
  {
    if |val| > 0 && val[0] == '0' then
      SkipLeadingZeros(val[1..])
    else
      val
  }

  function method {:tailrecursion} SkipTrailingZeros(val: string): (ret: string)
    ensures |ret| == 0 || ret[|ret| - 1] != '0'
    decreases val
  {
    if |val| > 0 && val[|val| - 1] == '0' then
      SkipTrailingZeros(val[..|val| - 1])
    else
      val
  }

  function method SplitDot(x: string): (string, string)
    decreases x
  {
    var parts: Option<(seq<char>, seq<char>)> := SplitOnce?(x, '.');
    if parts.Some? then
      (SkipLeadingZeros(parts.value.0), SkipTrailingZeros(parts.value.1))
    else
      (SkipLeadingZeros(x), "")
  }

  function method StrCmp(x: string, y: string): (ret: CompareType)
    decreases x, y
  {
    if |x| == 0 && |y| == 0 then
      0
    else if |x| == 0 then
      -1
    else if |y| == 0 then
      1
    else if x[0] < y[0] then
      -1
    else if x[0] > y[0] then
      1
    else
      StrCmp(x[1..], y[1..])
  }

  lemma /*{:_inductionTrigger StrCmp(y, x)}*/ /*{:_inductionTrigger StrCmp(x, y)}*/ /*{:_induction x, y}*/ StrCmpSymmetric(x: string, y: string)
    ensures StrCmp(x, y) == -StrCmp(y, x)
    decreases x, y
  {
  }

  function method AppendZeros(x: string, newLength: nat): (ret: string)
    requires |x| < newLength
    ensures |ret| == newLength
    decreases x, newLength
  {
    x + seq(newLength - |x|, (i: int) => '0')
  }

  function method CompareFloatInner(x: string, y: string): (ret: CompareType)
    decreases x, y
  {
    var xParts: (string, int) := SplitExp(x);
    var yParts: (string, int) := SplitExp(y);
    var xNum: (string, string) := SplitDot(xParts.0);
    var yNum: (string, string) := SplitDot(yParts.0);
    var xDigits: string := SkipLeadingZeros(xNum.0 + xNum.1);
    var yDigits: string := SkipLeadingZeros(yNum.0 + yNum.1);
    var xExp: int := xParts.1 - |xNum.1|;
    var yExp: int := yParts.1 - |yNum.1|;
    var logX: int := xExp + |xDigits|;
    var logY: int := yExp + |yDigits|;
    if logX > logY then
      1
    else if logY > logX then
      -1
    else if |xDigits| < |yDigits| then
      StrCmp(AppendZeros(xDigits, |yDigits|), yDigits)
    else if |yDigits| < |xDigits| then
      StrCmp(xDigits, AppendZeros(yDigits, |xDigits|))
    else
      StrCmp(xDigits, yDigits)
  }

  predicate method IsNegative(x: string)
    decreases x
  {
    |x| > 0 &&
    x[0] == '-'
  }

  function method SkipLeadingPlus(x: string): string
    decreases x
  {
    if 0 < |x| && x[0] == '+' then
      x[1..]
    else
      x
  }

  predicate method IsZero(x: string)
    decreases x
  {
    if |x| == 0 then
      true
    else if x[0] == '0' || x[0] == '.' then
      IsZero(x[1..])
    else if '1' <= x[0] <= '9' then
      false
    else
      true
  }

  function method RecognizeZero(x: string): string
    decreases x
  {
    if IsNegative(x) then
      if IsZero(x[1..]) then
        "0"
      else
        x
    else if IsZero(x) then
      "0"
    else
      x
  }

  function method CleanNumber(x: string): string
    decreases x
  {
    RecognizeZero(SkipLeadingPlus(SkipLeadingSpace(x)))
  }

  function method CompareFloat(x: string, y: string): (ret: CompareType)
    decreases x, y
  {
    var x: string := CleanNumber(x);
    var y: string := CleanNumber(y);
    if IsNegative(x) && IsNegative(y) then
      CompareFloatInner(y[1..], x[1..])
    else if IsNegative(x) then
      -1
    else if IsNegative(y) then
      1
    else
      CompareFloatInner(x, y)
  }

  import opened Wrappers

  import opened StandardLibrary

  newtype CompareType = x: int
    | -1 <= x <= 1
}

module {:extern "ConcurrentCall"} ConcurrentCall {
  method {:extern "ConcurrentCall"} ConcurrentCall(nameonly callee: Callee, nameonly serialIters: uint32, nameonly concurrentIters: uint32)
    decreases callee, serialIters, concurrentIters

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  trait {:termination false} Callee {
    ghost var Modifies: set<object>

    predicate ValidState()
      reads this
      decreases {this}

    method call(nameonly serialPos: uint32, nameonly concurrentPos: uint32)
      requires ValidState()
      modifies Modifies
      ensures ValidState()
      decreases serialPos, concurrentPos
  }
}

module Base64Lemmas {
  lemma DecodeValidEncodeEmpty(s: seq<char>)
    requires s == []
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
  }

  lemma DecodeValidEncodeUnpadded(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires !Is1Padding(s[|s| - 4..])
    requires !Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    calc {
      Encode(DecodeValid(s));
    ==
      Encode(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      {
        DecodeEncodeUnpadded(s);
      }
      s;
    }
  }

  lemma DecodeValidUnpaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 2] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid1PaddedPartialFrom1PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 2..] == Decode1Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma {:vcs_split_on_every_assert} DecodeValidEncode1Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    DecodeValidEncode1PaddingHelper(s);
    calc {
      Encode(DecodeValid(s));
    ==
      EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 2]) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom1PaddedSeq(s);
      }
      (assert IsUnpaddedBase64String(s[..|s| - 4]) by {
        assert |s| % 4 == 0;
      } EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]));
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode1Padding(DecodeValid(s)[|DecodeValid(s)| - 2..]);
    ==
      {
        DecodeValid1PaddedPartialFrom1PaddedSeq(s);
      }
      s[..|s| - 4] + Encode1Padding(Decode1Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode1Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValidEncode1PaddingHelper(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is1Padding(s[|s| - 4..])
    decreases s
  {
    assert |s| % 4 == 0;
    assert |DecodeValid(s)| % 3 == 2;
    assert 2 <= |DecodeValid(s)|;
  }

  lemma DecodeValidUnpaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[..|DecodeValid(s)| - 1] == DecodeUnpadded(s[..|s| - 4])
    decreases s
  {
  }

  lemma DecodeValid2PaddedPartialFrom2PaddedSeq(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures DecodeValid(s)[|DecodeValid(s)| - 1..] == Decode2Padding(s[|s| - 4..])
    decreases s
  {
  }

  lemma {:vcs_split_on_every_assert} DecodeValidEncode2Padding(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    DecodeValid2PaddingPropertiesHelper(s);
    calc {
      Encode(DecodeValid(s));
    ==
      EncodeUnpadded(DecodeValid(s)[..|DecodeValid(s)| - 1]) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValidUnpaddedPartialFrom2PaddedSeq(s);
      }
      EncodeUnpadded(DecodeUnpadded(s[..|s| - 4])) + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeEncodeUnpadded(s[..|s| - 4]);
      }
      s[..|s| - 4] + Encode2Padding(DecodeValid(s)[|DecodeValid(s)| - 1..]);
    ==
      {
        DecodeValid2PaddedPartialFrom2PaddedSeq(s);
      }
      s[..|s| - 4] + Encode2Padding(Decode2Padding(s[|s| - 4..]));
    ==
      {
        DecodeEncode2Padding(s[|s| - 4..]);
      }
      s[..|s| - 4] + s[|s| - 4..];
    ==
      {
        SeqPartsMakeWhole(s, |s| - 4);
      }
      s;
    }
  }

  lemma DecodeValid2PaddingPropertiesHelper(s: seq<char>)
    requires IsBase64String(s)
    requires |s| >= 4
    requires Is2Padding(s[|s| - 4..])
    decreases s
  {
    assert |DecodeUnpadded(s[..|s| - 4])| % 3 == 0;
    assert |DecodeValid(s)| % 3 == 1;
  }

  lemma DecodeValidEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(DecodeValid(s)) == s
    decreases s
  {
    if s == [] {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeEmpty(s);
        }
        s;
      }
    } else if |s| >= 4 && Is1Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode1Padding(s);
        }
        s;
      }
    } else if |s| >= 4 && Is2Padding(s[|s| - 4..]) {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncode2Padding(s);
        }
        s;
      }
    } else {
      calc {
        Encode(DecodeValid(s));
      ==
        {
          DecodeValidEncodeUnpadded(s);
        }
        s;
      }
    }
  }

  lemma {:vcs_split_on_every_assert} EncodeDecodeValid(b: seq<uint8>)
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
    if |b| % 3 == 0 {
      EncodeDecodeValid0(b);
    } else if |b| % 3 == 1 {
      EncodeDecodeValid1(b);
    } else {
      EncodeDecodeValid2(b);
    }
  }

  lemma EncodeDecodeValid0(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
  }

  lemma EncodeDecodeValid1(b: seq<uint8>)
    requires |b| % 3 == 1
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
  }

  lemma EncodeDecodeValid2(b: seq<uint8>)
    requires |b| % 3 == 2
    ensures DecodeValid(Encode(b)) == b
    decreases b
  {
  }

  lemma DecodeEncode(s: seq<char>)
    requires IsBase64String(s)
    ensures Encode(Decode(s).value) == s
    decreases s
  {
    calc {
      Encode(Decode(s).value);
    ==
      {
        DecodeValidEncode(s);
      }
      s;
    }
  }

  lemma EncodeDecode(b: seq<uint8>)
    ensures Decode(Encode(b)) == Success(b)
    decreases b
  {
    calc {
      Decode(Encode(b));
    ==
      {
        assert IsBase64String(Encode(b));
      }
      Success(DecodeValid(Encode(b)));
    ==
      {
        EncodeDecodeValid(b);
      }
      Success(b);
    }
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened Base64
}

module Base64 {
  predicate method IsBase64Char(c: char)
    decreases c
  {
    c == '+' || c == '/' || '0' <= c <= '9' || 'A' <= c <= 'Z' || 'a' <= c <= 'z'
  }

  predicate IsUnpaddedBase64String(s: string)
    decreases s
  {
    |s| % 4 == 0 &&
    forall k: char {:trigger IsBase64Char(k)} {:trigger k in s} :: 
      k in s ==>
        IsBase64Char(k)
  } by method {
    SequenceIsSafeBecauseItIsInMemory(s);
    var size := |s| as uint64;
    if size % 4 != 0 {
      return false;
    }
    for i: uint64 := 0 to size
      invariant |s| % 4 == 0 && forall k: char {:trigger IsBase64Char(k)} {:trigger k in s[..i]} :: k in s[..i] ==> IsBase64Char(k)
    {
      if !IsBase64Char(s[i]) {
        return false;
      }
    }
    return true;
  }

  function method IndexToChar(i: index): (c: char)
    ensures IsBase64Char(c)
    decreases i
  {
    if i == 63 then
      '/'
    else if i == 62 then
      '+'
    else if 52 <= i <= 61 then
      (i - 4) as char
    else if 26 <= i <= 51 then
      (i as uint8 + 71) as char
    else
      (i as uint8 + 65) as char
  }

  function method CharToIndex(c: char): (i: index)
    requires IsBase64Char(c)
    ensures IndexToChar(i) == c
    decreases c
  {
    if c == '/' then
      63
    else if c == '+' then
      62
    else if '0' <= c <= '9' then
      (c as uint8 + 4) as index
    else if 'a' <= c <= 'z' then
      (c as uint8 - 71) as index
    else
      (c as uint8 - 65) as index
  }

  lemma CharToIndexToChar(x: char)
    requires IsBase64Char(x)
    ensures IndexToChar(CharToIndex(x)) == x
    decreases x
  {
  }

  lemma IndexToCharToIndex(x: index)
    ensures CharToIndex(IndexToChar(x)) == x
    decreases x
  {
  }

  function method UInt24ToSeq(x: uint24): (ret: seq<uint8>)
    ensures |ret| == 3
    ensures ret[0] as uint24 * 65536 + ret[1] as uint24 * 256 + ret[2] as uint24 == x
    decreases x
  {
    var b0: uint8 := (x / 65536) as uint8;
    var x0: uint24 := x - b0 as uint24 * 65536;
    var b1: uint8 := (x0 / 256) as uint8;
    var b2: uint8 := (x0 % 256) as uint8;
    [b0, b1, b2]
  }

  function method SeqToUInt24(s: seq<uint8>): (x: uint24)
    requires |s| == 3
    ensures UInt24ToSeq(x) == s
    decreases s
  {
    s[0 as uint32] as uint24 * 65536 + s[1 as uint32] as uint24 * 256 + s[2 as uint32] as uint24
  }

  function method SeqPosToUInt24(s: seq<uint8>, pos: uint64): (x: uint24)
    requires |s| >= pos as nat + 3
    ensures UInt24ToSeq(x) == s[pos .. pos as nat + 3]
    decreases s, pos
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    s[pos] as uint24 * 65536 + s[pos + 1] as uint24 * 256 + s[pos + 2] as uint24
  }

  lemma UInt24ToSeqToUInt24(x: uint24)
    ensures SeqToUInt24(UInt24ToSeq(x)) == x
    decreases x
  {
  }

  lemma SeqToUInt24ToSeq(s: seq<uint8>)
    requires |s| == 3
    ensures UInt24ToSeq(SeqToUInt24(s)) == s
    decreases s
  {
  }

  function method UInt24ToIndexSeq(x: uint24): (ret: seq<index>)
    ensures |ret| == 4
    ensures ret[0] as uint24 * 262144 + ret[1] as uint24 * 4096 + ret[2] as uint24 * 64 + ret[3] as uint24 == x
    decreases x
  {
    var b0: index := (x / 262144) as index;
    var x0: uint24 := x - b0 as uint24 * 262144;
    var b1: index := (x0 / 4096) as index;
    var x1: uint24 := x0 - b1 as uint24 * 4096;
    var b2: index := (x1 / 64) as index;
    var b3: index := (x1 % 64) as index;
    [b0, b1, b2, b3]
  }

  function method {:vcs_split_on_every_assert} IndexSeqToUInt24(s: seq<index>): (x: uint24)
    requires |s| == 4
    ensures UInt24ToIndexSeq(x) == s
    decreases s
  {
    s[0 as uint32] as uint24 * 262144 + s[1 as uint32] as uint24 * 4096 + s[2 as uint32] as uint24 * 64 + s[3 as uint32] as uint24
  }

  function method {:vcs_split_on_every_assert} IndexSeqPosToUInt24(s: seq<index>, pos: uint64): (x: uint24)
    requires |s| >= pos as nat + 4
    ensures UInt24ToIndexSeq(x) == s[pos .. pos as nat + 4]
    decreases s, pos
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    s[pos] as uint24 * 262144 + s[pos + 1] as uint24 * 4096 + s[pos + 2] as uint24 * 64 + s[pos + 3] as uint24
  }

  lemma UInt24ToIndexSeqToUInt24(x: uint24)
    ensures IndexSeqToUInt24(UInt24ToIndexSeq(x)) == x
    decreases x
  {
  }

  lemma IndexSeqToUInt24ToIndexSeq(s: seq<index>)
    requires |s| == 4
    ensures UInt24ToIndexSeq(IndexSeqToUInt24(s)) == s
    decreases s
  {
  }

  function method DecodeBlock(s: seq<index>): (ret: seq<uint8>)
    requires |s| == 4
    ensures |ret| == 3
    ensures UInt24ToIndexSeq(SeqToUInt24(ret)) == s
    decreases s
  {
    UInt24ToSeq(IndexSeqToUInt24(s))
  }

  function method DecodeBlockPos(s: seq<index>, pos: uint64): (ret: seq<uint8>)
    requires |s| >= pos as nat + 4
    ensures |ret| == 3
    ensures UInt24ToIndexSeq(SeqToUInt24(ret)) == s[pos .. pos as nat + 4]
    decreases s, pos
  {
    UInt24ToSeq(IndexSeqPosToUInt24(s, pos))
  }

  function method EncodeBlock(s: seq<uint8>): (ret: seq<index>)
    requires |s| == 3
    ensures |ret| == 4
    ensures UInt24ToSeq(IndexSeqToUInt24(ret)) == s
    ensures DecodeBlock(ret) == s
    decreases s
  {
    UInt24ToIndexSeq(SeqToUInt24(s))
  }

  function method EncodeBlockPos(s: seq<uint8>, pos: uint64): (ret: seq<index>)
    requires |s| >= pos as nat + 3
    ensures |ret| == 4
    ensures UInt24ToSeq(IndexSeqToUInt24(ret)) == s[pos .. pos as nat + 3]
    ensures DecodeBlock(ret) == s[pos .. pos as nat + 3]
    decreases s, pos
  {
    UInt24ToIndexSeq(SeqPosToUInt24(s, pos))
  }

  lemma EncodeDecodeBlock(s: seq<uint8>)
    requires |s| == 3
    ensures DecodeBlock(EncodeBlock(s)) == s
    decreases s
  {
  }

  lemma DecodeEncodeBlock(s: seq<index>)
    requires |s| == 4
    ensures EncodeBlock(DecodeBlock(s)) == s
    decreases s
  {
  }

  function DecodeRecursively(s: seq<index>): (b: seq<uint8>)
    requires |s| % 4 == 0
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    ensures |b| == 0 ==> |s| == 0
    ensures |b| != 0 ==> EncodeBlock(b[..3]) == s[..4]
    decreases |s|
  {
    if |s| == 0 then
      []
    else
      DecodeBlock(s[..4]) + DecodeRecursively(s[4..])
  } by method {
    assert |s| == 0 || 4 <= |s|;
    SequenceIsSafeBecauseItIsInMemory(s);
    var i: uint64 := |s| as uint64;
    var result: seq<uint8> := [];
    while i > 0
      invariant (|s| - i as nat) % 4 == 0
      invariant result == DecodeRecursively(s[i..])
      decreases i
    {
      result := DecodeBlockPos(s, i - 4) + result;
      i := i - 4;
    }
    return result;
  }

  function EncodeRecursively(b: seq<uint8>): (s: seq<index>)
    requires |b| % 3 == 0
    ensures |s| == |b| / 3 * 4
    ensures |s| % 4 == 0
    ensures DecodeRecursively(s) == b
    decreases b
  {
    if |b| == 0 then
      []
    else
      EncodeBlock(b[..3]) + EncodeRecursively(b[3..])
  } by method {
    assert |b| == 0 || 3 <= |b|;
    SequenceIsSafeBecauseItIsInMemory(b);
    var i: uint64 := |b| as uint64;
    var result: seq<index> := [];
    while i > 0
      invariant (|b| - i as nat) % 3 == 0
      invariant result == EncodeRecursively(b[i..])
      decreases i
    {
      result := EncodeBlockPos(b, i - 3) + result;
      i := i - 3;
    }
    return result;
  }

  lemma /*{:_inductionTrigger DecodeRecursively(s)}*/ /*{:_inductionTrigger |s|}*/ /*{:_induction s}*/ DecodeEncodeRecursively(s: seq<index>)
    requires |s| % 4 == 0
    ensures EncodeRecursively(DecodeRecursively(s)) == s
    decreases s
  {
  }

  lemma /*{:_inductionTrigger EncodeRecursively(b)}*/ /*{:_inductionTrigger |b|}*/ /*{:_induction b}*/ EncodeDecodeRecursively(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeRecursively(EncodeRecursively(b)) == b
    decreases b
  {
  }

  function FromCharsToIndices(s: seq<char>): (b: seq<index>)
    requires forall k: char {:trigger IsBase64Char(k)} {:trigger k in s} :: k in s ==> IsBase64Char(k)
    ensures |b| == |s|
    ensures forall k: int {:trigger s[k]} {:trigger b[k]} :: 0 <= k < |b| ==> IndexToChar(b[k]) == s[k]
    decreases s
  {
    seq(|s|, (i: int) requires 0 <= i < |s| => CharToIndex(s[i]))
  } by method {
    var result: seq<index> := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant result == FromCharsToIndices(s[..i])
    {
      result := result + [CharToIndex(s[i])];
    }
    return result;
  }

  function FromIndicesToChars(b: seq<index>): (s: seq<char>)
    ensures forall k: char {:trigger IsBase64Char(k)} {:trigger k in s} :: k in s ==> IsBase64Char(k)
    ensures |s| == |b|
    ensures forall k: int {:trigger b[k]} {:trigger s[k]} :: 0 <= k < |s| ==> CharToIndex(s[k]) == b[k]
    ensures FromCharsToIndices(s) == b
    decreases b
  {
    seq(|b|, (i: int) requires 0 <= i < |b| => IndexToChar(b[i]))
  } by method {
    var result: seq<char> := [];
    SequenceIsSafeBecauseItIsInMemory(b);
    for i: uint64 := 0 to |b| as uint64
      invariant result == FromIndicesToChars(b[..i])
    {
      result := result + [IndexToChar(b[i])];
    }
    return result;
  }

  lemma FromCharsToIndicesToChars(s: seq<char>)
    requires forall k: char {:trigger IsBase64Char(k)} {:trigger k in s} :: k in s ==> IsBase64Char(k)
    ensures FromIndicesToChars(FromCharsToIndices(s)) == s
    decreases s
  {
  }

  lemma FromIndicesToCharsToIndices(b: seq<index>)
    ensures FromCharsToIndices(FromIndicesToChars(b)) == b
    decreases b
  {
  }

  function method DecodeUnpadded(s: seq<char>): (b: seq<uint8>)
    requires IsUnpaddedBase64String(s)
    ensures |b| == |s| / 4 * 3
    ensures |b| % 3 == 0
    decreases s
  {
    DecodeRecursively(FromCharsToIndices(s))
  }

  function method EncodeUnpadded(b: seq<uint8>): (s: seq<char>)
    requires |b| % 3 == 0
    ensures IsUnpaddedBase64String(s)
    ensures |s| == |b| / 3 * 4
    ensures DecodeUnpadded(s) == b
    ensures |s| % 4 == 0
    decreases b
  {
    FromIndicesToChars(EncodeRecursively(b))
  }

  lemma EncodeDecodeUnpadded(b: seq<uint8>)
    requires |b| % 3 == 0
    ensures DecodeUnpadded(EncodeUnpadded(b)) == b
    decreases b
  {
  }

  lemma DecodeEncodeUnpadded(s: seq<char>)
    requires |s| % 4 == 0
    requires IsUnpaddedBase64String(s)
    ensures EncodeUnpadded(DecodeUnpadded(s)) == s
    decreases s
  {
    ghost var fromCharsToIndicesS := FromCharsToIndices(s);
    calc {
      EncodeUnpadded(DecodeUnpadded(s));
    ==
      EncodeUnpadded(DecodeRecursively(FromCharsToIndices(s)));
    ==
      EncodeUnpadded(DecodeRecursively(fromCharsToIndicesS));
    ==
      assert |fromCharsToIndicesS| % 4 == 0; assert |DecodeRecursively(fromCharsToIndicesS)| % 3 == 0; FromIndicesToChars(EncodeRecursively(DecodeRecursively(fromCharsToIndicesS)));
    ==
      {
        DecodeEncodeRecursively(fromCharsToIndicesS);
      }
      FromIndicesToChars(fromCharsToIndicesS);
    ==
      FromIndicesToChars(FromCharsToIndices(s));
    ==
      {
        FromCharsToIndicesToChars(s);
      }
      s;
    }
  }

  predicate method Is1Padding(s: seq<char>)
    decreases s
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    |s| as uint64 == 4 &&
    IsBase64Char(s[0 as uint32]) &&
    IsBase64Char(s[1 as uint32]) &&
    IsBase64Char(s[2 as uint32]) &&
    CharToIndex(s[2 as uint32]) % 4 == 0 &&
    s[3 as uint32] == '='
  }

  function method Decode1Padding(s: seq<char>): (b: seq<uint8>)
    requires Is1Padding(s)
    ensures |b| == 2
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0 as uint32]), CharToIndex(s[1 as uint32]), CharToIndex(s[2 as uint32]), 0]);
    [d[0 as uint32], d[1 as uint32]]
  }

  function method {:vcs_split_on_every_assert} Encode1Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 2
    ensures Is1Padding(s)
    ensures Decode1Padding(s) == b
    ensures |s| % 4 == 0
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0 as uint32], b[1 as uint32], 0]);
    [IndexToChar(e[0 as uint32]), IndexToChar(e[1 as uint32]), IndexToChar(e[2 as uint32]), '=']
  }

  lemma DecodeEncode1Padding(s: seq<char>)
    requires Is1Padding(s)
    ensures Encode1Padding(Decode1Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode1Padding(b: seq<uint8>)
    requires |b| == 2
    ensures Decode1Padding(Encode1Padding(b)) == b
    decreases b
  {
  }

  predicate method Is2Padding(s: seq<char>)
    decreases s
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    |s| as uint64 == 4 &&
    IsBase64Char(s[0 as uint32]) &&
    IsBase64Char(s[1 as uint32]) &&
    CharToIndex(s[1 as uint32]) % 16 == 0 &&
    s[2 as uint32] == '=' &&
    s[3 as uint32] == '='
  }

  function method Decode2Padding(s: seq<char>): (b: seq<uint8>)
    requires Is2Padding(s)
    ensures |b| == 1
    decreases s
  {
    var d: seq<uint8> := DecodeBlock([CharToIndex(s[0 as uint32]), CharToIndex(s[1 as uint32]), 0, 0]);
    [d[0 as uint32]]
  }

  function method Encode2Padding(b: seq<uint8>): (s: seq<char>)
    requires |b| == 1
    ensures Is2Padding(s)
    ensures Decode2Padding(s) == b
    ensures |s| % 4 == 0
    decreases b
  {
    var e: seq<index> := EncodeBlock([b[0 as uint32], 0, 0]);
    [IndexToChar(e[0 as uint32]), IndexToChar(e[1 as uint32]), '=', '=']
  }

  lemma DecodeEncode2Padding(s: seq<char>)
    requires Is2Padding(s)
    ensures Encode2Padding(Decode2Padding(s)) == s
    decreases s
  {
  }

  lemma EncodeDecode2Padding(b: seq<uint8>)
    requires |b| == 1
    ensures Decode2Padding(Encode2Padding(b)) == b
    decreases b
  {
  }

  predicate method IsBase64String(s: string)
    decreases s
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    var size: uint64 := |s| as uint64;
    size % 4 == 0 &&
    (IsUnpaddedBase64String(s) || (IsUnpaddedBase64String(s[..size - 4]) && (Is1Padding(s[size - 4..]) || Is2Padding(s[size - 4..]))))
  }

  function method DecodeValid(s: seq<char>): (b: seq<uint8>)
    requires IsBase64String(s)
    decreases s
  {
    SequenceIsSafeBecauseItIsInMemory(s);
    var size: uint64 := |s| as uint64;
    if size == 0 then
      []
    else
      var finalBlockStart: BoundedInts.uint64 := size - 4; var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; if Is1Padding(suffix) then DecodeUnpadded(prefix) + Decode1Padding(suffix) else if Is2Padding(suffix) then DecodeUnpadded(prefix) + Decode2Padding(suffix) else DecodeUnpadded(s)
  }

  lemma {:vcs_split_on_every_assert} AboutDecodeValid(s: seq<char>, b: seq<uint8>)
    requires IsBase64String(s) && b == DecodeValid(s)
    ensures 4 <= |s| ==> ghost var finalBlockStart: int := |s| - 4; ghost var prefix: seq<char>, suffix: seq<char> := s[..finalBlockStart], s[finalBlockStart..]; (Is1Padding(suffix) ==> |b| % 3 == 2) && (Is2Padding(suffix) ==> |b| % 3 == 1) && (!Is1Padding(suffix) && !Is2Padding(suffix) ==> |b| % 3 == 0)
    decreases s, b
  {
    if 4 <= |s| {
      ghost var finalBlockStart := |s| - 4;
      ghost var prefix, suffix := s[..finalBlockStart], s[finalBlockStart..];
      if s == [] {
      } else if Is1Padding(suffix) {
        assert !Is2Padding(suffix);
        assert |prefix| % 4 == 0;
        ghost var x, y := DecodeUnpadded(prefix), Decode1Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 2;
        Mod3(|x| / 3, |y|, |b|);
      } else if Is2Padding(suffix) {
        ghost var x, y := DecodeUnpadded(prefix), Decode2Padding(suffix);
        assert b == x + y;
        assert |x| == |x| / 3 * 3 && |y| == 1;
        Mod3(|x| / 3, |y|, |b|);
      } else {
        assert b == DecodeUnpadded(s);
      }
    }
  }

  lemma Mod3(x: nat, k: nat, n: nat)
    requires 0 <= k < 3 && n == 3 * x + k
    ensures n % 3 == k
    decreases x, k, n
  {
  }

  function method Decode(s: seq<char>): (b: Result<seq<uint8>, string>)
    ensures IsBase64String(s) ==> b.Success?
    ensures !IsBase64String(s) ==> b.Failure?
    decreases s
  {
    if IsBase64String(s) then
      Success(DecodeValid(s))
    else
      Failure("The encoding is malformed")
  }

  predicate StringIs7Bit(s: string)
    decreases s
  {
    forall i: int {:trigger s[i]} :: 
      0 <= i < |s| ==>
        s[i] < 128 as char
  }

  lemma ConcatMod4Sequences<T>(s: seq<T>, t: seq<T>)
    requires |s| % 4 == 0
    requires |t| % 4 == 0
    ensures |s + t| % 4 == 0
    decreases s, t
  {
  }

  function method {:vcs_split_on_every_assert} Encode(b: seq<uint8>): (s: seq<char>)
    ensures StringIs7Bit(s)
    ensures |s| % 4 == 0
    ensures IsBase64String(s)
    decreases b
  {
    SequenceIsSafeBecauseItIsInMemory(b);
    var size: uint64 := |b| as uint64;
    var mod: BoundedInts.uint64 := size % 3;
    if mod == 0 then
      var s: seq<char> := EncodeUnpadded(b);
      assert |s| % 4 == 0;
      s
    else if mod == 1 then
      assert |b| >= 1;
      var s1: seq<char>, s2: seq<char> := EncodeUnpadded(b[..size - 1]), Encode2Padding(b[size - 1..]);
      ConcatMod4Sequences(s1, s2);
      var s: seq<char> := s1 + s2;
      assert |s| % 4 == 0;
      s
    else
      assert |b| % 3 == 2; assert |b| >= 2; var s1: seq<char>, s2: seq<char> := EncodeUnpadded(b[..size - 2]), Encode1Padding(b[size - 2..]); ConcatMod4Sequences(s1, s2); var s: seq<char> := s1 + s2; assert |s| % 4 == 0; s
  }

  lemma EncodeLengthExact(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4)
    decreases b
  {
    ghost var s := Encode(b);
    if |b| % 3 == 0 {
      assert s == EncodeUnpadded(b);
      assert |s| == |b| / 3 * 4;
    } else if |b| % 3 == 1 {
      assert s == EncodeUnpadded(b[..|b| - 1]) + Encode2Padding(b[|b| - 1..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 1])| + |Encode2Padding(b[|b| - 1..])|;
      ==
        {
          assert |Encode2Padding(b[|b| - 1..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 1])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 1])| == |b[..|b| - 1]| / 3 * 4;
        }
        |b[..|b| - 1]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 1]| == |b| - 1;
        }
        (|b| - 1) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 1) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
    } else {
      assert s == EncodeUnpadded(b[..|b| - 2]) + Encode1Padding(b[|b| - 2..]);
      calc {
        |s|;
      ==
        |EncodeUnpadded(b[..|b| - 2])| + |Encode1Padding(b[|b| - 2..])|;
      ==
        {
          assert |Encode1Padding(b[|b| - 2..])| == 4;
        }
        |EncodeUnpadded(b[..|b| - 2])| + 4;
      ==
        {
          assert |EncodeUnpadded(b[..|b| - 2])| == |b[..|b| - 2]| / 3 * 4;
        }
        |b[..|b| - 2]| / 3 * 4 + 4;
      ==
        {
          assert |b[..|b| - 2]| == |b| - 2;
        }
        (|b| - 2) / 3 * 4 + 4;
      ==
        {
          assert (|b| - 2) / 3 == |b| / 3;
        }
        |b| / 3 * 4 + 4;
      }
      assert ghost var s: seq<char> := Encode(b); (|b| % 3 == 0 ==> |s| == |b| / 3 * 4) && (|b| % 3 != 0 ==> |s| == |b| / 3 * 4 + 4);
    }
  }

  lemma EncodeLengthBound(b: seq<uint8>)
    ensures ghost var s: seq<char> := Encode(b); |s| <= |b| / 3 * 4 + 4
    decreases b
  {
    EncodeLengthExact(b);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  newtype index = x: int
    | 0 <= x < 64

  newtype uint24 = x: int
    | 0 <= x < 16777216
}

module Actions {
  method DeterministicMap<A, R>(action: DeterministicAction<A, R>, s: seq<A>) returns (res: seq<R>)
    ensures |s| == |res|
    ensures forall i: int {:trigger res[i]} {:trigger s[i]} :: true && 0 <= i < |s| ==> action.Ensures(s[i], res[i])
    decreases action, s
  {
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| == |rs|
      invariant forall j: BoundedInts.uint64 {:trigger rs[j]} {:trigger s[j]} :: true && 0 <= j < i ==> action.Ensures(s[j], rs[j])
    {
      var r := action.Invoke(s[i]);
      rs := rs + [r];
    }
    return rs;
  }

  method DeterministicMapWithResult<A, R, E>(action: DeterministicActionWithResult<A, R, E>, s: seq<A>) returns (res: Result<seq<R>, E>)
    ensures res.Success? ==> |s| == |res.value|
    ensures res.Success? ==> forall i: int {:trigger res.value[i]} {:trigger s[i]} :: true && 0 <= i < |s| ==> action.Ensures(s[i], Success(res.value[i]))
    decreases action, s
  {
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| == |rs|
      invariant forall j: BoundedInts.uint64 {:trigger rs[j]} {:trigger s[j]} :: true && 0 <= j < i ==> action.Ensures(s[j], Success(rs[j]))
    {
      var r :- action.Invoke(s[i]);
      rs := rs + [r];
    }
    return Success(rs);
  }

  method DeterministicFlatMap<A, R>(action: DeterministicAction<A, seq<R>>, s: seq<A>) returns (res: seq<R>)
    ensures forall i: A {:trigger i in s} :: i in s ==> exists fm: seq<R> {:trigger action.Ensures(i, fm)} :: action.Ensures(i, fm) && forall k: R {:trigger k in res} {:trigger k in fm} | k in fm :: k in res
    decreases action, s
  {
    ghost var parts := [];
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| == |parts|
      invariant forall j: BoundedInts.uint64 {:trigger parts[j]} {:trigger s[j]} :: (true && 0 <= j < i ==> action.Ensures(s[j], parts[j])) && (true && 0 <= j < i ==> forall b: R {:trigger b in rs} {:trigger b in parts[j]} | b in parts[j] :: b in rs)
    {
      var r := action.Invoke(s[i]);
      rs := rs + r;
      parts := parts + [r];
    }
    return rs;
  }

  method DeterministicFlatMapWithResult<A, R, E>(action: DeterministicActionWithResult<A, seq<R>, E>, s: seq<A>)
      returns (res: Result<seq<R>, E>, ghost parts: seq<seq<R>>)
    ensures res.Success? ==> |s| == |parts| && res.value == Flatten(parts) && forall i: int {:trigger parts[i]} {:trigger s[i]} :: (0 <= i < |s| ==> action.Ensures(s[i], Success(parts[i]))) && (0 <= i < |s| ==> multiset(parts[i]) <= multiset(res.value))
    decreases action, s
  {
    parts := [];
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| == |parts|
      invariant forall j: BoundedInts.uint64 {:trigger parts[j]} {:trigger s[j]} :: (true && 0 <= j < i ==> action.Ensures(s[j], Success(parts[j]))) && (true && 0 <= j < i ==> multiset(parts[j]) <= multiset(rs))
      invariant Flatten(parts) == rs
    {
      var r :- action.Invoke(s[i]);
      rs := rs + r;
      LemmaFlattenConcat(parts, [r]);
      parts := parts + [r];
    }
    return Success(rs), parts;
  }

  method Filter<A>(action: DeterministicAction<A, bool>, s: seq<A>) returns (res: seq<A>)
    ensures |s| >= |res|
    ensures forall j: A {:trigger action.Ensures(j, true)} {:trigger j in s} {:trigger j in res} :: (j in res ==> j in s) && (j in res ==> action.Ensures(j, true))
    decreases action, s
  {
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| >= |rs|
      invariant forall j: A {:trigger action.Ensures(j, true)} {:trigger j in s} {:trigger j in rs} :: (j in rs ==> j in s) && (j in rs ==> action.Ensures(j, true))
    {
      var r := action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return rs;
  }

  method FilterWithResult<A, E>(action: DeterministicActionWithResult<A, bool, E>, s: seq<A>) returns (res: Result<seq<A>, E>)
    ensures res.Success? ==> |s| >= |res.value| && forall j: A {:trigger action.Ensures(j, Success(true))} {:trigger j in s} {:trigger j in res.value} :: (j in res.value ==> j in s) && (j in res.value ==> action.Ensures(j, Success(true)))
    decreases action, s
  {
    var rs := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| >= |rs|
      invariant forall j: A {:trigger action.Ensures(j, Success(true))} {:trigger j in s} {:trigger j in rs} :: (j in rs ==> j in s) && (j in rs ==> action.Ensures(j, Success(true)))
    {
      var r :- action.Invoke(s[i]);
      if r {
        rs := rs + [s[i]];
      }
    }
    return Success(rs);
  }

  method ReduceToSuccess<A, B, E>(action: ActionWithResult<A, B, E>, s: seq<A>)
      returns (res: Result<B, seq<E>>, ghost attemptsState: seq<ActionInvoke<A, Result<B, E>>>)
    requires 0 < |s|
    requires action.Invariant()
    requires forall i: A {:trigger action.Requires(i)} {:trigger i in s} | i in s :: action.Requires(i)
    modifies action.Modifies
    ensures 0 < |attemptsState| <= |s|
    ensures forall i: int {:trigger s[i]} {:trigger attemptsState[i]} | 0 <= i < |attemptsState| :: attemptsState[i].input == s[i]
    ensures action.Invariant()
    ensures if res.Success? then Last(attemptsState).output.Success? && Last(attemptsState).output.value == res.value && action.Ensures(Last(attemptsState).input, Last(attemptsState).output, DropLast(attemptsState)) && forall i: int {:trigger attemptsState[i]} | 0 <= i < |DropLast(attemptsState)| :: attemptsState[i].output.Failure? else |attemptsState| == |s| && forall i: int {:trigger attemptsState[i]} | 0 <= i < |attemptsState| :: attemptsState[i].output.Failure?
    decreases action.Modifies
  {
    var attemptedResults := [];
    attemptsState := [];
    SequenceIsSafeBecauseItIsInMemory(s);
    for i: uint64 := 0 to |s| as uint64
      invariant |s[..i]| == |attemptsState| == |attemptedResults|
      invariant forall j: int {:trigger attemptedResults[j]} {:trigger s[j]} {:trigger attemptsState[j]} | 0 <= j < |attemptsState| :: attemptsState[j].input == s[j] && attemptsState[j].output.Failure? && attemptedResults[j] == attemptsState[j].output
      invariant action.Invariant()
    {
      var attempt := action.Invoke(s[i], attemptsState);
      attemptsState := attemptsState + [ActionInvoke(s[i], attempt)];
      attemptedResults := attemptedResults + [attempt];
      if attempt.Success? {
        return Success(attempt.value), attemptsState;
      }
    }
    res := Failure(Seq.Map(pluckErrors, attemptedResults));
  }

  function method pluckErrors<B, E>(r: Result<B, E>): (e: E)
    requires r.Failure?
    ensures r.error == e
    decreases r
  {
    r.error
  }

  import opened Wrappers

  import opened Seq

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  datatype ActionInvoke<A, R> = ActionInvoke(input: A, output: R)

  trait {:termination false} Action<A, R> {
    method Invoke(a: A, ghost attemptsState: seq<ActionInvoke<A, R>>) returns (r: R)
      requires Invariant()
      requires Requires(a)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(a, r, attemptsState)
      decreases Modifies

    predicate Invariant()
      reads Modifies
      decreases Modifies

    predicate Requires(a: A)

    predicate Ensures(a: A, r: R, attemptsState: seq<ActionInvoke<A, R>>)
      reads Modifies
      decreases Modifies

    ghost const Modifies: set<object>
  }

  trait {:termination false} ActionWithResult<A, R, E> extends Action<A, Result<R, E>> {
    method Invoke(a: A, ghost attemptsState: seq<ActionInvoke<A, Result<R, E>>>) returns (r: Result<R, E>)
      requires Invariant()
      requires Requires(a)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(a, r, attemptsState)
      decreases Modifies
  }

  trait {:termination false} DeterministicAction<A, R> {
    method Invoke(a: A) returns (r: R)
      ensures Ensures(a, r)

    predicate Ensures(a: A, r: R)
  }

  trait {:termination false} DeterministicActionWithResult<A, R, E> extends DeterministicAction<A, Result<R, E>> {
    method Invoke(a: A) returns (r: Result<R, E>)
      ensures Ensures(a, r)
  }
}

module {:extern "DafnyLibraries"} {:options "-functionSyntax:4"} DafnyLibraries {

  import opened Wrappers
  trait {:termination false} MutableMapTrait<K(==), V(==)> {
    function method content(): map<K, V>
      reads this
      decreases {this}

    method Put(k: K, v: V)
      modifies this
      ensures this.content() == old(this.content())[k := v]
      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}
      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}

    function method Keys(): (keys: set<K>)
      reads this
      ensures keys == this.content().Keys
      decreases {this}

    predicate method HasKey(k: K)
      reads this
      ensures HasKey(k) <==> k in this.content().Keys
      decreases {this}

    function method Values(): (values: set<V>)
      reads this
      ensures values == this.content().Values
      decreases {this}

    function method Items(): (items: set<(K, V)>)
      reads this
      ensures items == this.content().Items
      ensures items == set k: K {:trigger this.content()[k]} {:trigger k in this.content().Keys} | k in this.content().Keys :: (k, this.content()[k])
      decreases {this}

    function method Select(k: K): (v: V)
      requires this.HasKey(k)
      reads this
      ensures v in this.content().Values
      ensures this.content()[k] == v
      decreases {this}

    method Remove(k: K)
      modifies this
      ensures this.content() == old(this.content()) - {k}
      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values

    function method Size(): (size: int)
      reads this
      ensures size == |this.content().Items|
      decreases {this}
  }

  class {:extern} MutableMap<K(==), V(==)> extends MutableMapTrait<K, V> {
    constructor {:extern} ()
      ensures this.content() == map[]

    function method {:extern} content(): map<K, V>
      reads this
      decreases {this}

    method {:extern} Put(k: K, v: V)
      modifies this
      ensures this.content() == old(this.content())[k := v]
      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}
      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}

    function method {:extern} Keys(): (keys: set<K>)
      reads this
      ensures keys == this.content().Keys
      decreases {this}

    predicate method {:extern} HasKey(k: K)
      reads this
      ensures HasKey(k) <==> k in this.content().Keys
      decreases {this}

    function method {:extern} Values(): (values: set<V>)
      reads this
      ensures values == this.content().Values
      decreases {this}

    function method {:extern} Items(): (items: set<(K, V)>)
      reads this
      ensures items == this.content().Items
      ensures items == set k: K {:trigger this.content()[k]} {:trigger k in this.content().Keys} | k in this.content().Keys :: (k, this.content()[k])
      decreases {this}

    function method {:extern} Select(k: K): (v: V)
      requires this.HasKey(k)
      reads this
      ensures v in this.content().Values
      ensures this.content()[k] == v
      decreases {this}

    method {:extern} Remove(k: K)
      modifies this
      ensures this.content() == old(this.content()) - {k}
      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values

    function method {:extern} Size(): (size: int)
      reads this
      ensures size == |this.content().Items|
      decreases {this}
  }
}

module {:extern "AesKdfCtr"} AesKdfCtr {
  function method {:extern "AesKdfCtrStream"} Stream(nonce: seq<uint8>, key: seq<uint8>, length: uint32): (res: Result<seq<uint8>, Types.OpaqueError>)
    requires |nonce| == 16
    requires |key| == 32
    ensures res.Success? ==> |res.value| == length as nat
    decreases nonce, key, length

  function method CreateStreamSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateStreamFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyPrimitivesTypes
}

module {:extern "Signature"} Signature {
  predicate {:axiom} IsSigned(key: seq<uint8>, msg: seq<uint8>, signature: seq<uint8>)
    decreases key, msg, signature

  function method SignatureLength(signatureAlgorithm: Types.ECDSASignatureAlgorithm): uint16
    decreases signatureAlgorithm
  {
    match signatureAlgorithm
    case ECDSA_P256() =>
      71
    case ECDSA_P384() =>
      103
  }

  function method FieldSize(signatureAlgorithm: Types.ECDSASignatureAlgorithm): uint64
    decreases signatureAlgorithm
  {
    match signatureAlgorithm
    case ECDSA_P256() =>
      assert 1 + (256 + 7) / 8 == 33; 33
    case ECDSA_P384() =>
      assert 1 + (384 + 7) / 8 == 49;
      49
  }

  predicate {:axiom} IsValidSignatureKeyPair(sigKeyPair: SignatureKeyPair)
    decreases sigKeyPair

  method KeyGen(input: Types.GenerateECDSASignatureKeyInput) returns (res: Result<Types.GenerateECDSASignatureKeyOutput, Types.Error>)
    ensures match res case Success(sigKeyPair) => true && |sigKeyPair.verificationKey| == FieldSize(input.signatureAlgorithm) as nat case Failure(_ /* _v0 */) => true
    decreases input
  {
    var sigKeyPair :- ExternKeyGen(input.signatureAlgorithm);
    SequenceIsSafeBecauseItIsInMemory(sigKeyPair.verificationKey);
    :- Need(|sigKeyPair.verificationKey| as uint64 == FieldSize(input.signatureAlgorithm) as uint64, Types.AwsCryptographicPrimitivesError(message := "Incorrect verification-key length from ExternKeyGen."));
    return Success(Types.GenerateECDSASignatureKeyOutput(signatureAlgorithm := input.signatureAlgorithm, verificationKey := sigKeyPair.verificationKey, signingKey := sigKeyPair.signingKey));
  }

  method {:extern "Signature.ECDSA", "ExternKeyGen"} {:axiom} ExternKeyGen(s: Types.ECDSASignatureAlgorithm) returns (res: Result<SignatureKeyPair, Types.Error>)
    ensures res.Success? ==> IsValidSignatureKeyPair(res.value)
    decreases s

  method {:extern "Signature.ECDSA", "Sign"} {:axiom} Sign(s: Types.ECDSASignatureAlgorithm, key: seq<uint8>, msg: seq<uint8>)
      returns (sig: Result<seq<uint8>, Types.Error>)
    ensures sig.Success? ==> IsSigned(key, msg, sig.value)
    decreases s, key, msg

  function method {:extern "Signature.ECDSA", "Verify"} Verify(s: Types.ECDSASignatureAlgorithm, key: seq<uint8>, msg: seq<uint8>, sig: seq<uint8>): (res: Result<bool, Types.Error>)
    decreases s, key, msg, sig

  function method CreateExternKeyGenSuccess(output: SignatureKeyPair): Result<SignatureKeyPair, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateExternKeyGenFailure(error: Types.Error): Result<SignatureKeyPair, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateSignSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateSignFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateVerifySuccess(b: bool): Result<bool, Types.Error>
    decreases b
  {
    Success(b)
  }

  function method CreateVerifyFailure(error: Types.Error): Result<bool, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes

  datatype SignatureKeyPair = SignatureKeyPair(verificationKey: seq<uint8>, signingKey: seq<uint8>)
}

module {:extern "RSAEncryption"} RSAEncryption {
  method GenerateKeyPair(lengthBits: Types.RSAModulusLengthBitsToGenerate) returns (publicKey: Types.RSAPublicKey, privateKey: Types.RSAPrivateKey)
    decreases lengthBits
  {
    var pemPublic, pemPrivate := GenerateKeyPairExtern(lengthBits);
    privateKey := Types.RSAPrivateKey(pem := pemPrivate, lengthBits := lengthBits);
    publicKey := Types.RSAPublicKey(pem := pemPublic, lengthBits := lengthBits);
  }

  function method GetRSAKeyModulusLength(publicKey: seq<uint8>): (res: Result<Types.RSAModulusLengthBits, Types.Error>)
    decreases publicKey
  {
    var length: uint32 :- GetRSAKeyModulusLengthExtern(publicKey); :- Need(81 <= length as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "Unsupported length for RSA modulus.")); Success(length as int32)
  }

  method Decrypt(input: Types.RSADecryptInput) returns (output: Result<seq<uint8>, Types.Error>)
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.privateKey);
    SequenceIsSafeBecauseItIsInMemory(input.cipherText);
    :- Need(0 < |input.privateKey| as uint64 && 0 < |input.cipherText| as uint64, Types.AwsCryptographicPrimitivesError(message := ""));
    output := DecryptExtern(input.padding, input.privateKey, input.cipherText);
  }

  method Encrypt(input: Types.RSAEncryptInput) returns (output: Result<seq<uint8>, Types.Error>)
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.publicKey);
    SequenceIsSafeBecauseItIsInMemory(input.plaintext);
    :- Need(0 < |input.publicKey| as uint64 && 0 < |input.plaintext| as uint64, Types.AwsCryptographicPrimitivesError(message := ""));
    output := EncryptExtern(input.padding, input.publicKey, input.plaintext);
  }

  method {:extern "RSAEncryption.RSA", "GenerateKeyPairExtern"} {:axiom} GenerateKeyPairExtern(lengthBits: Types.RSAModulusLengthBitsToGenerate) returns (publicKey: seq<uint8>, privateKey: seq<uint8>)
    ensures |publicKey| > 0
    ensures |privateKey| > 0
    decreases lengthBits

  function method {:extern "RSAEncryption.RSA", "GetRSAKeyModulusLengthExtern"} {:axiom} GetRSAKeyModulusLengthExtern(publicKey: seq<uint8>): (length: Result<uint32, Types.Error>)
    decreases publicKey

  method {:extern "RSAEncryption.RSA", "DecryptExtern"} DecryptExtern(padding: Types.RSAPaddingMode, privateKey: seq<uint8>, cipherText: seq<uint8>)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires |privateKey| > 0
    requires |cipherText| > 0
    decreases padding, privateKey, cipherText

  method {:extern "RSAEncryption.RSA", "EncryptExtern"} EncryptExtern(padding: Types.RSAPaddingMode, publicKey: seq<uint8>, plaintextData: seq<uint8>)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires |publicKey| > 0
    requires |plaintextData| > 0
    decreases padding, publicKey, plaintextData

  function method CreateGetRSAKeyModulusLengthExternSuccess(output: uint32): Result<uint32, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateGetRSAKeyModulusLengthExternFailure(error: Types.Error): Result<uint32, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateBytesSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateBytesFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes
}

module Digest {
  function method Length(digestAlgorithm: Types.DigestAlgorithm): uint64
    decreases digestAlgorithm
  {
    match digestAlgorithm
    case SHA_512() =>
      64
    case SHA_384() =>
      48
    case SHA_256() =>
      32
  }

  method Digest(input: Types.DigestInput) returns (res: Result<seq<uint8>, Types.Error>)
    ensures res.Success? ==> |res.value| == Length(input.digestAlgorithm) as nat
    decreases input
  {
    var DigestInput(digestAlgorithm, message) := input;
    var value :- ExternDigest.Digest(digestAlgorithm, message);
    SequenceIsSafeBecauseItIsInMemory(value);
    :- Need(|value| as uint64 == Length(digestAlgorithm), Types.AwsCryptographicPrimitivesError(message := "Incorrect length digest from ExternDigest."));
    return Success(value);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes

  import ExternDigest
}

module {:extern "ExternDigest"} ExternDigest {
  method {:extern} Digest(alg: Types.DigestAlgorithm, msg: seq<uint8>) returns (res: Result<seq<uint8>, Types.Error>)
    decreases alg, msg

  function method CreateDigestSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateDigestFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyPrimitivesTypes
}

module {:extern "AESEncryption"} AESEncryption {
  predicate {:axiom} PlaintextDecryptedWithAAD(plaintext: seq<uint8>, aad: seq<uint8>)
    decreases plaintext, aad

  predicate {:axiom} EncryptionOutputEncryptedWithAAD(output: Types.AESEncryptOutput, aad: seq<uint8>)
    decreases output, aad

  predicate {:axiom} CiphertextGeneratedWithPlaintext(ciphertext: seq<uint8>, plaintext: seq<uint8>)
    decreases ciphertext, plaintext

  predicate {:axiom} EncryptedWithKey(ciphertext: seq<uint8>, key: seq<uint8>)
    decreases ciphertext, key

  predicate {:axiom} DecryptedWithKey(key: seq<uint8>, plaintext: seq<uint8>)
    decreases key, plaintext

  function method EncryptionOutputFromByteSeq(s: seq<uint8>, encAlg: Types.AES_GCM): (encArt: Types.AESEncryptOutput)
    requires 0 < encAlg.tagLength
    requires encAlg.tagLength as nat <= |s|
    ensures |encArt.cipherText + encArt.authTag| == |s|
    ensures |encArt.authTag| == encAlg.tagLength as int
    decreases s, encAlg
  {
    assert |s| - encAlg.tagLength as int <= |s|;
    SequenceIsSafeBecauseItIsInMemory(s);
    var pivot_point: BoundedInts.uint64 := |s| as uint64 - encAlg.tagLength as uint64;
    var cipherText: seq<BoundedInts.uint8> := s[..pivot_point];
    var authTag: seq<BoundedInts.uint8> := s[pivot_point..];
    Types.AESEncryptOutput(cipherText := cipherText, authTag := authTag)
  }

  method {:extern "AESEncryption.AES_GCM", "AESEncryptExtern"} {:axiom} AESEncryptExtern(encAlg: Types.AES_GCM, iv: seq<uint8>, key: seq<uint8>, msg: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<Types.AESEncryptOutput, Types.OpaqueError>)
    requires |iv| == encAlg.ivLength as int
    requires |key| == encAlg.keyLength as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, key)
    decreases encAlg, iv, key, msg, aad

  method AESEncrypt(input: Types.AESEncryptInput) returns (res: Result<Types.AESEncryptOutput, Types.Error>)
    ensures res.Success? ==> |res.value.cipherText| == |input.msg| && |res.value.authTag| == input.encAlg.tagLength as int
    ensures res.Success? ==> EncryptionOutputEncryptedWithAAD(res.value, input.aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(res.value.cipherText, input.msg)
    ensures res.Success? ==> EncryptedWithKey(res.value.cipherText, input.key)
    ensures res.Success? ==> |res.value.authTag| == input.encAlg.tagLength as nat
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.iv);
    SequenceIsSafeBecauseItIsInMemory(input.key);
    :- Need(|input.iv| as uint64 == input.encAlg.ivLength as uint64 && |input.key| as uint64 == input.encAlg.keyLength as uint64, Types.AwsCryptographicPrimitivesError(message := "Request does not match algorithm."));
    var AESEncryptInput(encAlg, iv, key, msg, aad) := input;
    var value :- AESEncryptExtern(encAlg, iv, key, msg, aad);
    SequenceIsSafeBecauseItIsInMemory(value.cipherText);
    SequenceIsSafeBecauseItIsInMemory(value.authTag);
    SequenceIsSafeBecauseItIsInMemory(msg);
    :- Need(|value.cipherText| as uint64 == |msg| as uint64, Types.AwsCryptographicPrimitivesError(message := "AESEncrypt did not return cipherText of expected length"));
    :- Need(|value.authTag| as uint64 == encAlg.tagLength as uint64, Types.AwsCryptographicPrimitivesError(message := "AESEncryption did not return valid tag"));
    return Success(value);
  }

  method {:extern "AESEncryption.AES_GCM", "AESDecryptExtern"} {:axiom} AESDecryptExtern(encAlg: Types.AES_GCM, key: seq<uint8>, cipherTxt: seq<uint8>, authTag: seq<uint8>, iv: seq<uint8>, aad: seq<uint8>)
      returns (res: Result<seq<uint8>, Types.OpaqueError>)
    requires |key| == encAlg.keyLength as int
    requires |iv| == encAlg.ivLength as int
    requires |authTag| == encAlg.tagLength as int
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(key, res.value)
    decreases encAlg, key, cipherTxt, authTag, iv, aad

  method AESDecrypt(input: Types.AESDecryptInput) returns (res: Result<seq<uint8>, Types.Error>)
    ensures res.Success? ==> |res.value| == |input.cipherTxt|
    ensures res.Success? ==> PlaintextDecryptedWithAAD(res.value, input.aad)
    ensures res.Success? ==> CiphertextGeneratedWithPlaintext(input.cipherTxt, res.value)
    ensures res.Success? ==> DecryptedWithKey(input.key, res.value)
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.iv);
    SequenceIsSafeBecauseItIsInMemory(input.key);
    SequenceIsSafeBecauseItIsInMemory(input.authTag);
    :- Need(|input.key| as uint64 == input.encAlg.keyLength as uint64 && |input.iv| as uint64 == input.encAlg.ivLength as uint64 && |input.authTag| as uint64 == input.encAlg.tagLength as uint64, Types.AwsCryptographicPrimitivesError(message := "Request does not match algorithm."));
    var AESDecryptInput(encAlg, key, cipherTxt, authTag, iv, aad) := input;
    var value :- AESDecryptExtern(encAlg, key, cipherTxt, authTag, iv, aad);
    SequenceIsSafeBecauseItIsInMemory(value);
    SequenceIsSafeBecauseItIsInMemory(cipherTxt);
    :- Need(|cipherTxt| as uint64 == |value| as uint64, Types.AwsCryptographicPrimitivesError(message := "AESDecrypt did not return plaintext of expected length"));
    return Success(value);
  }

  function method CreateAESEncryptExternSuccess(output: Types.AESEncryptOutput): Result<Types.AESEncryptOutput, Types.OpaqueError>
    decreases output
  {
    Success(output)
  }

  function method CreateAESEncryptExternFailure(error: Types.OpaqueError): Result<Types.AESEncryptOutput, Types.OpaqueError>
    decreases error
  {
    Failure(error)
  }

  function method CreateAESDecryptExternSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.OpaqueError>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateAESDecryptExternFailure(error: Types.OpaqueError): Result<seq<uint8>, Types.OpaqueError>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes
}

module KdfCtr {
  const SEPARATION_INDICATOR: seq<uint8> := [0]
  const COUNTER_START_VALUE: uint32 := 1

  method KdfCounterMode(input: Types.KdfCtrInput) returns (output: Result<seq<uint8>, Types.Error>)
    ensures output.Success? ==> |output.value| == input.expectedLength as nat
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.ikm);
    OptionalSequenceIsSafeBecauseItIsInMemory(input.nonce);
    :- Need((input.digestAlgorithm == Types.DigestAlgorithm.SHA_256 || input.digestAlgorithm == Types.DigestAlgorithm.SHA_384) && (|input.ikm| as uint64 == 32 || |input.ikm| as uint64 == 48 || |input.ikm| as uint64 == 66) && input.nonce.Some? && (|input.nonce.value| as uint64 == 16 || |input.nonce.value| as uint64 == 32) && (input.expectedLength == 32 || input.expectedLength == 64) && 0 < (input.expectedLength * 8) as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "Kdf in Counter Mode input is invalid."));
    var ikm := input.ikm;
    var label_ := input.purpose.UnwrapOr([]);
    var info := input.nonce.UnwrapOr([]);
    var okm := [];
    var internalLength: uint32 := (4 + |SEPARATION_INDICATOR| as uint64 + 4) as uint32;
    SequenceIsSafeBecauseItIsInMemory(label_);
    SequenceIsSafeBecauseItIsInMemory(info);
    :- Need(true && Add3(internalLength as uint64, |label_| as uint64, |info| as uint64) < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "Input Length exceeds INT32_MAX_LIMIT"));
    var lengthBits: seq<uint8> := UInt.UInt32ToSeq((input.expectedLength * 8) as uint32);
    var explicitInfo := label_ + SEPARATION_INDICATOR + info + lengthBits;
    SequenceIsSafeBecauseItIsInMemory(explicitInfo);
    :- Need(4 + |explicitInfo| as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "PRF input length exceeds INT32_MAX_LIMIT."));
    okm :- RawDerive(ikm, explicitInfo, input.expectedLength, 0, input.digestAlgorithm);
    return Success(okm);
  }

  method RawDerive(ikm: seq<uint8>, explicitInfo: seq<uint8>, length: int32, offset: int32, digestAlgorithm: Types.DigestAlgorithm)
      returns (output: Result<seq<uint8>, Types.Error>)
    requires |ikm| >= 32 && length > 0 && 4 + |explicitInfo| < INT32_MAX_LIMIT && (digestAlgorithm == Types.DigestAlgorithm.SHA_256 || digestAlgorithm == Types.DigestAlgorithm.SHA_384) && length as int + Digest.Length(Types.DigestAlgorithm.SHA_256) as int < INT32_MAX_LIMIT - 1 && length as int + Digest.Length(Types.DigestAlgorithm.SHA_384) as int < INT32_MAX_LIMIT - 1
    ensures output.Success? ==> |output.value| == length as int
    decreases ikm, explicitInfo, length, offset, digestAlgorithm
  {
    var hmac :- HMAC.HMac.Build(digestAlgorithm);
    hmac.Init(key := ikm);
    var macLengthBytes := Digest.Length(digestAlgorithm) as int32;
    var iterations := (length + macLengthBytes - 1) / macLengthBytes;
    var buffer := [];
    var i: seq<uint8> := UInt.UInt32ToSeq(COUNTER_START_VALUE);
    for iteration: uint64 := 1 to Add(iterations as uint64, 1)
      invariant |i| == 4
      invariant hmac.GetKey() == ikm
    {
      hmac.Update(i);
      hmac.Update(explicitInfo);
      var tmp := hmac.GetResult();
      buffer := buffer + tmp;
      i :- Increment(i);
    }
    SequenceIsSafeBecauseItIsInMemory(buffer);
    :- Need(|buffer| as uint64 >= length as uint64, Types.AwsCryptographicPrimitivesError(message := "Failed to derive key of requested length"));
    return Success(buffer[..length]);
  }

  function method Increment(x: seq<uint8>): (ret: Result<seq<uint8>, Types.Error>)
    requires |x| == 4
    ensures ret.Success? ==> |ret.value| == 4
    decreases x
  {
    if x[3 as uint32] < 255 then
      Success([x[0 as uint32], x[1 as uint32], x[2 as uint32], x[3 as uint32] + 1])
    else if x[2 as uint32] < 255 then
      Success([x[0 as uint32], x[1 as uint32], x[2 as uint32] + 1, 0])
    else if x[1 as uint32] < 255 then
      Success([x[0 as uint32], x[1 as uint32] + 1, 0, 0])
    else if x[0 as uint32] < 255 then
      Success([x[0 as uint32] + 1, 0, 0, 0])
    else
      Failure(Types.AwsCryptographicPrimitivesError(message := "Unable to derive key material; may have exceeded limit."))
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import UTF8

  import Types = AwsCryptographyPrimitivesTypes

  import HMAC

  import Digest
}

module {:options "-functionSyntax:4"} {:extern "HMAC"} HMAC {
  function method {:extern "Digest"} {:axiom} Digest(input: Types.HMacInput): (output: Result<seq<uint8>, Types.Error>)
    ensures output.Success? ==> |output.value| == HashDigest.Length(input.digestAlgorithm) as nat
    decreases input

  function method CreateHMacSuccess(hmac: HMac): Result<HMac, Types.Error>
    decreases hmac
  {
    Success(hmac)
  }

  function method CreateHMacFailure(error: Types.Error): Result<HMac, Types.Error>
    decreases error
  {
    Failure(error)
  }

  function method CreateDigestSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateDigestFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyPrimitivesTypes

  import HashDigest = Digest

  class {:extern "HMac"} HMac {
    function {:extern} GetKey(): seq<uint8>
      reads this
      decreases {this}

    function {:extern} GetDigest(): Types.DigestAlgorithm
      reads this
      decreases {this}

    function {:extern} GetInputSoFar(): seq<uint8>
      reads this
      decreases {this}

    static method {:extern} {:axiom} Build(digest: Types.DigestAlgorithm) returns (output: Result<HMac, Types.Error>)
      ensures output.Success? ==> output.value.GetDigest() == digest && output.value.GetInputSoFar() == [] && fresh(output.value)
      decreases digest

    method {:extern "Init"} {:axiom} Init(key: seq<uint8>)
      requires 0 < |key|
      modifies this
      ensures this.GetKey() == key
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetInputSoFar() == []
      decreases key

    method {:extern "BlockUpdate"} {:axiom} Update(input: seq<uint8>)
      requires |this.GetKey()| > 0
      requires |input| < INT32_MAX_LIMIT
      modifies this
      ensures this.GetInputSoFar() == old(this.GetInputSoFar()) + input
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      decreases input

    method {:extern "GetResult"} {:axiom} GetResult() returns (s: seq<uint8>)
      requires |this.GetKey()| > 0
      modifies this
      ensures |s| == HashDigest.Length(this.GetDigest()) as nat
      ensures this.GetInputSoFar() == []
      ensures this.GetDigest() == old(this.GetDigest())
      ensures this.GetKey() == old(this.GetKey())
      ensures this.HashSignature(old(this.GetInputSoFar()), s)

    predicate {:axiom} HashSignature(message: seq<uint8>, s: seq<uint8>)
      decreases message, s
  }
}

module WrappedHKDF {
  method Extract(input: Types.HkdfExtractInput) returns (output: Result<seq<uint8>, Types.Error>)
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.ikm);
    OptionalSequenceIsSafeBecauseItIsInMemory(input.salt);
    :- Need((input.salt.None? || |input.salt.value| as uint64 != 0) && |input.ikm| as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "HKDF Extract needs a salt and reasonable ikm."));
    var HkdfExtractInput(digestAlgorithm, salt, ikm) := input;
    var hmac :- HMAC.HMac.Build(digestAlgorithm);
    var prk := HKDF.Extract(hmac, salt.UnwrapOr(StandardLibrary.Fill(0, Digest.Length(digestAlgorithm) as nat)), ikm, digestAlgorithm);
    return Success(prk);
  }

  method Expand(input: Types.HkdfExpandInput) returns (output: Result<seq<uint8>, Types.Error>)
    ensures output.Success? ==> |output.value| == input.expectedLength as nat
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.info);
    SequenceIsSafeBecauseItIsInMemory(input.prk);
    :- Need(1 <= input.expectedLength as uint64 <= 255 * Digest.Length(input.digestAlgorithm) as uint64 && |input.info| as uint64 < INT32_MAX_LIMIT as uint64 && Digest.Length(input.digestAlgorithm) as uint64 == |input.prk| as uint64, Types.AwsCryptographicPrimitivesError(message := "HKDF Expand needs valid input."));
    var HkdfExpandInput(digestAlgorithm, prk, info, expectedLength) := input;
    var hmac :- HMAC.HMac.Build(digestAlgorithm);
    var omk, _ /* _v0 */ := HKDF.Expand(hmac, prk, info, expectedLength as uint64, digestAlgorithm);
    return Success(omk);
  }

  method Hkdf(input: Types.HkdfInput) returns (output: Result<seq<uint8>, Types.Error>)
    ensures output.Success? ==> |output.value| == input.expectedLength as nat
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.ikm);
    SequenceIsSafeBecauseItIsInMemory(input.info);
    OptionalSequenceIsSafeBecauseItIsInMemory(input.salt);
    :- Need(1 <= input.expectedLength as uint64 <= 255 * Digest.Length(input.digestAlgorithm) as uint64 && (input.salt.None? || |input.salt.value| as uint64 != 0) && |input.info| as uint64 < INT32_MAX_LIMIT as uint64 && |input.ikm| as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "Wrapped Hkdf input is invalid."));
    var HkdfInput(digest, salt, ikm, info, expectedLength) := input;
    var okm := HKDF.Hkdf(digest, salt, ikm, info, expectedLength as uint64);
    return Success(okm);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import StandardLibrary

  import Types = AwsCryptographyPrimitivesTypes

  import HMAC

  import HKDF

  import Digest
}

module HKDF {
  method Extract(hmac: HMac, salt: seq<uint8>, ikm: seq<uint8>, ghost digest: Types.DigestAlgorithm)
      returns (prk: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires |salt| != 0
    requires |ikm| < INT32_MAX_LIMIT
    modifies hmac
    ensures Digest.Length(hmac.GetDigest()) as nat == |prk|
    ensures hmac.GetKey() == salt
    ensures hmac.GetDigest() == digest
    decreases hmac, salt, ikm, digest
  {
    hmac.Init(salt);
    hmac.Update(ikm);
    assert hmac.GetInputSoFar() == ikm;
    prk := hmac.GetResult();
    return prk;
  }

  predicate T(hmac: HMac, info: seq<uint8>, n: uint64, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n
  {
    if n == 0 then
      [] == res
    else
      ghost var nMinusOne: BoundedInts.uint64 := n - 1; exists prev1: seq<uint8>, prev2: seq<uint8> {:trigger prev1 + prev2} {:trigger Ti(hmac, info, n, prev2), T(hmac, info, nMinusOne, prev1)} :: T(hmac, info, nMinusOne, prev1) && Ti(hmac, info, n, prev2) && prev1 + prev2 == res
  }

  predicate Ti(hmac: HMac, info: seq<uint8>, n: uint64, res: seq<uint8>)
    requires 0 <= n < 256
    decreases n, 1
  {
    if n == 0 then
      res == []
    else
      exists prev: seq<uint8> {:trigger hmac.HashSignature(prev, res)} {:trigger PreTi(hmac, info, n, prev)} :: PreTi(hmac, info, n, prev) && hmac.HashSignature(prev, res)
  }

  predicate PreTi(hmac: HMac, info: seq<uint8>, n: uint64, res: seq<uint8>)
    requires 1 <= n < 256
    decreases n, 0
  {
    ghost var nMinusOne: BoundedInts.uint64 := n - 1;
    exists prev: seq<uint8> {:trigger prev + info} {:trigger Ti(hmac, info, nMinusOne, prev)} | Ti(hmac, info, nMinusOne, prev) :: 
      res == prev + info + [n as uint8]
  }

  method Expand(hmac: HMac, prk: seq<uint8>, info: seq<uint8>, expectedLength: uint64, digest: Types.DigestAlgorithm)
      returns (okm: seq<uint8>, ghost okmUnabridged: seq<uint8>)
    requires hmac.GetDigest() == digest
    requires 1 <= expectedLength as uint64 <= 255 * Digest.Length(hmac.GetDigest())
    requires |info| < INT32_MAX_LIMIT
    requires Digest.Length(hmac.GetDigest()) as nat == |prk|
    modifies hmac
    ensures |okm| == expectedLength as nat
    ensures hmac.GetKey() == prk
    ensures hmac.GetDigest() == digest
    ensures var n: BoundedInts.uint64 := (Digest.Length(digest) + expectedLength - 1) / Digest.Length(digest); T(hmac, info, n, okmUnabridged) && (|okmUnabridged| <= expectedLength as nat ==> okm == okmUnabridged) && (expectedLength as nat < |okmUnabridged| ==> okm == okmUnabridged[..expectedLength])
    decreases hmac, prk, info, expectedLength, digest
  {
    var hashLength := Digest.Length(digest);
    var n := (hashLength + expectedLength - 1) / hashLength;
    assert 0 <= n < 256;
    hmac.Init(prk);
    var t_prev := [];
    var t_n := t_prev;
    var i := 1;
    while i <= n
      invariant 1 <= i <= n + 1
      invariant |t_prev| == if i == 1 then 0 else hashLength as nat
      invariant hashLength as nat == |prk|
      invariant |t_n| == (i - 1) as nat * hashLength as nat
      invariant hmac.GetKey() == prk
      invariant hmac.GetDigest() == digest
      invariant hmac.GetInputSoFar() == []
      invariant T(hmac, info, i - 1, t_n)
      invariant Ti(hmac, info, i - 1, t_prev)
      decreases n as int - i as int
    {
      hmac.Update(t_prev);
      hmac.Update(info);
      hmac.Update([i as uint8]);
      assert hmac.GetInputSoFar() == t_prev + info + [i as uint8];
      t_prev := hmac.GetResult();
      assert Ti(hmac, info, i, t_prev);
      t_n := t_n + t_prev;
      i := i + 1;
      assert T(hmac, info, i - 1, t_n);
    }
    okm := t_n;
    okmUnabridged := okm;
    assert T(hmac, info, n, okmUnabridged);
    SequenceIsSafeBecauseItIsInMemory(okm);
    if expectedLength < |okm| as uint64 {
      okm := okm[..expectedLength];
    }
  }

  method Hkdf(digest: Types.DigestAlgorithm, salt: Option<seq<uint8>>, ikm: seq<uint8>, info: seq<uint8>, L: uint64)
      returns (okm: seq<uint8>)
    requires 0 <= L as nat <= 255 * Digest.Length(digest) as nat
    requires salt.None? || |salt.value| != 0
    requires |info| < INT32_MAX_LIMIT
    requires |ikm| < INT32_MAX_LIMIT
    ensures |okm| == L as nat
    decreases digest, salt, ikm, info, L
  {
    if L == 0 {
      return [];
    }
    var hmac :- expect HMac.Build(digest);
    var hashLength := Digest.Length(digest);
    var nonEmptySalt: seq<uint8>;
    match salt {
      case {:split false} None() =>
        nonEmptySalt := StandardLibrary.Fill(0, hashLength as nat);
      case {:split false} Some(s) =>
        nonEmptySalt := s;
    }
    var prk := Extract(hmac, nonEmptySalt, ikm, digest);
    ghost var okmUnabridged;
    okm, okmUnabridged := Expand(hmac, prk, info, L, digest);
  }

  import opened HMAC

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes

  import Digest
}

module {:options "-functionSyntax:4"} WrappedHMAC {
  function method Digest(input: Types.HMacInput): (output: Result<seq<uint8>, Types.Error>)
    decreases input
  {
    SequenceIsSafeBecauseItIsInMemory(input.key);
    SequenceIsSafeBecauseItIsInMemory(input.message);
    :- Need(0 < |input.key| as uint64, Types.AwsCryptographicPrimitivesError(message := "Key MUST NOT be 0 bytes.")); :- Need(|input.message| as uint64 < INT32_MAX_LIMIT as uint64, Types.AwsCryptographicPrimitivesError(message := "Message over INT32_MAX_LIMIT")); var value: seq<uint8> :- HMAC.Digest(input); Success(value)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyPrimitivesTypes

  import HMAC
}

module Random {
  method GenerateBytes(i: int32) returns (res: Result<seq<uint8>, Types.Error>)
    requires 0 <= i
    ensures res.Success? ==> |res.value| == i as int
    decreases i
  {
    var value :- ExternRandom.GenerateBytes(i);
    SequenceIsSafeBecauseItIsInMemory(value);
    :- Need(|value| as uint64 == i as uint64, Types.AwsCryptographicPrimitivesError(message := "Incorrect length from ExternRandom."));
    return Success(value);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import ExternRandom

  import Types = AwsCryptographyPrimitivesTypes
}

module {:extern "ExternRandom"} ExternRandom {
  method {:extern} GenerateBytes(i: int32) returns (res: Result<seq<uint8>, Types.OpaqueError>)
    decreases i

  function method CreateGenerateBytesSuccess(bytes: seq<uint8>): Result<seq<uint8>, Types.Error>
    decreases bytes
  {
    Success(bytes)
  }

  function method CreateGenerateBytesFailure(error: Types.Error): Result<seq<uint8>, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyPrimitivesTypes
}

module {:extern "software.amazon.cryptography.materialproviders.internaldafny"} MaterialProviders refines AbstractAwsCryptographyMaterialProvidersService {
  function method DefaultMaterialProvidersConfig(): MaterialProvidersConfig
  {
    MaterialProvidersConfig
  }

  method MaterialProviders(config: MaterialProvidersConfig := DefaultMaterialProvidersConfig()) returns (res: Result<MaterialProvidersClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    ensures res.Success? ==> true && res.value is MaterialProvidersClient
    decreases config
  {
    var maybeCrypto := AtomicPrimitives.AtomicPrimitives();
    var cryptoPrimitivesX: Crypto.IAwsCryptographicPrimitivesClient :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    assert cryptoPrimitivesX is AtomicPrimitives.AtomicPrimitivesClient;
    var cryptoPrimitives := cryptoPrimitivesX as AtomicPrimitives.AtomicPrimitivesClient;
    var client := new MaterialProvidersClient(Operations.Config(crypto := cryptoPrimitives));
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IAwsCryptographicMaterialProvidersClient): Result<IAwsCryptographicMaterialProvidersClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IAwsCryptographicMaterialProvidersClient, Error>
    decreases error
  {
    Failure(error)
  }

  import Operations = AwsCryptographyMaterialProvidersOperations

  import AtomicPrimitives

  import Crypto = AwsCryptographyPrimitivesTypes

  class MaterialProvidersClient ... {
    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IAwsCryptographicMaterialProvidersClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsKeyring(config, input);
      History.CreateAwsKmsKeyring := History.CreateAwsKmsKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsDiscoveryKeyring(config, input);
      History.CreateAwsKmsDiscoveryKeyring := History.CreateAwsKmsDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMultiKeyring(config, input);
      History.CreateAwsKmsMultiKeyring := History.CreateAwsKmsMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsDiscoveryMultiKeyring := History.CreateAwsKmsDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkKeyring(config, input);
      History.CreateAwsKmsMrkKeyring := History.CreateAwsKmsMrkKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkMultiKeyring(config, input);
      History.CreateAwsKmsMrkMultiKeyring := History.CreateAwsKmsMrkMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkDiscoveryKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryKeyring := History.CreateAwsKmsMrkDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryMultiKeyring := History.CreateAwsKmsMrkDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History} && (input.cache.Some? ==> false || (input.cache.value.Shared? ==> input.cache.value.Shared.ValidState() && input.cache.value.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies - if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}
    {
      output := Operations.CreateAwsKmsHierarchicalKeyring(config, input);
      History.CreateAwsKmsHierarchicalKeyring := History.CreateAwsKmsHierarchicalKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsRsaKeyring(config, input);
      History.CreateAwsKmsRsaKeyring := History.CreateAwsKmsRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsEcdhKeyringEnsuresPublicly(input: CreateAwsKmsEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsEcdhKeyring(input: CreateAwsKmsEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsEcdhKeyring == old(History.CreateAwsKmsEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsEcdhKeyring(config, input);
      History.CreateAwsKmsEcdhKeyring := History.CreateAwsKmsEcdhKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    {
      output := Operations.CreateMultiKeyring(config, input);
      History.CreateMultiKeyring := History.CreateMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawAesKeyringEnsuresPublicly(input, output)
    }

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawAesKeyring(config, input);
      History.CreateRawAesKeyring := History.CreateRawAesKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawRsaKeyring(config, input);
      History.CreateRawRsaKeyring := History.CreateRawRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawEcdhKeyringEnsuresPublicly(input: CreateRawEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawEcdhKeyringEnsuresPublicly(input, output)
    }

    method CreateRawEcdhKeyring(input: CreateRawEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawEcdhKeyring == old(History.CreateRawEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawEcdhKeyring(config, input);
      History.CreateRawEcdhKeyring := History.CreateRawEcdhKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    }

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies
    {
      output := Operations.CreateDefaultCryptographicMaterialsManager(config, input);
      History.CreateDefaultCryptographicMaterialsManager := History.CreateDefaultCryptographicMaterialsManager + [DafnyCallEvent(input, output)];
    }

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    }

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.CreateRequiredEncryptionContextCMM(config, input);
      History.CreateRequiredEncryptionContextCMM := History.CreateRequiredEncryptionContextCMM + [DafnyCallEvent(input, output)];
    }

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output
    {
      Operations.CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    }

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires ValidState() && (false || (input.cache.Shared? ==> input.cache.Shared.ValidState() && input.cache.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.cache.Shared? then input.cache.Shared.Modifies else {}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}
    {
      output := Operations.CreateCryptographicMaterialsCache(config, input);
      History.CreateCryptographicMaterialsCache := History.CreateCryptographicMaterialsCache + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output
    {
      Operations.CreateDefaultClientSupplierEnsuresPublicly(input, output)
    }

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateDefaultClientSupplier(config, input);
      History.CreateDefaultClientSupplier := History.CreateDefaultClientSupplier + [DafnyCallEvent(input, output)];
    }

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeEncryptionMaterials(config, input)
    }

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeDecryptionMaterials(config, input)
    }

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidEncryptionMaterialsTransition(config, input)
    }

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidDecryptionMaterialsTransition(config, input)
    }

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.EncryptionMaterialsHasPlaintextDataKey(config, input)
    }

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.DecryptionMaterialsWithPlaintextDataKey(config, input)
    }

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input
    {
      Operations.GetAlgorithmSuiteInfo(config, input)
    }

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidAlgorithmSuiteInfo(config, input)
    }

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnEncrypt(config, input)
    }

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnDecrypt(config, input)
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes
}

module AwsCryptographyMaterialProvidersOperations refines AbstractAwsCryptographyMaterialProvidersOperations {
  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    true &&
    config.crypto.ValidState()
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.crypto.Modifies
  }

  predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsKeyring(config: InternalConfig, input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    var _ /* _v0 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsKeyring.AwsKmsKeyring(input.kmsClient, input.kmsKeyId, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    if input.discoveryFilter.Some? {
      var _ /* _v1 */ :- ValidateDiscoveryFilter(input.discoveryFilter.value);
    }
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring(input.kmsClient, input.discoveryFilter, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMultiKeyring(config: InternalConfig, input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    if input.clientSupplier.Some? {
      output := StrictMultiKeyring(input.generator, input.kmsKeyIds, input.clientSupplier.value, Option.Some(grantTokens));
    } else {
      var clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
      output := StrictMultiKeyring(input.generator, input.kmsKeyIds, clientSupplier, Option.Some(grantTokens));
    }
  }

  predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := DiscoveryMultiKeyring(input.regions, input.discoveryFilter, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkKeyring(config: InternalConfig, input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    var _ /* _v2 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(input.kmsClient, input.kmsKeyId, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := MrkAwareStrictMultiKeyring(input.generator, input.kmsKeyIds, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    if input.discoveryFilter.Some? {
      var _ /* _v3 */ :- ValidateDiscoveryFilter(input.discoveryFilter.value);
    }
    var regionMatch := Kms.RegionMatch(input.kmsClient, input.region);
    :- Need(regionMatch != Some(false), Types.AwsCryptographicMaterialProvidersException(message := "Provided client and region do not match"));
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring(input.kmsClient, input.region, input.discoveryFilter, grantTokens);
    return Success(keyring);
  }

  predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsMrkDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var clientSupplier: Types.IClientSupplier;
    if input.clientSupplier.None? {
      clientSupplier :- CreateDefaultClientSupplier(config, Types.CreateDefaultClientSupplierInput());
    } else {
      clientSupplier := input.clientSupplier.value;
    }
    output := MrkAwareDiscoveryMultiKeyring(input.regions, input.discoveryFilter, clientSupplier, Option.Some(grantTokens));
  }

  predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  function method N(n: PositiveLong): string
    decreases n
  {
    String.Base10Int2String(n as int)
  }

  method CheckCache(cache: CacheType, ttlSeconds: PositiveLong) returns (output: Outcome<Error>)
    decreases cache, ttlSeconds
  {
    if cache.StormTracking? {
      var gracePeriod := if cache.StormTracking.timeUnits.UnwrapOr(Types.Seconds).Seconds? then cache.StormTracking.gracePeriod as PositiveLong else cache.StormTracking.gracePeriod as PositiveLong / 1000;
      var storm := cache.StormTracking;
      if ttlSeconds <= gracePeriod {
        var msg := "When creating an AwsKmsHierarchicalKeyring with a StormCache, " + "the ttlSeconds of the KeyRing must be greater than the gracePeriod of the StormCache " + "yet the ttlSeconds is " + N(ttlSeconds) + " and the gracePeriod is " + N(gracePeriod) + ".";
        return Fail(Types.AwsCryptographicMaterialProvidersException(message := msg));
      }
      return Pass;
    } else {
      return Pass;
    }
  }

  method CreateAwsKmsHierarchicalKeyring(config: InternalConfig, input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.branchKeyIdSupplier.Some? ==> true && input.branchKeyIdSupplier.value.ValidState()) && input.keyStore.ValidState() && (input.cache.Some? ==> false || (input.cache.value.Shared? ==> true && input.cache.value.Shared.ValidState()))
    modifies ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies - if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}))
    ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}
  {
    var cmc;
    if input.cache.Some? {
      :- CheckCache(input.cache.value, input.ttlSeconds);
      match input.cache.value {
        case {:split false} Shared(c) =>
          cmc := c;
        case {:split false} _ /* _v4 */ =>
          cmc :- CreateCryptographicMaterialsCache(config, CreateCryptographicMaterialsCacheInput(cache := input.cache.value));
      }
    } else {
      :- CheckCache(CacheType.StormTracking(StormTracker.DefaultStorm()), input.ttlSeconds);
      cmc :- CreateCryptographicMaterialsCache(config, CreateCryptographicMaterialsCacheInput(cache := Types.Default(Types.DefaultCache(entryCapacity := 1000))));
    }
    var partitionIdBytes: seq<uint8>;
    if input.partitionId.Some? {
      partitionIdBytes :- UTF8.Encode(input.partitionId.value).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := "Could not UTF-8 Encode Partition ID: " + e));
    } else {
      var uuid? := UUID.GenerateUUID();
      var uuid :- uuid?.MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      partitionIdBytes :- UUID.ToByteArray(uuid).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
    }
    var getKeyStoreInfoOutput? := input.keyStore.GetKeyStoreInfo();
    var getKeyStoreInfoOutput :- getKeyStoreInfoOutput?.MapFailure((e: Error) => Types.AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
    var logicalKeyStoreName := getKeyStoreInfoOutput.logicalKeyStoreName;
    var logicalKeyStoreNameBytes: seq<uint8> :- UTF8.Encode(logicalKeyStoreName).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := "Could not UTF-8 Encode Logical Key Store Name: " + e));
    :- Need(input.branchKeyId.None? || input.branchKeyIdSupplier.None?, Types.AwsCryptographicMaterialProvidersException(message := "Cannot initialize keyring with both a branchKeyId and BranchKeyIdSupplier."));
    :- Need(input.branchKeyId.Some? || input.branchKeyIdSupplier.Some?, Types.AwsCryptographicMaterialProvidersException(message := "Must initialize keyring with either branchKeyId or BranchKeyIdSupplier."));
    var keyring := new AwsKmsHierarchicalKeyring.AwsKmsHierarchicalKeyring(keyStore := input.keyStore, branchKeyId := input.branchKeyId, branchKeyIdSupplier := input.branchKeyIdSupplier, ttlSeconds := input.ttlSeconds, cmc := cmc, partitionIdBytes := partitionIdBytes, logicalKeyStoreNameBytes := logicalKeyStoreNameBytes, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateAwsKmsEcdhKeyringEnsuresPublicly(input: CreateAwsKmsEcdhKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsEcdhKeyring(config: InternalConfig, input: CreateAwsKmsEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies
  {
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var recipientPublicKey: KMS.PublicKeyType;
    var senderPublicKey: Option<KMS.PublicKeyType>;
    var compressedSenderPublicKey: Option<seq<uint8>>;
    match input.KeyAgreementScheme {
      case {:split false} KmsPublicKeyDiscovery(kmsPublicKeyDiscovery) =>
        {
          var _ /* _v5 */ :- ValidateKmsKeyId(kmsPublicKeyDiscovery.recipientKmsIdentifier);
          recipientPublicKey :- GetEcdhPublicKey(input.kmsClient, kmsPublicKeyDiscovery.recipientKmsIdentifier);
          senderPublicKey := Option.None();
          compressedSenderPublicKey := Option.None();
        }
      case {:split false} KmsPrivateKeyToStaticPublicKey(kmsPrivateKeyToStaticPublicKey) =>
        {
          if kmsPrivateKeyToStaticPublicKey.senderPublicKey.Some? {
            :- Need(KMS.IsValid_PublicKeyType(kmsPrivateKeyToStaticPublicKey.senderPublicKey.value), Types.AwsCryptographicMaterialProvidersException(message := "Invalid SenderPublicKey length."));
            senderPublicKey := Some(kmsPrivateKeyToStaticPublicKey.senderPublicKey.value);
            var compressedPKU :- RawECDHKeyring.CompressPublicKey(Crypto.ECCPublicKey(der := senderPublicKey.value), input.curveSpec, config.crypto);
            compressedSenderPublicKey := Some(compressedPKU);
          } else {
            var _ /* _v6 */ :- ValidateKmsKeyId(kmsPrivateKeyToStaticPublicKey.senderKmsIdentifier);
            var senderPublicKeyResponse :- GetEcdhPublicKey(input.kmsClient, kmsPrivateKeyToStaticPublicKey.senderKmsIdentifier);
            var compressedPKU :- RawECDHKeyring.CompressPublicKey(Crypto.ECCPublicKey(der := senderPublicKeyResponse), input.curveSpec, config.crypto);
            senderPublicKey := Some(senderPublicKeyResponse);
            compressedSenderPublicKey := Some(compressedPKU);
          }
          :- Need(KMS.IsValid_PublicKeyType(kmsPrivateKeyToStaticPublicKey.recipientPublicKey), Types.AwsCryptographicMaterialProvidersException(message := "Invalid RecipientPublicKey length."));
          recipientPublicKey := kmsPrivateKeyToStaticPublicKey.recipientPublicKey;
        }
    }
    var _ /* _v7 */ :- RawECDHKeyring.ValidatePublicKey(config.crypto, input.curveSpec, recipientPublicKey);
    var compressedRecipientPublicKey :- RawECDHKeyring.CompressPublicKey(Crypto.ECCPublicKey(der := recipientPublicKey), input.curveSpec, config.crypto);
    var senderKmsKeyId := if input.KeyAgreementScheme.KmsPublicKeyDiscovery? then Option.None() else Some(input.KeyAgreementScheme.KmsPrivateKeyToStaticPublicKey.senderKmsIdentifier);
    if senderKmsKeyId.Some? {
      var _ /* _v8 */ :- ValidateKmsKeyId(senderKmsKeyId.value);
    }
    if senderPublicKey.Some? {
      var _ /* _v9 */ :- RawECDHKeyring.ValidatePublicKey(config.crypto, input.curveSpec, senderPublicKey.value);
    }
    var keyring := new AwsKmsEcdhKeyring.AwsKmsEcdhKeyring(input.KeyAgreementScheme, input.curveSpec, input.kmsClient, grantTokens, senderKmsKeyId, senderPublicKey, recipientPublicKey, compressedSenderPublicKey, compressedRecipientPublicKey, config.crypto);
    return Success(keyring);
  }

  predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateMultiKeyring(config: InternalConfig, input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.generator.Some? ==> true && input.generator.value.ValidState()) && forall i: IKeyring {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState()
    modifies ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
    ensures CreateMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
  {
    SequenceIsSafeBecauseItIsInMemory(input.childKeyrings);
    :- Need(input.generator.Some? || |input.childKeyrings| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "Must include a generator keyring and/or at least one child keyring"));
    var keyring := new MultiKeyring.MultiKeyring(input.generator, input.childKeyrings);
    return Success(keyring);
  }

  predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    input.keyNamespace == "aws-kms" ==>
      output.Failure?
  }

  method CreateRawAesKeyring(config: InternalConfig, input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawAesKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(input.keyNamespace != "aws-kms", Types.AwsCryptographicMaterialProvidersException(message := "keyNamespace must not be `aws-kms`"));
    var wrappingAlg: Crypto.AES_GCM := match input.wrappingAlg case ALG_AES128_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 16, tagLength := 16, ivLength := 12) case ALG_AES192_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 24, tagLength := 16, ivLength := 12) case ALG_AES256_GCM_IV12_TAG16() => Crypto.AES_GCM(keyLength := 32, tagLength := 16, ivLength := 12);
    var namespaceAndName :- ParseKeyNamespaceAndName(input.keyNamespace, input.keyName);
    var (namespace, name) := namespaceAndName;
    SequenceIsSafeBecauseItIsInMemory(input.wrappingKey);
    var wrapping_key_size := |input.wrappingKey| as uint64;
    :- Need(wrapping_key_size == 16 || wrapping_key_size == 24 || wrapping_key_size == 32, Types.AwsCryptographicMaterialProvidersException(message := "Invalid wrapping key length"));
    :- Need(wrapping_key_size == wrappingAlg.keyLength as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Wrapping key length does not match specified wrapping algorithm"));
    var keyring := new RawAESKeyring.RawAESKeyring(namespace := namespace, name := name, key := input.wrappingKey, wrappingAlgorithm := wrappingAlg, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    (input.keyNamespace == "aws-kms" ==>
      output.Failure?) &&
    (input.publicKey.None? &&
    input.privateKey.None? ==>
      output.Failure?)
  }

  method CreateRawRsaKeyring(config: InternalConfig, input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    :- Need(input.keyNamespace != "aws-kms", Types.AwsCryptographicMaterialProvidersException(message := "keyNamespace must not be `aws-kms`"));
    :- Need(input.publicKey.Some? || input.privateKey.Some?, Types.AwsCryptographicMaterialProvidersException(message := "A publicKey or a privateKey is required"));
    var padding: Crypto.RSAPaddingMode := match input.paddingScheme case PKCS1() => Crypto.RSAPaddingMode.PKCS1 case OAEP_SHA1_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA1 case OAEP_SHA256_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA256 case OAEP_SHA384_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA384 case OAEP_SHA512_MGF1() => Crypto.RSAPaddingMode.OAEP_SHA512;
    var namespaceAndName :- ParseKeyNamespaceAndName(input.keyNamespace, input.keyName);
    var (namespace, name) := namespaceAndName;
    var keyring := new RawRSAKeyring.RawRSAKeyring(namespace := namespace, name := name, publicKey := input.publicKey, privateKey := input.privateKey, paddingScheme := padding, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateRawEcdhKeyringEnsuresPublicly(input: CreateRawEcdhKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateRawEcdhKeyring(config: InternalConfig, input: CreateRawEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawEcdhKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    var recipientPublicKey: seq<uint8>;
    var senderPrivateKey: Option<seq<uint8>>;
    var senderPublicKey: Option<seq<uint8>>;
    var compressedSenderPublicKey: Option<seq<uint8>>;
    match input.KeyAgreementScheme {
      case {:split false} RawPrivateKeyToStaticPublicKey(rawPrivateKeyToStaticPublicKey) =>
        {
          recipientPublicKey := rawPrivateKeyToStaticPublicKey.recipientPublicKey;
          senderPrivateKey := Option.Some(rawPrivateKeyToStaticPublicKey.senderStaticPrivateKey);
          var reproducedPublicKey :- GetPublicKey(input.curveSpec, Crypto.ECCPrivateKey(pem := senderPrivateKey.value), config.crypto);
          var _ /* _v10 */ :- RawECDHKeyring.ValidatePublicKey(config.crypto, input.curveSpec, reproducedPublicKey);
          senderPublicKey := Some(reproducedPublicKey);
          var compressedSenderPublicKey? :- RawECDHKeyring.CompressPublicKey(Crypto.ECCPublicKey(der := reproducedPublicKey), input.curveSpec, config.crypto);
          compressedSenderPublicKey := Some(compressedSenderPublicKey?);
        }
      case {:split false} EphemeralPrivateKeyToStaticPublicKey(ephemeralPrivateKeyToStaticPublicKey) =>
        {
          recipientPublicKey := ephemeralPrivateKeyToStaticPublicKey.recipientPublicKey;
          senderPrivateKey := Option.None();
          senderPublicKey := Option.None();
          compressedSenderPublicKey := Option.None();
        }
      case {:split false} PublicKeyDiscovery(publicKeyDiscovery) =>
        {
          var reproducedPublicKey :- GetPublicKey(input.curveSpec, Crypto.ECCPrivateKey(pem := publicKeyDiscovery.recipientStaticPrivateKey), config.crypto);
          recipientPublicKey := reproducedPublicKey;
          senderPrivateKey := Option.None();
          senderPublicKey := Option.None();
          compressedSenderPublicKey := Option.None();
        }
    }
    var compressedRecipientPublicKey :- RawECDHKeyring.CompressPublicKey(Crypto.ECCPublicKey(der := recipientPublicKey), input.curveSpec, config.crypto);
    var _ /* _v11 */ :- RawECDHKeyring.ValidatePublicKey(config.crypto, input.curveSpec, recipientPublicKey);
    if senderPublicKey.Some? {
      var _ /* _v12 */ :- RawECDHKeyring.ValidatePublicKey(config.crypto, input.curveSpec, senderPublicKey.value);
      :- Need(RawECDHKeyring.ValidPublicKeyLength(senderPublicKey.value), Types.AwsCryptographicMaterialProvidersException(message := "Invalid sender public key length"));
    }
    :- Need(RawECDHKeyring.ValidPublicKeyLength(recipientPublicKey), Types.AwsCryptographicMaterialProvidersException(message := "Invalid recipient public key length"));
    var keyring := new RawECDHKeyring.RawEcdhKeyring(keyAgreementScheme := input.KeyAgreementScheme, curveSpec := input.curveSpec, senderPrivateKey := senderPrivateKey, senderPublicKey := senderPublicKey, recipientPublicKey := recipientPublicKey, compressedSenderPublicKey := compressedSenderPublicKey, compressedRecipientPublicKey := compressedRecipientPublicKey, cryptoPrimitives := config.crypto);
    return Success(keyring);
  }

  predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output
  {
    true
  }

  method CreateAwsKmsRsaKeyring(config: InternalConfig, input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.kmsClient.Some? ==> true && input.kmsClient.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
    ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
  {
    :- Need(input.publicKey.Some? || input.kmsClient.Some?, Types.AwsCryptographicMaterialProvidersException(message := "A publicKey or a kmsClient is required"));
    :- Need(input.encryptionAlgorithm.RSAES_OAEP_SHA_1? || input.encryptionAlgorithm.RSAES_OAEP_SHA_256?, Types.AwsCryptographicMaterialProvidersException(message := "Unsupported EncryptionAlgorithmSpec"));
    :- Need(KMS.IsValid_KeyIdType(input.kmsKeyId) && ParseAwsKmsArn(input.kmsKeyId).Success?, Types.AwsCryptographicMaterialProvidersException(message := "Kms Key ID must be a KMS Key ARN"));
    if input.publicKey.Some? {
      var lengthOutputRes := config.crypto.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := input.publicKey.value));
      var lengthOutput :- lengthOutputRes.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      :- Need(lengthOutput.length >= AwsKmsRsaKeyring.MIN_KMS_RSA_KEY_LEN, Types.AwsCryptographicMaterialProvidersException(message := "Invalid public key length"));
    }
    var _ /* _v13 */ :- ValidateKmsKeyId(input.kmsKeyId);
    var grantTokens :- GetValidGrantTokens(input.grantTokens);
    var keyring := new AwsKmsRsaKeyring.AwsKmsRsaKeyring(publicKey := input.publicKey, awsKmsKey := input.kmsKeyId, paddingScheme := input.encryptionAlgorithm, client := input.kmsClient, cryptoPrimitives := config.crypto, grantTokens := grantTokens);
    return Success(keyring);
  }

  predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output
  {
    true
  }

  method CreateDefaultCryptographicMaterialsManager(config: InternalConfig, input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && input.keyring.ValidState()
    modifies ModifiesInternalConfig(config), input.keyring.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.keyring.Modifies))
    ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.keyring.Modifies
  {
    var cmm := new DefaultCMM.OfKeyring(input.keyring, config.crypto);
    return Success(cmm);
  }

  function method CmpError(s: string): Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output
  {
    true
  }

  method CreateRequiredEncryptionContextCMM(config: InternalConfig, input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && (input.underlyingCMM.Some? ==> true && input.underlyingCMM.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
    ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    ensures output.Success? ==> output.value.ValidState()
    decreases ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
  {
    :- Need(input.underlyingCMM.Some? && input.keyring.None?, CmpError("CreateRequiredEncryptionContextCMM currently only supports cmm."));
    var keySet: set<UTF8.ValidUTF8Bytes> := set k: UTF8.ValidUTF8Bytes {:trigger k in input.requiredEncryptionContextKeys} | k in input.requiredEncryptionContextKeys;
    SetIsSafeBecauseItIsInMemory(keySet);
    :- Need(0 < |keySet| as uint64, CmpError("RequiredEncryptionContextCMM needs at least one requiredEncryptionContextKey."));
    var cmm := new RequiredEncryptionContextCMM.RequiredEncryptionContextCMM(input.underlyingCMM.value, keySet);
    return Success(cmm);
  }

  predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
    decreases input, output
  {
    true
  }

  method CreateCryptographicMaterialsCache(config: InternalConfig, input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
    requires ValidInternalConfig?(config) && (false || (input.cache.Shared? ==> true && input.cache.Shared.ValidState()))
    modifies ModifiesInternalConfig(config), if input.cache.Shared? then input.cache.Shared.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.cache.Shared? then input.cache.Shared.Modifies else {}))
    ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.cache.Shared? then input.cache.Shared.Modifies else {}
  {
    match input.cache {
      case {:split false} Default(c) =>
        var cache := StormTracker.DefaultStorm().(entryCapacity := c.entryCapacity);
        :- StormTracker.CheckSettings(cache);
        var cmc := new StormTracker.StormTracker(cache);
        var synCmc := new StormTrackingCMC.StormTrackingCMC(cmc);
        return Success(synCmc);
      case {:split false} No(_ /* _v14 */) =>
        var cmc := new LocalCMC.LocalCMC(0, 1);
        return Success(cmc);
      case {:split false} SingleThreaded(c) =>
        var cmc := new LocalCMC.LocalCMC(c.entryCapacity as uint64, OptionalCountingNumber(c.entryPruningTailSize).UnwrapOr(1) as uint64);
        return Success(cmc);
      case {:split false} MultiThreaded(c) =>
        var cmc := new LocalCMC.LocalCMC(c.entryCapacity as uint64, OptionalCountingNumber(c.entryPruningTailSize).UnwrapOr(1) as uint64);
        var synCmc := new SynchronizedLocalCMC.SynchronizedLocalCMC(cmc);
        return Success(synCmc);
      case {:split false} StormTracking(c) =>
        var cache := c.(entryPruningTailSize := OptionalCountingNumber(c.entryPruningTailSize));
        :- StormTracker.CheckSettings(cache);
        var cmc := new StormTracker.StormTracker(cache);
        var synCmc := new StormTrackingCMC.StormTrackingCMC(cmc);
        return Success(synCmc);
      case {:split false} Shared(c) =>
        var exception := Types.AwsCryptographicMaterialProvidersException(message := "CreateCryptographicMaterialsCache should never be called with Shared CacheType.");
        return Failure(exception);
    }
  }

  function method OptionalCountingNumber(c: Option<int32>): Option<CountingNumber>
    decreases c
  {
    if c.Some? && c.value <= 0 then
      Wrappers.None
    else
      c
  }

  lemma OptionalCountingNumberCorrect(c: int32)
    ensures 1 <= c ==> OptionalCountingNumber(Some(c)) == Some(c)
    ensures c <= 0 ==> OptionalCountingNumber(Some(c)) == Wrappers.None
    decreases c
  {
  }

  predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
    decreases input, output
  {
    true
  }

  method CreateDefaultClientSupplier(config: InternalConfig, input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    var clientSupplier := new DefaultClientSupplier.DefaultClientSupplier();
    return Success(clientSupplier);
  }

  function method InitializeEncryptionMaterials(config: InternalConfig, input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
    decreases input
  {
    Materials.InitializeEncryptionMaterials(input)
  }

  function method InitializeDecryptionMaterials(config: InternalConfig, input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
    decreases input
  {
    Materials.InitializeDecryptionMaterials(input)
  }

  function method ValidEncryptionMaterialsTransition(config: InternalConfig, input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input
  {
    :- Need(Materials.ValidEncryptionMaterialsTransition(input.start, input.stop), InvalidEncryptionMaterialsTransition(message := "Invalid Encryption Materials Transition")); Success(())
  }

  function method ValidDecryptionMaterialsTransition(config: InternalConfig, input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input
  {
    :- Need(Materials.DecryptionMaterialsTransitionIsValid(input.start, input.stop), InvalidDecryptionMaterialsTransition(message := "Invalid Decryption Materials Transition")); Success(())
  }

  function method EncryptionMaterialsHasPlaintextDataKey(config: InternalConfig, input: EncryptionMaterials): (output: Result<(), Error>)
    decreases input
  {
    :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(input), InvalidDecryptionMaterials(message := "Invalid Encryption Materials")); Success(())
  }

  function method DecryptionMaterialsWithPlaintextDataKey(config: InternalConfig, input: DecryptionMaterials): (output: Result<(), Error>)
    decreases input
  {
    :- Need(Materials.DecryptionMaterialsWithPlaintextDataKey(input), InvalidDecryptionMaterials(message := "Invalid Decryption Materials")); Success(())
  }

  function method GetAlgorithmSuiteInfo(config: InternalConfig, input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
    decreases input
  {
    AlgorithmSuites.GetAlgorithmSuiteInfo(input)
  }

  function method ValidAlgorithmSuiteInfo(config: InternalConfig, input: AlgorithmSuiteInfo): (output: Result<(), Error>)
    decreases input
  {
    :- Need(AlgorithmSuites.AlgorithmSuite?(input), InvalidAlgorithmSuiteInfo(message := "Invalid AlgorithmSuiteInfo")); Success(())
  }

  function method ValidateCommitmentPolicyOnEncrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
    decreases input
  {
    :- Commitment.ValidateCommitmentPolicyOnEncrypt(input.algorithm, input.commitmentPolicy); Success(())
  }

  function method ValidateCommitmentPolicyOnDecrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
    decreases input
  {
    :- Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithm, input.commitmentPolicy); Success(())
  }

  import MultiKeyring

  import opened S = StrictMultiKeyring

  import opened D = DiscoveryMultiKeyring

  import opened MD = MrkAwareDiscoveryMultiKeyring

  import opened M = MrkAwareStrictMultiKeyring

  import opened MemoryMath = StandardLibrary.MemoryMath

  import AwsKmsKeyring

  import AwsKmsHierarchicalKeyring

  import AwsKmsMrkKeyring

  import AwsKmsDiscoveryKeyring

  import AwsKmsMrkDiscoveryKeyring

  import AwsKmsRsaKeyring

  import AwsKmsEcdhKeyring

  import RawAESKeyring

  import RawRSAKeyring

  import RawECDHKeyring

  import opened C = DefaultCMM

  import LocalCMC

  import SynchronizedLocalCMC

  import StormTracker

  import StormTrackingCMC

  import Crypto = AwsCryptographyPrimitivesTypes

  import AtomicPrimitives

  import opened AwsKmsUtils

  import DefaultClientSupplier

  import Materials

  import Commitment

  import AlgorithmSuites

  import opened AwsArnParsing

  import opened Utils

  import Kms = Com.Amazonaws.Kms

  import Ddb = ComAmazonawsDynamodbTypes

  import RequiredEncryptionContextCMM

  import UUID

  import String = StandardLibrary.String

  datatype Config = Config(nameonly crypto: AtomicPrimitives.AtomicPrimitivesClient)

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes
}

module {:options "/functionSyntax:4"} Utils {
  method {:vcs_split_on_every_assert} GetPublicKey(curveSpec: Crypto.ECDHCurveSpec, privateKey: Crypto.ECCPrivateKey, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.GetPublicKeyFromPrivateKey| > 0 && Last(crypto.History.GetPublicKeyFromPrivateKey).output.Success? && Last(crypto.History.GetPublicKeyFromPrivateKey).input == Crypto.GetPublicKeyFromPrivateKeyInput(eccCurve := curveSpec, privateKey := privateKey)
    decreases curveSpec, privateKey, crypto
  {
    var maybePublicKey := crypto.GetPublicKeyFromPrivateKey(Crypto.GetPublicKeyFromPrivateKeyInput(eccCurve := curveSpec, privateKey := privateKey));
    var keyPairOutput :- maybePublicKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    res := Success(keyPairOutput.publicKey);
  }

  import Crypto = AwsCryptographyPrimitivesTypes

  import AtomicPrimitives

  import Types = AwsCryptographyMaterialProvidersTypes

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Seq

  import opened Wrappers
}

module {:extern "software.amazon.cryptography.materialproviders.internaldafny.types"} AwsCryptographyMaterialProvidersTypes {
  predicate method IsValid_CountingNumber(x: int32)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_PositiveInteger(x: int32)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_PositiveLong(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import AwsCryptographyKeyStoreTypes

  import AwsCryptographyPrimitivesTypes

  import ComAmazonawsDynamodbTypes

  import ComAmazonawsKmsTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  type AccountId = string

  type AccountIdList = seq<AccountId>

  datatype AesWrappingAlg = ALG_AES128_GCM_IV12_TAG16 | ALG_AES192_GCM_IV12_TAG16 | ALG_AES256_GCM_IV12_TAG16

  datatype AlgorithmSuiteId = ESDK(ESDK: ESDKAlgorithmSuiteId) | DBE(DBE: DBEAlgorithmSuiteId)

  datatype AlgorithmSuiteInfo = AlgorithmSuiteInfo(nameonly id: AlgorithmSuiteId, nameonly binaryId: seq<uint8>, nameonly messageVersion: int32, nameonly encrypt: Encrypt, nameonly kdf: DerivationAlgorithm, nameonly commitment: DerivationAlgorithm, nameonly signature: SignatureAlgorithm, nameonly symmetricSignature: SymmetricSignatureAlgorithm, nameonly edkWrapping: EdkWrappingAlgorithm)

  class IAwsCryptographicMaterialProvidersClientCallHistory {
    ghost constructor ()
    {
      CreateAwsKmsKeyring := [];
      CreateAwsKmsDiscoveryKeyring := [];
      CreateAwsKmsMultiKeyring := [];
      CreateAwsKmsDiscoveryMultiKeyring := [];
      CreateAwsKmsMrkKeyring := [];
      CreateAwsKmsMrkMultiKeyring := [];
      CreateAwsKmsMrkDiscoveryKeyring := [];
      CreateAwsKmsMrkDiscoveryMultiKeyring := [];
      CreateAwsKmsHierarchicalKeyring := [];
      CreateAwsKmsRsaKeyring := [];
      CreateAwsKmsEcdhKeyring := [];
      CreateMultiKeyring := [];
      CreateRawAesKeyring := [];
      CreateRawRsaKeyring := [];
      CreateRawEcdhKeyring := [];
      CreateDefaultCryptographicMaterialsManager := [];
      CreateRequiredEncryptionContextCMM := [];
      CreateCryptographicMaterialsCache := [];
      CreateDefaultClientSupplier := [];
      InitializeEncryptionMaterials := [];
      InitializeDecryptionMaterials := [];
      ValidEncryptionMaterialsTransition := [];
      ValidDecryptionMaterialsTransition := [];
      EncryptionMaterialsHasPlaintextDataKey := [];
      DecryptionMaterialsWithPlaintextDataKey := [];
      GetAlgorithmSuiteInfo := [];
      ValidAlgorithmSuiteInfo := [];
      ValidateCommitmentPolicyOnEncrypt := [];
      ValidateCommitmentPolicyOnDecrypt := [];
    }

    ghost var CreateAwsKmsKeyring: seq<DafnyCallEvent<CreateAwsKmsKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsDiscoveryKeyring: seq<DafnyCallEvent<CreateAwsKmsDiscoveryKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsDiscoveryMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsDiscoveryMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkDiscoveryKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkDiscoveryKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsMrkDiscoveryMultiKeyring: seq<DafnyCallEvent<CreateAwsKmsMrkDiscoveryMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsHierarchicalKeyring: seq<DafnyCallEvent<CreateAwsKmsHierarchicalKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsRsaKeyring: seq<DafnyCallEvent<CreateAwsKmsRsaKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateAwsKmsEcdhKeyring: seq<DafnyCallEvent<CreateAwsKmsEcdhKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateMultiKeyring: seq<DafnyCallEvent<CreateMultiKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateRawAesKeyring: seq<DafnyCallEvent<CreateRawAesKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateRawRsaKeyring: seq<DafnyCallEvent<CreateRawRsaKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateRawEcdhKeyring: seq<DafnyCallEvent<CreateRawEcdhKeyringInput, Result<IKeyring, Error>>>
    ghost var CreateDefaultCryptographicMaterialsManager: seq<DafnyCallEvent<CreateDefaultCryptographicMaterialsManagerInput, Result<ICryptographicMaterialsManager, Error>>>
    ghost var CreateRequiredEncryptionContextCMM: seq<DafnyCallEvent<CreateRequiredEncryptionContextCMMInput, Result<ICryptographicMaterialsManager, Error>>>
    ghost var CreateCryptographicMaterialsCache: seq<DafnyCallEvent<CreateCryptographicMaterialsCacheInput, Result<ICryptographicMaterialsCache, Error>>>
    ghost var CreateDefaultClientSupplier: seq<DafnyCallEvent<CreateDefaultClientSupplierInput, Result<IClientSupplier, Error>>>
    ghost var InitializeEncryptionMaterials: seq<DafnyCallEvent<InitializeEncryptionMaterialsInput, Result<EncryptionMaterials, Error>>>
    ghost var InitializeDecryptionMaterials: seq<DafnyCallEvent<InitializeDecryptionMaterialsInput, Result<DecryptionMaterials, Error>>>
    ghost var ValidEncryptionMaterialsTransition: seq<DafnyCallEvent<ValidEncryptionMaterialsTransitionInput, Result<(), Error>>>
    ghost var ValidDecryptionMaterialsTransition: seq<DafnyCallEvent<ValidDecryptionMaterialsTransitionInput, Result<(), Error>>>
    ghost var EncryptionMaterialsHasPlaintextDataKey: seq<DafnyCallEvent<EncryptionMaterials, Result<(), Error>>>
    ghost var DecryptionMaterialsWithPlaintextDataKey: seq<DafnyCallEvent<DecryptionMaterials, Result<(), Error>>>
    ghost var GetAlgorithmSuiteInfo: seq<DafnyCallEvent<seq<uint8>, Result<AlgorithmSuiteInfo, Error>>>
    ghost var ValidAlgorithmSuiteInfo: seq<DafnyCallEvent<AlgorithmSuiteInfo, Result<(), Error>>>
    ghost var ValidateCommitmentPolicyOnEncrypt: seq<DafnyCallEvent<ValidateCommitmentPolicyOnEncryptInput, Result<(), Error>>>
    ghost var ValidateCommitmentPolicyOnDecrypt: seq<DafnyCallEvent<ValidateCommitmentPolicyOnDecryptInput, Result<(), Error>>>
  }

  trait {:termination false} IAwsCryptographicMaterialProvidersClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IAwsCryptographicMaterialProvidersClientCallHistory

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History} && (input.cache.Some? ==> false || (input.cache.value.Shared? ==> input.cache.value.Shared.ValidState() && input.cache.value.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies - if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}

    predicate CreateAwsKmsEcdhKeyringEnsuresPublicly(input: CreateAwsKmsEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateAwsKmsEcdhKeyring(input: CreateAwsKmsEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsEcdhKeyring == old(History.CreateAwsKmsEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateRawEcdhKeyringEnsuresPublicly(input: CreateRawEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output

    method CreateRawEcdhKeyring(input: CreateRawEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawEcdhKeyring == old(History.CreateRawEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires ValidState() && (false || (input.cache.Shared? ==> input.cache.Shared.ValidState() && input.cache.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.cache.Shared? then input.cache.Shared.Modifies else {}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
  }

  class IBranchKeyIdSupplierCallHistory {
    ghost constructor ()
    {
      GetBranchKeyId := [];
    }

    ghost var GetBranchKeyId: seq<DafnyCallEvent<GetBranchKeyIdInput, Result<GetBranchKeyIdOutput, Error>>>
  }

  trait {:termination false} IBranchKeyIdSupplier {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IBranchKeyIdSupplierCallHistory

    predicate GetBranchKeyIdEnsuresPublicly(input: GetBranchKeyIdInput, output: Result<GetBranchKeyIdOutput, Error>)
      decreases input, output

    method GetBranchKeyId(input: GetBranchKeyIdInput) returns (output: Result<GetBranchKeyIdOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyId
      ensures true && ValidState()
      ensures GetBranchKeyIdEnsuresPublicly(input, output)
      ensures History.GetBranchKeyId == old(History.GetBranchKeyId) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetBranchKeyId'(input);
      History.GetBranchKeyId := History.GetBranchKeyId + [DafnyCallEvent(input, output)];
    }

    method GetBranchKeyId'(input: GetBranchKeyIdInput) returns (output: Result<GetBranchKeyIdOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetBranchKeyIdEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype CacheType = Default(Default: DefaultCache) | No(No: NoCache) | SingleThreaded(SingleThreaded: SingleThreadedCache) | MultiThreaded(MultiThreaded: MultiThreadedCache) | StormTracking(StormTracking: StormTrackingCache) | Shared(Shared: ICryptographicMaterialsCache)

  class IClientSupplierCallHistory {
    ghost constructor ()
    {
      GetClient := [];
    }

    ghost var GetClient: seq<DafnyCallEvent<GetClientInput, Result<ComAmazonawsKmsTypes.IKMSClient, Error>>>
  }

  trait {:termination false} IClientSupplier {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IClientSupplierCallHistory

    predicate GetClientEnsuresPublicly(input: GetClientInput, output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      decreases input, output

    method GetClient(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetClient
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures GetClientEnsuresPublicly(input, output)
      ensures History.GetClient == old(History.GetClient) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetClient'(input);
      History.GetClient := History.GetClient + [DafnyCallEvent(input, output)];
    }

    method GetClient'(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures GetClientEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype CommitmentPolicy = ESDK(ESDK: ESDKCommitmentPolicy) | DBE(DBE: DBECommitmentPolicy)

  type CountingNumber = x: int32
    | IsValid_CountingNumber(x)
    witness *

  datatype CreateAwsKmsDiscoveryKeyringInput = CreateAwsKmsDiscoveryKeyringInput(nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly discoveryFilter: Option<DiscoveryFilter> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsDiscoveryMultiKeyringInput = CreateAwsKmsDiscoveryMultiKeyringInput(nameonly regions: RegionList, nameonly discoveryFilter: Option<DiscoveryFilter> := Option.None, nameonly clientSupplier: Option<IClientSupplier> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsEcdhKeyringInput = CreateAwsKmsEcdhKeyringInput(nameonly KeyAgreementScheme: KmsEcdhStaticConfigurations, nameonly curveSpec: AwsCryptographyPrimitivesTypes.ECDHCurveSpec, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsHierarchicalKeyringInput = CreateAwsKmsHierarchicalKeyringInput(nameonly branchKeyId: Option<string> := Option.None, nameonly branchKeyIdSupplier: Option<IBranchKeyIdSupplier> := Option.None, nameonly keyStore: AwsCryptographyKeyStoreTypes.IKeyStoreClient, nameonly ttlSeconds: PositiveLong, nameonly cache: Option<CacheType> := Option.None, nameonly partitionId: Option<string> := Option.None)

  datatype CreateAwsKmsKeyringInput = CreateAwsKmsKeyringInput(nameonly kmsKeyId: KmsKeyId, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsMrkDiscoveryKeyringInput = CreateAwsKmsMrkDiscoveryKeyringInput(nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly discoveryFilter: Option<DiscoveryFilter> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None, nameonly region: Region)

  datatype CreateAwsKmsMrkDiscoveryMultiKeyringInput = CreateAwsKmsMrkDiscoveryMultiKeyringInput(nameonly regions: RegionList, nameonly discoveryFilter: Option<DiscoveryFilter> := Option.None, nameonly clientSupplier: Option<IClientSupplier> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsMrkKeyringInput = CreateAwsKmsMrkKeyringInput(nameonly kmsKeyId: KmsKeyId, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsMrkMultiKeyringInput = CreateAwsKmsMrkMultiKeyringInput(nameonly generator: Option<KmsKeyId> := Option.None, nameonly kmsKeyIds: Option<KmsKeyIdList> := Option.None, nameonly clientSupplier: Option<IClientSupplier> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsMultiKeyringInput = CreateAwsKmsMultiKeyringInput(nameonly generator: Option<KmsKeyId> := Option.None, nameonly kmsKeyIds: Option<KmsKeyIdList> := Option.None, nameonly clientSupplier: Option<IClientSupplier> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateAwsKmsRsaKeyringInput = CreateAwsKmsRsaKeyringInput(nameonly publicKey: Option<Secret> := Option.None, nameonly kmsKeyId: KmsKeyId, nameonly encryptionAlgorithm: ComAmazonawsKmsTypes.EncryptionAlgorithmSpec, nameonly kmsClient: Option<ComAmazonawsKmsTypes.IKMSClient> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None)

  datatype CreateCryptographicMaterialsCacheInput = CreateCryptographicMaterialsCacheInput(nameonly cache: CacheType)

  datatype CreateDefaultClientSupplierInput = CreateDefaultClientSupplierInput

  datatype CreateDefaultCryptographicMaterialsManagerInput = CreateDefaultCryptographicMaterialsManagerInput(nameonly keyring: IKeyring)

  datatype CreateMultiKeyringInput = CreateMultiKeyringInput(nameonly generator: Option<IKeyring> := Option.None, nameonly childKeyrings: KeyringList)

  datatype CreateRawAesKeyringInput = CreateRawAesKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly wrappingKey: seq<uint8>, nameonly wrappingAlg: AesWrappingAlg)

  datatype CreateRawEcdhKeyringInput = CreateRawEcdhKeyringInput(nameonly KeyAgreementScheme: RawEcdhStaticConfigurations, nameonly curveSpec: AwsCryptographyPrimitivesTypes.ECDHCurveSpec)

  datatype CreateRawRsaKeyringInput = CreateRawRsaKeyringInput(nameonly keyNamespace: string, nameonly keyName: string, nameonly paddingScheme: PaddingScheme, nameonly publicKey: Option<seq<uint8>> := Option.None, nameonly privateKey: Option<seq<uint8>> := Option.None)

  datatype CreateRequiredEncryptionContextCMMInput = CreateRequiredEncryptionContextCMMInput(nameonly underlyingCMM: Option<ICryptographicMaterialsManager> := Option.None, nameonly keyring: Option<IKeyring> := Option.None, nameonly requiredEncryptionContextKeys: EncryptionContextKeys)

  class ICryptographicMaterialsCacheCallHistory {
    ghost constructor ()
    {
      PutCacheEntry := [];
      UpdateUsageMetadata := [];
      GetCacheEntry := [];
      DeleteCacheEntry := [];
    }

    ghost var PutCacheEntry: seq<DafnyCallEvent<PutCacheEntryInput, Result<(), Error>>>
    ghost var UpdateUsageMetadata: seq<DafnyCallEvent<UpdateUsageMetadataInput, Result<(), Error>>>
    ghost var GetCacheEntry: seq<DafnyCallEvent<GetCacheEntryInput, Result<GetCacheEntryOutput, Error>>>
    ghost var DeleteCacheEntry: seq<DafnyCallEvent<DeleteCacheEntryInput, Result<(), Error>>>
  }

  trait {:termination false} ICryptographicMaterialsCache {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies && this in Modifies

    ghost var InternalModifies: set<object>

    predicate InternalValidState()
      reads this`InternalModifies, InternalModifies
      ensures InternalValidState() ==> History !in InternalModifies
      decreases InternalModifies + {this}

    ghost const History: ICryptographicMaterialsCacheCallHistory

    predicate PutCacheEntryEnsuresPublicly(input: PutCacheEntryInput, output: Result<(), Error>)
      decreases input, output

    method PutCacheEntry(input: PutCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutCacheEntry
      ensures true && ValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures History.PutCacheEntry == old(History.PutCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      assume {:axiom} InternalModifies < Modifies && InternalValidState();
      output := PutCacheEntry'(input);
      History.PutCacheEntry := History.PutCacheEntry + [DafnyCallEvent(input, output)];
    }

    method PutCacheEntry'(input: PutCacheEntryInput) returns (output: Result<(), Error>)
      requires true && InternalValidState()
      modifies InternalModifies
      ensures true && InternalValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate UpdateUsageMetadataEnsuresPublicly(input: UpdateUsageMetadataInput, output: Result<(), Error>)
      decreases input, output

    method UpdateUsageMetadata(input: UpdateUsageMetadataInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateUsageMetadata
      ensures true && ValidState()
      ensures UpdateUsageMetadataEnsuresPublicly(input, output)
      ensures History.UpdateUsageMetadata == old(History.UpdateUsageMetadata) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      assume {:axiom} InternalModifies < Modifies && InternalValidState();
      output := UpdateUsageMetadata'(input);
      History.UpdateUsageMetadata := History.UpdateUsageMetadata + [DafnyCallEvent(input, output)];
    }

    method UpdateUsageMetadata'(input: UpdateUsageMetadataInput) returns (output: Result<(), Error>)
      requires true && InternalValidState()
      modifies InternalModifies
      ensures true && InternalValidState()
      ensures UpdateUsageMetadataEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate GetCacheEntryEnsuresPublicly(input: GetCacheEntryInput, output: Result<GetCacheEntryOutput, Error>)
      decreases input, output

    method GetCacheEntry(input: GetCacheEntryInput) returns (output: Result<GetCacheEntryOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetCacheEntry
      ensures true && ValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures History.GetCacheEntry == old(History.GetCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      assume {:axiom} InternalModifies < Modifies && InternalValidState();
      output := GetCacheEntry'(input);
      History.GetCacheEntry := History.GetCacheEntry + [DafnyCallEvent(input, output)];
    }

    method GetCacheEntry'(input: GetCacheEntryInput) returns (output: Result<GetCacheEntryOutput, Error>)
      requires true && InternalValidState()
      modifies InternalModifies
      ensures true && InternalValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate DeleteCacheEntryEnsuresPublicly(input: DeleteCacheEntryInput, output: Result<(), Error>)
      decreases input, output

    method DeleteCacheEntry(input: DeleteCacheEntryInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteCacheEntry
      ensures true && ValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures History.DeleteCacheEntry == old(History.DeleteCacheEntry) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      assume {:axiom} InternalModifies < Modifies && InternalValidState();
      output := DeleteCacheEntry'(input);
      History.DeleteCacheEntry := History.DeleteCacheEntry + [DafnyCallEvent(input, output)];
    }

    method DeleteCacheEntry'(input: DeleteCacheEntryInput) returns (output: Result<(), Error>)
      requires true && InternalValidState()
      modifies InternalModifies
      ensures true && InternalValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies
  }

  class ICryptographicMaterialsManagerCallHistory {
    ghost constructor ()
    {
      GetEncryptionMaterials := [];
      DecryptMaterials := [];
    }

    ghost var GetEncryptionMaterials: seq<DafnyCallEvent<GetEncryptionMaterialsInput, Result<GetEncryptionMaterialsOutput, Error>>>
    ghost var DecryptMaterials: seq<DafnyCallEvent<DecryptMaterialsInput, Result<DecryptMaterialsOutput, Error>>>
  }

  trait {:termination false} ICryptographicMaterialsManager {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: ICryptographicMaterialsManagerCallHistory

    predicate GetEncryptionMaterialsEnsuresPublicly(input: GetEncryptionMaterialsInput, output: Result<GetEncryptionMaterialsOutput, Error>)
      decreases input, output

    method GetEncryptionMaterials(input: GetEncryptionMaterialsInput) returns (output: Result<GetEncryptionMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetEncryptionMaterials
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures History.GetEncryptionMaterials == old(History.GetEncryptionMaterials) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := GetEncryptionMaterials'(input);
      History.GetEncryptionMaterials := History.GetEncryptionMaterials + [DafnyCallEvent(input, output)];
    }

    method GetEncryptionMaterials'(input: GetEncryptionMaterialsInput) returns (output: Result<GetEncryptionMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate DecryptMaterialsEnsuresPublicly(input: DecryptMaterialsInput, output: Result<DecryptMaterialsOutput, Error>)
      decreases input, output

    method DecryptMaterials(input: DecryptMaterialsInput) returns (output: Result<DecryptMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DecryptMaterials
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures History.DecryptMaterials == old(History.DecryptMaterials) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := DecryptMaterials'(input);
      History.DecryptMaterials := History.DecryptMaterials + [DafnyCallEvent(input, output)];
    }

    method DecryptMaterials'(input: DecryptMaterialsInput) returns (output: Result<DecryptMaterialsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype DBEAlgorithmSuiteId = ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384 | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384

  datatype DBECommitmentPolicy = REQUIRE_ENCRYPT_REQUIRE_DECRYPT

  type DdbTableArn = string

  datatype DecryptionMaterials = DecryptionMaterials(nameonly algorithmSuite: AlgorithmSuiteInfo, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly plaintextDataKey: Option<Secret> := Option.None, nameonly verificationKey: Option<Secret> := Option.None, nameonly symmetricSigningKey: Option<Secret> := Option.None)

  datatype DecryptMaterialsInput = DecryptMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy, nameonly encryptedDataKeys: EncryptedDataKeyList, nameonly encryptionContext: EncryptionContext, nameonly reproducedEncryptionContext: Option<EncryptionContext> := Option.None)

  datatype DecryptMaterialsOutput = DecryptMaterialsOutput(nameonly decryptionMaterials: DecryptionMaterials)

  datatype DefaultCache = DefaultCache(nameonly entryCapacity: CountingNumber)

  datatype DeleteCacheEntryInput = DeleteCacheEntryInput(nameonly identifier: seq<uint8>)

  datatype DerivationAlgorithm = HKDF(HKDF: HKDF) | IDENTITY(IDENTITY: IDENTITY) | None(None: None)

  datatype DIRECT_KEY_WRAPPING = DIRECT_KEY_WRAPPING

  datatype DiscoveryFilter = DiscoveryFilter(nameonly accountIds: AccountIdList, nameonly partition: string)

  datatype ECDSA = ECDSA(nameonly curve: AwsCryptographyPrimitivesTypes.ECDSASignatureAlgorithm)

  datatype EdkWrappingAlgorithm = DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING: DIRECT_KEY_WRAPPING) | IntermediateKeyWrapping(IntermediateKeyWrapping: IntermediateKeyWrapping)

  datatype Encrypt = AES_GCM(AES_GCM: AwsCryptographyPrimitivesTypes.AES_GCM)

  datatype EncryptedDataKey = EncryptedDataKey(nameonly keyProviderId: Utf8Bytes, nameonly keyProviderInfo: seq<uint8>, nameonly ciphertext: seq<uint8>)

  type EncryptedDataKeyList = seq<EncryptedDataKey>

  type EncryptionContext = map<Utf8Bytes, Utf8Bytes>

  type EncryptionContextKeys = seq<Utf8Bytes>

  datatype EncryptionMaterials = EncryptionMaterials(nameonly algorithmSuite: AlgorithmSuiteInfo, nameonly encryptionContext: EncryptionContext, nameonly encryptedDataKeys: EncryptedDataKeyList, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly plaintextDataKey: Option<Secret> := Option.None, nameonly signingKey: Option<Secret> := Option.None, nameonly symmetricSigningKeys: Option<SymmetricSigningKeyList> := Option.None)

  datatype EphemeralPrivateKeyToStaticPublicKeyInput = EphemeralPrivateKeyToStaticPublicKeyInput(nameonly recipientPublicKey: seq<uint8>)

  datatype ESDKAlgorithmSuiteId = ALG_AES_128_GCM_IV12_TAG16_NO_KDF | ALG_AES_192_GCM_IV12_TAG16_NO_KDF | ALG_AES_256_GCM_IV12_TAG16_NO_KDF | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 | ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 | ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 | ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY | ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384

  datatype ESDKCommitmentPolicy = FORBID_ENCRYPT_ALLOW_DECRYPT | REQUIRE_ENCRYPT_ALLOW_DECRYPT | REQUIRE_ENCRYPT_REQUIRE_DECRYPT

  datatype GetBranchKeyIdInput = GetBranchKeyIdInput(nameonly encryptionContext: EncryptionContext)

  datatype GetBranchKeyIdOutput = GetBranchKeyIdOutput(nameonly branchKeyId: string)

  datatype GetCacheEntryInput = GetCacheEntryInput(nameonly identifier: seq<uint8>, nameonly bytesUsed: Option<int64> := Option.None)

  datatype GetCacheEntryOutput = GetCacheEntryOutput(nameonly materials: Materials, nameonly creationTime: PositiveLong, nameonly expiryTime: PositiveLong, nameonly messagesUsed: PositiveInteger, nameonly bytesUsed: PositiveInteger)

  datatype GetClientInput = GetClientInput(nameonly region: Region)

  datatype GetEncryptionMaterialsInput = GetEncryptionMaterialsInput(nameonly encryptionContext: EncryptionContext, nameonly commitmentPolicy: CommitmentPolicy, nameonly algorithmSuiteId: Option<AlgorithmSuiteId> := Option.None, nameonly maxPlaintextLength: Option<int64> := Option.None, nameonly requiredEncryptionContextKeys: Option<EncryptionContextKeys> := Option.None)

  datatype GetEncryptionMaterialsOutput = GetEncryptionMaterialsOutput(nameonly encryptionMaterials: EncryptionMaterials)

  type GrantTokenList = seq<string>

  datatype HKDF = HKDF(nameonly hmac: AwsCryptographyPrimitivesTypes.DigestAlgorithm, nameonly saltLength: AwsCryptographyPrimitivesTypes.PositiveInteger, nameonly inputKeyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength, nameonly outputKeyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength)

  datatype IDENTITY = IDENTITY

  datatype InitializeDecryptionMaterialsInput = InitializeDecryptionMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys)

  datatype InitializeEncryptionMaterialsInput = InitializeEncryptionMaterialsInput(nameonly algorithmSuiteId: AlgorithmSuiteId, nameonly encryptionContext: EncryptionContext, nameonly requiredEncryptionContextKeys: EncryptionContextKeys, nameonly signingKey: Option<Secret> := Option.None, nameonly verificationKey: Option<Secret> := Option.None)

  datatype IntermediateKeyWrapping = IntermediateKeyWrapping(nameonly keyEncryptionKeyKdf: DerivationAlgorithm, nameonly macKeyKdf: DerivationAlgorithm, nameonly pdkEncryptAlgorithm: Encrypt)

  datatype KeyAgreementScheme = StaticConfiguration(StaticConfiguration: StaticConfigurations)

  type KeyringList = seq<IKeyring>

  class IKeyringCallHistory {
    ghost constructor ()
    {
      OnEncrypt := [];
      OnDecrypt := [];
    }

    ghost var OnEncrypt: seq<DafnyCallEvent<OnEncryptInput, Result<OnEncryptOutput, Error>>>
    ghost var OnDecrypt: seq<DafnyCallEvent<OnDecryptInput, Result<OnDecryptOutput, Error>>>
  }

  trait {:termination false} IKeyring {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IKeyringCallHistory

    predicate OnEncryptEnsuresPublicly(input: OnEncryptInput, output: Result<OnEncryptOutput, Error>)
      decreases input, output

    method OnEncrypt(input: OnEncryptInput) returns (output: Result<OnEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`OnEncrypt
      ensures true && ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures History.OnEncrypt == old(History.OnEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := OnEncrypt'(input);
      History.OnEncrypt := History.OnEncrypt + [DafnyCallEvent(input, output)];
    }

    method OnEncrypt'(input: OnEncryptInput) returns (output: Result<OnEncryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}

    predicate OnDecryptEnsuresPublicly(input: OnDecryptInput, output: Result<OnDecryptOutput, Error>)
      decreases input, output

    method OnDecrypt(input: OnDecryptInput) returns (output: Result<OnDecryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`OnDecrypt
      ensures true && ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures History.OnDecrypt == old(History.OnDecrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := OnDecrypt'(input);
      History.OnDecrypt := History.OnDecrypt + [DafnyCallEvent(input, output)];
    }

    method OnDecrypt'(input: OnDecryptInput) returns (output: Result<OnDecryptOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
  }

  datatype KmsEcdhStaticConfigurations = KmsPublicKeyDiscovery(KmsPublicKeyDiscovery: KmsPublicKeyDiscoveryInput) | KmsPrivateKeyToStaticPublicKey(KmsPrivateKeyToStaticPublicKey: KmsPrivateKeyToStaticPublicKeyInput)

  type KmsKeyId = string

  type KmsKeyIdList = seq<KmsKeyId>

  datatype KmsPrivateKeyToStaticPublicKeyInput = KmsPrivateKeyToStaticPublicKeyInput(nameonly senderKmsIdentifier: KmsKeyId, nameonly senderPublicKey: Option<seq<uint8>> := Option.None, nameonly recipientPublicKey: seq<uint8>)

  datatype KmsPublicKeyDiscoveryInput = KmsPublicKeyDiscoveryInput(nameonly recipientKmsIdentifier: KmsKeyId)

  datatype MaterialProvidersConfig = MaterialProvidersConfig

  datatype Materials = Encryption(Encryption: EncryptionMaterials) | Decryption(Decryption: DecryptionMaterials) | BranchKey(BranchKey: AwsCryptographyKeyStoreTypes.BranchKeyMaterials) | BeaconKey(BeaconKey: AwsCryptographyKeyStoreTypes.BeaconKeyMaterials)

  datatype MultiThreadedCache = MultiThreadedCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber> := Option.None)

  datatype NoCache = NoCache

  datatype None = None

  datatype OnDecryptInput = OnDecryptInput(nameonly materials: DecryptionMaterials, nameonly encryptedDataKeys: EncryptedDataKeyList)

  datatype OnDecryptOutput = OnDecryptOutput(nameonly materials: DecryptionMaterials)

  datatype OnEncryptInput = OnEncryptInput(nameonly materials: EncryptionMaterials)

  datatype OnEncryptOutput = OnEncryptOutput(nameonly materials: EncryptionMaterials)

  datatype PaddingScheme = PKCS1 | OAEP_SHA1_MGF1 | OAEP_SHA256_MGF1 | OAEP_SHA384_MGF1 | OAEP_SHA512_MGF1

  type PositiveInteger = x: int32
    | IsValid_PositiveInteger(x)
    witness *

  type PositiveLong = x: int64
    | IsValid_PositiveLong(x)
    witness *

  datatype PublicKeyDiscoveryInput = PublicKeyDiscoveryInput(nameonly recipientStaticPrivateKey: seq<uint8>)

  datatype PutCacheEntryInput = PutCacheEntryInput(nameonly identifier: seq<uint8>, nameonly materials: Materials, nameonly creationTime: PositiveLong, nameonly expiryTime: PositiveLong, nameonly messagesUsed: Option<PositiveInteger> := Option.None, nameonly bytesUsed: Option<PositiveInteger> := Option.None)

  datatype RawEcdhStaticConfigurations = PublicKeyDiscovery(PublicKeyDiscovery: PublicKeyDiscoveryInput) | RawPrivateKeyToStaticPublicKey(RawPrivateKeyToStaticPublicKey: RawPrivateKeyToStaticPublicKeyInput) | EphemeralPrivateKeyToStaticPublicKey(EphemeralPrivateKeyToStaticPublicKey: EphemeralPrivateKeyToStaticPublicKeyInput)

  datatype RawPrivateKeyToStaticPublicKeyInput = RawPrivateKeyToStaticPublicKeyInput(nameonly senderStaticPrivateKey: seq<uint8>, nameonly recipientPublicKey: seq<uint8>)

  type Region = string

  type RegionList = seq<Region>

  type Secret = seq<uint8>

  datatype SignatureAlgorithm = ECDSA(ECDSA: ECDSA) | None(None: None)

  datatype SingleThreadedCache = SingleThreadedCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber> := Option.None)

  datatype StaticConfigurations = AWS_KMS_ECDH(AWS_KMS_ECDH: KmsEcdhStaticConfigurations) | RAW_ECDH(RAW_ECDH: RawEcdhStaticConfigurations)

  datatype StormTrackingCache = StormTrackingCache(nameonly entryCapacity: CountingNumber, nameonly entryPruningTailSize: Option<CountingNumber> := Option.None, nameonly gracePeriod: CountingNumber, nameonly graceInterval: CountingNumber, nameonly fanOut: CountingNumber, nameonly inFlightTTL: CountingNumber, nameonly sleepMilli: CountingNumber, nameonly timeUnits: Option<TimeUnits> := Option.None)

  datatype SymmetricSignatureAlgorithm = HMAC(HMAC: AwsCryptographyPrimitivesTypes.DigestAlgorithm) | None(None: None)

  type SymmetricSigningKeyList = seq<Secret>

  datatype TimeUnits = Seconds | Milliseconds

  datatype UpdateUsageMetadataInput = UpdateUsageMetadataInput(nameonly identifier: seq<uint8>, nameonly bytesUsed: PositiveInteger)

  type Utf8Bytes = ValidUTF8Bytes

  datatype ValidateCommitmentPolicyOnDecryptInput = ValidateCommitmentPolicyOnDecryptInput(nameonly algorithm: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy)

  datatype ValidateCommitmentPolicyOnEncryptInput = ValidateCommitmentPolicyOnEncryptInput(nameonly algorithm: AlgorithmSuiteId, nameonly commitmentPolicy: CommitmentPolicy)

  datatype ValidDecryptionMaterialsTransitionInput = ValidDecryptionMaterialsTransitionInput(nameonly start: DecryptionMaterials, nameonly stop: DecryptionMaterials)

  datatype ValidEncryptionMaterialsTransitionInput = ValidEncryptionMaterialsTransitionInput(nameonly start: EncryptionMaterials, nameonly stop: EncryptionMaterials)

  datatype Error = AwsCryptographicMaterialProvidersException(nameonly message: string) | EntryAlreadyExists(nameonly message: string) | EntryDoesNotExist(nameonly message: string) | InFlightTTLExceeded(nameonly message: string) | InvalidAlgorithmSuiteInfo(nameonly message: string) | InvalidAlgorithmSuiteInfoOnDecrypt(nameonly message: string) | InvalidAlgorithmSuiteInfoOnEncrypt(nameonly message: string) | InvalidDecryptionMaterials(nameonly message: string) | InvalidDecryptionMaterialsTransition(nameonly message: string) | InvalidEncryptionMaterials(nameonly message: string) | InvalidEncryptionMaterialsTransition(nameonly message: string) | AwsCryptographyKeyStore(AwsCryptographyKeyStore: AwsCryptographyKeyStoreTypes.Error) | AwsCryptographyPrimitives(AwsCryptographyPrimitives: AwsCryptographyPrimitivesTypes.Error) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | ComAmazonawsKms(ComAmazonawsKms: ComAmazonawsKmsTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyMaterialProvidersService {
  function method DefaultMaterialProvidersConfig(): MaterialProvidersConfig

  method MaterialProviders(config: MaterialProvidersConfig := DefaultMaterialProvidersConfig()) returns (res: Result<MaterialProvidersClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IAwsCryptographicMaterialProvidersClient): Result<IAwsCryptographicMaterialProvidersClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IAwsCryptographicMaterialProvidersClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes

  import Operations : AbstractAwsCryptographyMaterialProvidersOperations

  class MaterialProvidersClient extends IAwsCryptographicMaterialProvidersClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsKeyring(input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsKeyring == old(History.CreateAwsKmsKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsKeyring(config, input);
      History.CreateAwsKmsKeyring := History.CreateAwsKmsKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryKeyring(input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryKeyring == old(History.CreateAwsKmsDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsDiscoveryKeyring(config, input);
      History.CreateAwsKmsDiscoveryKeyring := History.CreateAwsKmsDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMultiKeyring(input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMultiKeyring == old(History.CreateAwsKmsMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMultiKeyring(config, input);
      History.CreateAwsKmsMultiKeyring := History.CreateAwsKmsMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsDiscoveryMultiKeyring(input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsDiscoveryMultiKeyring == old(History.CreateAwsKmsDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsDiscoveryMultiKeyring := History.CreateAwsKmsDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkKeyring(input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkKeyring == old(History.CreateAwsKmsMrkKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkKeyring(config, input);
      History.CreateAwsKmsMrkKeyring := History.CreateAwsKmsMrkKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkMultiKeyring(input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkMultiKeyring == old(History.CreateAwsKmsMrkMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkMultiKeyring(config, input);
      History.CreateAwsKmsMrkMultiKeyring := History.CreateAwsKmsMrkMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryKeyring(input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsMrkDiscoveryKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryKeyring == old(History.CreateAwsKmsMrkDiscoveryKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsMrkDiscoveryKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryKeyring := History.CreateAwsKmsMrkDiscoveryKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsMrkDiscoveryMultiKeyring(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.clientSupplier.Some? ==> input.clientSupplier.value.ValidState() && input.clientSupplier.value.Modifies !! {History})
      modifies Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}, History`CreateAwsKmsMrkDiscoveryMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
      ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsMrkDiscoveryMultiKeyring == old(History.CreateAwsKmsMrkDiscoveryMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsMrkDiscoveryMultiKeyring(config, input);
      History.CreateAwsKmsMrkDiscoveryMultiKeyring := History.CreateAwsKmsMrkDiscoveryMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsHierarchicalKeyring(input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.branchKeyIdSupplier.Some? ==> input.branchKeyIdSupplier.value.ValidState() && input.branchKeyIdSupplier.value.Modifies !! {History}) && input.keyStore.ValidState() && input.keyStore.Modifies !! {History} && (input.cache.Some? ==> false || (input.cache.value.Shared? ==> input.cache.value.Shared.ValidState() && input.cache.value.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}, History`CreateAwsKmsHierarchicalKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies - if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}))
      ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsHierarchicalKeyring == old(History.CreateAwsKmsHierarchicalKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}
    {
      output := Operations.CreateAwsKmsHierarchicalKeyring(config, input);
      History.CreateAwsKmsHierarchicalKeyring := History.CreateAwsKmsHierarchicalKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsRsaKeyring(input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.kmsClient.Some? ==> input.kmsClient.value.ValidState() && input.kmsClient.value.Modifies !! {History})
      modifies Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}, History`CreateAwsKmsRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
      ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsRsaKeyring == old(History.CreateAwsKmsRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    {
      output := Operations.CreateAwsKmsRsaKeyring(config, input);
      History.CreateAwsKmsRsaKeyring := History.CreateAwsKmsRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateAwsKmsEcdhKeyringEnsuresPublicly(input: CreateAwsKmsEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
    }

    method CreateAwsKmsEcdhKeyring(input: CreateAwsKmsEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && input.kmsClient.ValidState() && input.kmsClient.Modifies !! {History}
      modifies Modifies - {History}, input.kmsClient.Modifies, History`CreateAwsKmsEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.kmsClient.Modifies))
      ensures CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateAwsKmsEcdhKeyring == old(History.CreateAwsKmsEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.kmsClient.Modifies
    {
      output := Operations.CreateAwsKmsEcdhKeyring(config, input);
      History.CreateAwsKmsEcdhKeyring := History.CreateAwsKmsEcdhKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateMultiKeyringEnsuresPublicly(input, output)
    }

    method CreateMultiKeyring(input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
      requires ValidState() && (input.generator.Some? ==> input.generator.value.ValidState() && input.generator.value.Modifies !! {History}) && forall i: IKeyring {:trigger i.Modifies} {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState() && i.Modifies !! {History}
      modifies Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m, History`CreateMultiKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
      ensures CreateMultiKeyringEnsuresPublicly(input, output)
      ensures History.CreateMultiKeyring == old(History.CreateMultiKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    {
      output := Operations.CreateMultiKeyring(config, input);
      History.CreateMultiKeyring := History.CreateMultiKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawAesKeyringEnsuresPublicly(input, output)
    }

    method CreateRawAesKeyring(input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawAesKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawAesKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawAesKeyring == old(History.CreateRawAesKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawAesKeyring(config, input);
      History.CreateRawAesKeyring := History.CreateRawAesKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawRsaKeyringEnsuresPublicly(input, output)
    }

    method CreateRawRsaKeyring(input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawRsaKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawRsaKeyring == old(History.CreateRawRsaKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawRsaKeyring(config, input);
      History.CreateRawRsaKeyring := History.CreateRawRsaKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateRawEcdhKeyringEnsuresPublicly(input: CreateRawEcdhKeyringInput, output: Result<IKeyring, Error>)
      decreases input, output
    {
      Operations.CreateRawEcdhKeyringEnsuresPublicly(input, output)
    }

    method CreateRawEcdhKeyring(input: CreateRawEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateRawEcdhKeyring
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateRawEcdhKeyringEnsuresPublicly(input, output)
      ensures History.CreateRawEcdhKeyring == old(History.CreateRawEcdhKeyring) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateRawEcdhKeyring(config, input);
      History.CreateRawEcdhKeyring := History.CreateRawEcdhKeyring + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    }

    method CreateDefaultCryptographicMaterialsManager(input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && input.keyring.ValidState() && input.keyring.Modifies !! {History}
      modifies Modifies - {History}, input.keyring.Modifies, History`CreateDefaultCryptographicMaterialsManager
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - input.keyring.Modifies))
      ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
      ensures History.CreateDefaultCryptographicMaterialsManager == old(History.CreateDefaultCryptographicMaterialsManager) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, input.keyring.Modifies
    {
      output := Operations.CreateDefaultCryptographicMaterialsManager(config, input);
      History.CreateDefaultCryptographicMaterialsManager := History.CreateDefaultCryptographicMaterialsManager + [DafnyCallEvent(input, output)];
    }

    predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
      decreases input, output
    {
      Operations.CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    }

    method CreateRequiredEncryptionContextCMM(input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
      requires ValidState() && (input.underlyingCMM.Some? ==> input.underlyingCMM.value.ValidState() && input.underlyingCMM.value.Modifies !! {History}) && (input.keyring.Some? ==> input.keyring.value.ValidState() && input.keyring.value.Modifies !! {History})
      modifies Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}, History`CreateRequiredEncryptionContextCMM
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
      ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
      ensures History.CreateRequiredEncryptionContextCMM == old(History.CreateRequiredEncryptionContextCMM) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    {
      output := Operations.CreateRequiredEncryptionContextCMM(config, input);
      History.CreateRequiredEncryptionContextCMM := History.CreateRequiredEncryptionContextCMM + [DafnyCallEvent(input, output)];
    }

    predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
      decreases input, output
    {
      Operations.CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    }

    method CreateCryptographicMaterialsCache(input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
      requires ValidState() && (false || (input.cache.Shared? ==> input.cache.Shared.ValidState() && input.cache.Shared.Modifies !! {History}))
      modifies Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}, History`CreateCryptographicMaterialsCache
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History} - if input.cache.Shared? then input.cache.Shared.Modifies else {}))
      ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
      ensures History.CreateCryptographicMaterialsCache == old(History.CreateCryptographicMaterialsCache) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}, if input.cache.Shared? then input.cache.Shared.Modifies else {}
    {
      output := Operations.CreateCryptographicMaterialsCache(config, input);
      History.CreateCryptographicMaterialsCache := History.CreateCryptographicMaterialsCache + [DafnyCallEvent(input, output)];
    }

    predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
      decreases input, output
    {
      Operations.CreateDefaultClientSupplierEnsuresPublicly(input, output)
    }

    method CreateDefaultClientSupplier(input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateDefaultClientSupplier
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! {History} && fresh(output.value) && fresh(output.value.Modifies - Modifies - {History}))
      ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
      ensures History.CreateDefaultClientSupplier == old(History.CreateDefaultClientSupplier) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateDefaultClientSupplier(config, input);
      History.CreateDefaultClientSupplier := History.CreateDefaultClientSupplier + [DafnyCallEvent(input, output)];
    }

    function method InitializeEncryptionMaterials(input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeEncryptionMaterials(config, input)
    }

    function method InitializeDecryptionMaterials(input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
      decreases input
    {
      Operations.InitializeDecryptionMaterials(config, input)
    }

    function method ValidEncryptionMaterialsTransition(input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidEncryptionMaterialsTransition(config, input)
    }

    function method ValidDecryptionMaterialsTransition(input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidDecryptionMaterialsTransition(config, input)
    }

    function method EncryptionMaterialsHasPlaintextDataKey(input: EncryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.EncryptionMaterialsHasPlaintextDataKey(config, input)
    }

    function method DecryptionMaterialsWithPlaintextDataKey(input: DecryptionMaterials): (output: Result<(), Error>)
      decreases input
    {
      Operations.DecryptionMaterialsWithPlaintextDataKey(config, input)
    }

    function method GetAlgorithmSuiteInfo(input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
      decreases input
    {
      Operations.GetAlgorithmSuiteInfo(config, input)
    }

    function method ValidAlgorithmSuiteInfo(input: AlgorithmSuiteInfo): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidAlgorithmSuiteInfo(config, input)
    }

    function method ValidateCommitmentPolicyOnEncrypt(input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnEncrypt(config, input)
    }

    function method ValidateCommitmentPolicyOnDecrypt(input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
      decreases input
    {
      Operations.ValidateCommitmentPolicyOnDecrypt(config, input)
    }
  }
}

abstract module AbstractAwsCryptographyMaterialProvidersOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate CreateAwsKmsKeyringEnsuresPublicly(input: CreateAwsKmsKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsKeyring(config: InternalConfig, input: CreateAwsKmsKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMultiKeyringEnsuresPublicly(input: CreateAwsKmsMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMultiKeyring(config: InternalConfig, input: CreateAwsKmsMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsMrkKeyringEnsuresPublicly(input: CreateAwsKmsMrkKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkKeyring(config: InternalConfig, input: CreateAwsKmsMrkKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkDiscoveryKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsMrkDiscoveryKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input: CreateAwsKmsMrkDiscoveryMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsMrkDiscoveryMultiKeyring(config: InternalConfig, input: CreateAwsKmsMrkDiscoveryMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.clientSupplier.Some? ==> true && input.clientSupplier.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}))
    ensures CreateAwsKmsMrkDiscoveryMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.clientSupplier.Some? then input.clientSupplier.value.Modifies else {}

  predicate CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input: CreateAwsKmsHierarchicalKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsHierarchicalKeyring(config: InternalConfig, input: CreateAwsKmsHierarchicalKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.branchKeyIdSupplier.Some? ==> true && input.branchKeyIdSupplier.value.ValidState()) && input.keyStore.ValidState() && (input.cache.Some? ==> false || (input.cache.value.Shared? ==> true && input.cache.value.Shared.ValidState()))
    modifies ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}) - input.keyStore.Modifies - if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}))
    ensures CreateAwsKmsHierarchicalKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.branchKeyIdSupplier.Some? then input.branchKeyIdSupplier.value.Modifies else {}, input.keyStore.Modifies, if input.cache.Some? then if input.cache.value.Shared? then input.cache.value.Shared.Modifies else {} else {}

  predicate CreateAwsKmsRsaKeyringEnsuresPublicly(input: CreateAwsKmsRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsRsaKeyring(config: InternalConfig, input: CreateAwsKmsRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.kmsClient.Some? ==> true && input.kmsClient.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}))
    ensures CreateAwsKmsRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.kmsClient.Some? then input.kmsClient.value.Modifies else {}

  predicate CreateAwsKmsEcdhKeyringEnsuresPublicly(input: CreateAwsKmsEcdhKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateAwsKmsEcdhKeyring(config: InternalConfig, input: CreateAwsKmsEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && input.kmsClient.ValidState()
    modifies ModifiesInternalConfig(config), input.kmsClient.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.kmsClient.Modifies))
    ensures CreateAwsKmsEcdhKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.kmsClient.Modifies

  predicate CreateMultiKeyringEnsuresPublicly(input: CreateMultiKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateMultiKeyring(config: InternalConfig, input: CreateMultiKeyringInput) returns (output: Result<IKeyring, Error>)
    requires ValidInternalConfig?(config) && (input.generator.Some? ==> true && input.generator.value.ValidState()) && forall i: IKeyring {:trigger i.ValidState()} {:trigger i in input.childKeyrings} | i in input.childKeyrings :: i.ValidState()
    modifies ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.generator.Some? then input.generator.value.Modifies else {}) - set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m))
    ensures CreateMultiKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.generator.Some? then input.generator.value.Modifies else {}, set i: IKeyring, m: object {:trigger m in i.Modifies} | i in input.childKeyrings && m in i.Modifies :: m

  predicate CreateRawAesKeyringEnsuresPublicly(input: CreateRawAesKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateRawAesKeyring(config: InternalConfig, input: CreateRawAesKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawAesKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateRawRsaKeyringEnsuresPublicly(input: CreateRawRsaKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateRawRsaKeyring(config: InternalConfig, input: CreateRawRsaKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawRsaKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateRawEcdhKeyringEnsuresPublicly(input: CreateRawEcdhKeyringInput, output: Result<IKeyring, Error>)
    decreases input, output

  method CreateRawEcdhKeyring(config: InternalConfig, input: CreateRawEcdhKeyringInput) returns (output: Result<IKeyring, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateRawEcdhKeyringEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input: CreateDefaultCryptographicMaterialsManagerInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output

  method CreateDefaultCryptographicMaterialsManager(config: InternalConfig, input: CreateDefaultCryptographicMaterialsManagerInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && input.keyring.ValidState()
    modifies ModifiesInternalConfig(config), input.keyring.Modifies
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - input.keyring.Modifies))
    ensures CreateDefaultCryptographicMaterialsManagerEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), input.keyring.Modifies

  predicate CreateRequiredEncryptionContextCMMEnsuresPublicly(input: CreateRequiredEncryptionContextCMMInput, output: Result<ICryptographicMaterialsManager, Error>)
    decreases input, output

  method CreateRequiredEncryptionContextCMM(config: InternalConfig, input: CreateRequiredEncryptionContextCMMInput) returns (output: Result<ICryptographicMaterialsManager, Error>)
    requires ValidInternalConfig?(config) && (input.underlyingCMM.Some? ==> true && input.underlyingCMM.value.ValidState()) && (input.keyring.Some? ==> true && input.keyring.value.ValidState())
    modifies ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - (if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}) - if input.keyring.Some? then input.keyring.value.Modifies else {}))
    ensures CreateRequiredEncryptionContextCMMEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.underlyingCMM.Some? then input.underlyingCMM.value.Modifies else {}, if input.keyring.Some? then input.keyring.value.Modifies else {}

  predicate CreateCryptographicMaterialsCacheEnsuresPublicly(input: CreateCryptographicMaterialsCacheInput, output: Result<ICryptographicMaterialsCache, Error>)
    decreases input, output

  method CreateCryptographicMaterialsCache(config: InternalConfig, input: CreateCryptographicMaterialsCacheInput) returns (output: Result<ICryptographicMaterialsCache, Error>)
    requires ValidInternalConfig?(config) && (false || (input.cache.Shared? ==> true && input.cache.Shared.ValidState()))
    modifies ModifiesInternalConfig(config), if input.cache.Shared? then input.cache.Shared.Modifies else {}
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config) - if input.cache.Shared? then input.cache.Shared.Modifies else {}))
    ensures CreateCryptographicMaterialsCacheEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config), if input.cache.Shared? then input.cache.Shared.Modifies else {}

  predicate CreateDefaultClientSupplierEnsuresPublicly(input: CreateDefaultClientSupplierInput, output: Result<IClientSupplier, Error>)
    decreases input, output

  method CreateDefaultClientSupplier(config: InternalConfig, input: CreateDefaultClientSupplierInput) returns (output: Result<IClientSupplier, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures ValidInternalConfig?(config) && (output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.Modifies - ModifiesInternalConfig(config)))
    ensures CreateDefaultClientSupplierEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  function method InitializeEncryptionMaterials(config: InternalConfig, input: InitializeEncryptionMaterialsInput): (output: Result<EncryptionMaterials, Error>)
    decreases input

  function method InitializeDecryptionMaterials(config: InternalConfig, input: InitializeDecryptionMaterialsInput): (output: Result<DecryptionMaterials, Error>)
    decreases input

  function method ValidEncryptionMaterialsTransition(config: InternalConfig, input: ValidEncryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input

  function method ValidDecryptionMaterialsTransition(config: InternalConfig, input: ValidDecryptionMaterialsTransitionInput): (output: Result<(), Error>)
    decreases input

  function method EncryptionMaterialsHasPlaintextDataKey(config: InternalConfig, input: EncryptionMaterials): (output: Result<(), Error>)
    decreases input

  function method DecryptionMaterialsWithPlaintextDataKey(config: InternalConfig, input: DecryptionMaterials): (output: Result<(), Error>)
    decreases input

  function method GetAlgorithmSuiteInfo(config: InternalConfig, input: seq<uint8>): (output: Result<AlgorithmSuiteInfo, Error>)
    decreases input

  function method ValidAlgorithmSuiteInfo(config: InternalConfig, input: AlgorithmSuiteInfo): (output: Result<(), Error>)
    decreases input

  function method ValidateCommitmentPolicyOnEncrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnEncryptInput): (output: Result<(), Error>)
    decreases input

  function method ValidateCommitmentPolicyOnDecrypt(config: InternalConfig, input: ValidateCommitmentPolicyOnDecryptInput): (output: Result<(), Error>)
    decreases input

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyMaterialProvidersTypes

  type InternalConfig
}

module {:extern "software.amazon.cryptography.services.kms.internaldafny.types"} ComAmazonawsKmsTypes {
  predicate method IsValid_AliasNameType(x: string)
    decreases x
  {
    1 <= |x| <= 256
  }

  predicate method IsValid_ArnType(x: string)
    decreases x
  {
    20 <= |x| <= 2048
  }

  predicate method IsValid_AttestationDocumentType(x: seq<uint8>)
    decreases x
  {
    1 <= |x| <= 262144
  }

  predicate method IsValid_CiphertextType(x: seq<uint8>)
    decreases x
  {
    1 <= |x| <= 6144
  }

  predicate method IsValid_CloudHsmClusterIdType(x: string)
    decreases x
  {
    19 <= |x| <= 24
  }

  predicate method IsValid_CustomKeyStoreIdType(x: string)
    decreases x
  {
    1 <= |x| <= 64
  }

  predicate method IsValid_CustomKeyStoreNameType(x: string)
    decreases x
  {
    1 <= |x| <= 256
  }

  predicate method IsValid_DescriptionType(x: string)
    decreases x
  {
    0 <= |x| <= 8192
  }

  predicate method IsValid_GrantIdType(x: string)
    decreases x
  {
    1 <= |x| <= 128
  }

  predicate method IsValid_GrantNameType(x: string)
    decreases x
  {
    1 <= |x| <= 256
  }

  predicate method IsValid_GrantTokenList(x: seq<GrantTokenType>)
    decreases x
  {
    0 <= |x| <= 10
  }

  predicate method IsValid_GrantTokenType(x: string)
    decreases x
  {
    1 <= |x| <= 8192
  }

  predicate method IsValid_KeyIdType(x: string)
    decreases x
  {
    1 <= |x| <= 2048
  }

  predicate method IsValid_KeyStorePasswordType(x: string)
    decreases x
  {
    7 <= |x| <= 32
  }

  predicate method IsValid_LimitType(x: int32)
    decreases x
  {
    1 <= x <= 1000
  }

  predicate method IsValid_MarkerType(x: string)
    decreases x
  {
    1 <= |x| <= 1024
  }

  predicate method IsValid_NumberOfBytesType(x: int32)
    decreases x
  {
    1 <= x <= 1024
  }

  predicate method IsValid_PendingWindowInDaysType(x: int32)
    decreases x
  {
    1 <= x <= 365
  }

  predicate method IsValid_PlaintextType(x: seq<uint8>)
    decreases x
  {
    1 <= |x| <= 4096
  }

  predicate method IsValid_PolicyNameType(x: string)
    decreases x
  {
    1 <= |x| <= 128
  }

  predicate method IsValid_PolicyType(x: string)
    decreases x
  {
    1 <= |x| <= 131072
  }

  predicate method IsValid_PrincipalIdType(x: string)
    decreases x
  {
    1 <= |x| <= 256
  }

  predicate method IsValid_PublicKeyType(x: seq<uint8>)
    decreases x
  {
    1 <= |x| <= 8192
  }

  predicate method IsValid_RegionType(x: string)
    decreases x
  {
    1 <= |x| <= 32
  }

  predicate method IsValid_RotationPeriodInDaysType(x: int32)
    decreases x
  {
    90 <= x <= 2560
  }

  predicate method IsValid_TagKeyType(x: string)
    decreases x
  {
    1 <= |x| <= 128
  }

  predicate method IsValid_TagValueType(x: string)
    decreases x
  {
    0 <= |x| <= 256
  }

  predicate method IsValid_TrustAnchorCertificateType(x: string)
    decreases x
  {
    1 <= |x| <= 5000
  }

  predicate method IsValid_XksKeyIdType(x: string)
    decreases x
  {
    1 <= |x| <= 128
  }

  predicate method IsValid_XksProxyAuthenticationAccessKeyIdType(x: string)
    decreases x
  {
    20 <= |x| <= 30
  }

  predicate method IsValid_XksProxyAuthenticationRawSecretAccessKeyType(x: string)
    decreases x
  {
    43 <= |x| <= 64
  }

  predicate method IsValid_XksProxyUriEndpointType(x: string)
    decreases x
  {
    10 <= |x| <= 128
  }

  predicate method IsValid_XksProxyUriPathType(x: string)
    decreases x
  {
    10 <= |x| <= 128
  }

  predicate method IsValid_XksProxyVpcEndpointServiceNameType(x: string)
    decreases x
  {
    20 <= |x| <= 64
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype AlgorithmSpec = RSAES_PKCS1_V1_5 | RSAES_OAEP_SHA_1 | RSAES_OAEP_SHA_256 | RSA_AES_KEY_WRAP_SHA_1 | RSA_AES_KEY_WRAP_SHA_256 | SM2PKE

  type AliasList = seq<AliasListEntry>

  datatype AliasListEntry = AliasListEntry(nameonly AliasName: Option<AliasNameType> := Option.None, nameonly AliasArn: Option<ArnType> := Option.None, nameonly TargetKeyId: Option<KeyIdType> := Option.None, nameonly CreationDate: Option<string> := Option.None, nameonly LastUpdatedDate: Option<string> := Option.None)

  type AliasNameType = x: string
    | IsValid_AliasNameType(x)
    witness *

  type ArnType = x: string
    | IsValid_ArnType(x)
    witness *

  type AttestationDocumentType = x: seq<uint8>
    | IsValid_AttestationDocumentType(x)
    witness *

  type AWSAccountIdType = string

  type BooleanType = bool

  datatype CancelKeyDeletionRequest = CancelKeyDeletionRequest(nameonly KeyId: KeyIdType)

  datatype CancelKeyDeletionResponse = CancelKeyDeletionResponse(nameonly KeyId: Option<KeyIdType> := Option.None)

  type CiphertextType = x: seq<uint8>
    | IsValid_CiphertextType(x)
    witness *

  type CloudHsmClusterIdType = x: string
    | IsValid_CloudHsmClusterIdType(x)
    witness *

  datatype ConnectCustomKeyStoreRequest = ConnectCustomKeyStoreRequest(nameonly CustomKeyStoreId: CustomKeyStoreIdType)

  datatype ConnectCustomKeyStoreResponse = ConnectCustomKeyStoreResponse

  datatype ConnectionErrorCodeType = INVALID_CREDENTIALS | CLUSTER_NOT_FOUND | NETWORK_ERRORS | INTERNAL_ERROR | INSUFFICIENT_CLOUDHSM_HSMS | USER_LOCKED_OUT | USER_NOT_FOUND | USER_LOGGED_IN | SUBNET_NOT_FOUND | INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET | XKS_PROXY_ACCESS_DENIED | XKS_PROXY_NOT_REACHABLE | XKS_VPC_ENDPOINT_SERVICE_NOT_FOUND | XKS_PROXY_INVALID_RESPONSE | XKS_PROXY_INVALID_CONFIGURATION | XKS_VPC_ENDPOINT_SERVICE_INVALID_CONFIGURATION | XKS_PROXY_TIMED_OUT | XKS_PROXY_INVALID_TLS_CONFIGURATION

  datatype ConnectionStateType = CONNECTED | CONNECTING | FAILED | DISCONNECTED | DISCONNECTING

  datatype CreateAliasRequest = CreateAliasRequest(nameonly AliasName: AliasNameType, nameonly TargetKeyId: KeyIdType)

  datatype CreateCustomKeyStoreRequest = CreateCustomKeyStoreRequest(nameonly CustomKeyStoreName: CustomKeyStoreNameType, nameonly CloudHsmClusterId: Option<CloudHsmClusterIdType> := Option.None, nameonly TrustAnchorCertificate: Option<TrustAnchorCertificateType> := Option.None, nameonly KeyStorePassword: Option<KeyStorePasswordType> := Option.None, nameonly CustomKeyStoreType: Option<CustomKeyStoreType> := Option.None, nameonly XksProxyUriEndpoint: Option<XksProxyUriEndpointType> := Option.None, nameonly XksProxyUriPath: Option<XksProxyUriPathType> := Option.None, nameonly XksProxyVpcEndpointServiceName: Option<XksProxyVpcEndpointServiceNameType> := Option.None, nameonly XksProxyAuthenticationCredential: Option<XksProxyAuthenticationCredentialType> := Option.None, nameonly XksProxyConnectivity: Option<XksProxyConnectivityType> := Option.None)

  datatype CreateCustomKeyStoreResponse = CreateCustomKeyStoreResponse(nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None)

  datatype CreateGrantRequest = CreateGrantRequest(nameonly KeyId: KeyIdType, nameonly GranteePrincipal: PrincipalIdType, nameonly RetiringPrincipal: Option<PrincipalIdType> := Option.None, nameonly Operations: GrantOperationList, nameonly Constraints: Option<GrantConstraints> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly Name: Option<GrantNameType> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype CreateGrantResponse = CreateGrantResponse(nameonly GrantToken: Option<GrantTokenType> := Option.None, nameonly GrantId: Option<GrantIdType> := Option.None)

  datatype CreateKeyRequest = CreateKeyRequest(nameonly Policy: Option<PolicyType> := Option.None, nameonly Description: Option<DescriptionType> := Option.None, nameonly KeyUsage: Option<KeyUsageType> := Option.None, nameonly CustomerMasterKeySpec: Option<CustomerMasterKeySpec> := Option.None, nameonly KeySpec: Option<KeySpec> := Option.None, nameonly Origin: Option<OriginType> := Option.None, nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None, nameonly BypassPolicyLockoutSafetyCheck: Option<BooleanType> := Option.None, nameonly Tags: Option<TagList> := Option.None, nameonly MultiRegion: Option<NullableBooleanType> := Option.None, nameonly XksKeyId: Option<XksKeyIdType> := Option.None)

  datatype CreateKeyResponse = CreateKeyResponse(nameonly KeyMetadata: Option<KeyMetadata> := Option.None)

  datatype CustomerMasterKeySpec = RSA_2048 | RSA_3072 | RSA_4096 | ECC_NIST_P256 | ECC_NIST_P384 | ECC_NIST_P521 | ECC_SECG_P256K1 | SYMMETRIC_DEFAULT | HMAC_224 | HMAC_256 | HMAC_384 | HMAC_512 | SM2

  type CustomKeyStoreIdType = x: string
    | IsValid_CustomKeyStoreIdType(x)
    witness *

  type CustomKeyStoreNameType = x: string
    | IsValid_CustomKeyStoreNameType(x)
    witness *

  type CustomKeyStoresList = seq<CustomKeyStoresListEntry>

  datatype CustomKeyStoresListEntry = CustomKeyStoresListEntry(nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None, nameonly CustomKeyStoreName: Option<CustomKeyStoreNameType> := Option.None, nameonly CloudHsmClusterId: Option<CloudHsmClusterIdType> := Option.None, nameonly TrustAnchorCertificate: Option<TrustAnchorCertificateType> := Option.None, nameonly ConnectionState: Option<ConnectionStateType> := Option.None, nameonly ConnectionErrorCode: Option<ConnectionErrorCodeType> := Option.None, nameonly CreationDate: Option<string> := Option.None, nameonly CustomKeyStoreType: Option<CustomKeyStoreType> := Option.None, nameonly XksProxyConfiguration: Option<XksProxyConfigurationType> := Option.None)

  datatype CustomKeyStoreType = AWS_CLOUDHSM | EXTERNAL_KEY_STORE

  datatype DataKeyPairSpec = RSA_2048 | RSA_3072 | RSA_4096 | ECC_NIST_P256 | ECC_NIST_P384 | ECC_NIST_P521 | ECC_SECG_P256K1 | SM2

  datatype DataKeySpec = AES_256 | AES_128

  datatype DecryptRequest = DecryptRequest(nameonly CiphertextBlob: CiphertextType, nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly EncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly Recipient: Option<RecipientInfo> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype DecryptResponse = DecryptResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly Plaintext: Option<PlaintextType> := Option.None, nameonly EncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly CiphertextForRecipient: Option<CiphertextType> := Option.None)

  datatype DeleteAliasRequest = DeleteAliasRequest(nameonly AliasName: AliasNameType)

  datatype DeleteCustomKeyStoreRequest = DeleteCustomKeyStoreRequest(nameonly CustomKeyStoreId: CustomKeyStoreIdType)

  datatype DeleteCustomKeyStoreResponse = DeleteCustomKeyStoreResponse

  datatype DeleteImportedKeyMaterialRequest = DeleteImportedKeyMaterialRequest(nameonly KeyId: KeyIdType)

  datatype DeriveSharedSecretRequest = DeriveSharedSecretRequest(nameonly KeyId: KeyIdType, nameonly KeyAgreementAlgorithm: KeyAgreementAlgorithmSpec, nameonly PublicKey: PublicKeyType, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None, nameonly Recipient: Option<RecipientInfo> := Option.None)

  datatype DeriveSharedSecretResponse = DeriveSharedSecretResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly SharedSecret: Option<PlaintextType> := Option.None, nameonly CiphertextForRecipient: Option<CiphertextType> := Option.None, nameonly KeyAgreementAlgorithm: Option<KeyAgreementAlgorithmSpec> := Option.None, nameonly KeyOrigin: Option<OriginType> := Option.None)

  datatype DescribeCustomKeyStoresRequest = DescribeCustomKeyStoresRequest(nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None, nameonly CustomKeyStoreName: Option<CustomKeyStoreNameType> := Option.None, nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype DescribeCustomKeyStoresResponse = DescribeCustomKeyStoresResponse(nameonly CustomKeyStores: Option<CustomKeyStoresList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype DescribeKeyRequest = DescribeKeyRequest(nameonly KeyId: KeyIdType, nameonly GrantTokens: Option<GrantTokenList> := Option.None)

  datatype DescribeKeyResponse = DescribeKeyResponse(nameonly KeyMetadata: Option<KeyMetadata> := Option.None)

  type DescriptionType = x: string
    | IsValid_DescriptionType(x)
    witness *

  datatype DisableKeyRequest = DisableKeyRequest(nameonly KeyId: KeyIdType)

  datatype DisableKeyRotationRequest = DisableKeyRotationRequest(nameonly KeyId: KeyIdType)

  datatype DisconnectCustomKeyStoreRequest = DisconnectCustomKeyStoreRequest(nameonly CustomKeyStoreId: CustomKeyStoreIdType)

  datatype DisconnectCustomKeyStoreResponse = DisconnectCustomKeyStoreResponse

  datatype EnableKeyRequest = EnableKeyRequest(nameonly KeyId: KeyIdType)

  datatype EnableKeyRotationRequest = EnableKeyRotationRequest(nameonly KeyId: KeyIdType, nameonly RotationPeriodInDays: Option<RotationPeriodInDaysType> := Option.None)

  datatype EncryptionAlgorithmSpec = SYMMETRIC_DEFAULT | RSAES_OAEP_SHA_1 | RSAES_OAEP_SHA_256

  type EncryptionAlgorithmSpecList = seq<EncryptionAlgorithmSpec>

  type EncryptionContextKey = string

  type EncryptionContextType = map<EncryptionContextKey, EncryptionContextValue>

  type EncryptionContextValue = string

  datatype EncryptRequest = EncryptRequest(nameonly KeyId: KeyIdType, nameonly Plaintext: PlaintextType, nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly EncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype EncryptResponse = EncryptResponse(nameonly CiphertextBlob: Option<CiphertextType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly EncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None)

  type ErrorMessageType = string

  datatype ExpirationModelType = KEY_MATERIAL_EXPIRES | KEY_MATERIAL_DOES_NOT_EXPIRE

  datatype GenerateDataKeyPairRequest = GenerateDataKeyPairRequest(nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly KeyId: KeyIdType, nameonly KeyPairSpec: DataKeyPairSpec, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly Recipient: Option<RecipientInfo> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype GenerateDataKeyPairResponse = GenerateDataKeyPairResponse(nameonly PrivateKeyCiphertextBlob: Option<CiphertextType> := Option.None, nameonly PrivateKeyPlaintext: Option<PlaintextType> := Option.None, nameonly PublicKey: Option<PublicKeyType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly KeyPairSpec: Option<DataKeyPairSpec> := Option.None, nameonly CiphertextForRecipient: Option<CiphertextType> := Option.None)

  datatype GenerateDataKeyPairWithoutPlaintextRequest = GenerateDataKeyPairWithoutPlaintextRequest(nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly KeyId: KeyIdType, nameonly KeyPairSpec: DataKeyPairSpec, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype GenerateDataKeyPairWithoutPlaintextResponse = GenerateDataKeyPairWithoutPlaintextResponse(nameonly PrivateKeyCiphertextBlob: Option<CiphertextType> := Option.None, nameonly PublicKey: Option<PublicKeyType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly KeyPairSpec: Option<DataKeyPairSpec> := Option.None)

  datatype GenerateDataKeyRequest = GenerateDataKeyRequest(nameonly KeyId: KeyIdType, nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly NumberOfBytes: Option<NumberOfBytesType> := Option.None, nameonly KeySpec: Option<DataKeySpec> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly Recipient: Option<RecipientInfo> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype GenerateDataKeyResponse = GenerateDataKeyResponse(nameonly CiphertextBlob: Option<CiphertextType> := Option.None, nameonly Plaintext: Option<PlaintextType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly CiphertextForRecipient: Option<CiphertextType> := Option.None)

  datatype GenerateDataKeyWithoutPlaintextRequest = GenerateDataKeyWithoutPlaintextRequest(nameonly KeyId: KeyIdType, nameonly EncryptionContext: Option<EncryptionContextType> := Option.None, nameonly KeySpec: Option<DataKeySpec> := Option.None, nameonly NumberOfBytes: Option<NumberOfBytesType> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype GenerateDataKeyWithoutPlaintextResponse = GenerateDataKeyWithoutPlaintextResponse(nameonly CiphertextBlob: Option<CiphertextType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None)

  datatype GenerateMacRequest = GenerateMacRequest(nameonly Message: PlaintextType, nameonly KeyId: KeyIdType, nameonly MacAlgorithm: MacAlgorithmSpec, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype GenerateMacResponse = GenerateMacResponse(nameonly Mac: Option<CiphertextType> := Option.None, nameonly MacAlgorithm: Option<MacAlgorithmSpec> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None)

  datatype GenerateRandomRequest = GenerateRandomRequest(nameonly NumberOfBytes: Option<NumberOfBytesType> := Option.None, nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None, nameonly Recipient: Option<RecipientInfo> := Option.None)

  datatype GenerateRandomResponse = GenerateRandomResponse(nameonly Plaintext: Option<PlaintextType> := Option.None, nameonly CiphertextForRecipient: Option<CiphertextType> := Option.None)

  datatype GetKeyPolicyRequest = GetKeyPolicyRequest(nameonly KeyId: KeyIdType, nameonly PolicyName: Option<PolicyNameType> := Option.None)

  datatype GetKeyPolicyResponse = GetKeyPolicyResponse(nameonly Policy: Option<PolicyType> := Option.None, nameonly PolicyName: Option<PolicyNameType> := Option.None)

  datatype GetKeyRotationStatusRequest = GetKeyRotationStatusRequest(nameonly KeyId: KeyIdType)

  datatype GetKeyRotationStatusResponse = GetKeyRotationStatusResponse(nameonly KeyRotationEnabled: Option<BooleanType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly RotationPeriodInDays: Option<RotationPeriodInDaysType> := Option.None, nameonly NextRotationDate: Option<string> := Option.None, nameonly OnDemandRotationStartDate: Option<string> := Option.None)

  datatype GetParametersForImportRequest = GetParametersForImportRequest(nameonly KeyId: KeyIdType, nameonly WrappingAlgorithm: AlgorithmSpec, nameonly WrappingKeySpec: WrappingKeySpec)

  datatype GetParametersForImportResponse = GetParametersForImportResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly ImportToken: Option<CiphertextType> := Option.None, nameonly PublicKey: Option<PlaintextType> := Option.None, nameonly ParametersValidTo: Option<string> := Option.None)

  datatype GetPublicKeyRequest = GetPublicKeyRequest(nameonly KeyId: KeyIdType, nameonly GrantTokens: Option<GrantTokenList> := Option.None)

  datatype GetPublicKeyResponse = GetPublicKeyResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly PublicKey: Option<PublicKeyType> := Option.None, nameonly CustomerMasterKeySpec: Option<CustomerMasterKeySpec> := Option.None, nameonly KeySpec: Option<KeySpec> := Option.None, nameonly KeyUsage: Option<KeyUsageType> := Option.None, nameonly EncryptionAlgorithms: Option<EncryptionAlgorithmSpecList> := Option.None, nameonly SigningAlgorithms: Option<SigningAlgorithmSpecList> := Option.None, nameonly KeyAgreementAlgorithms: Option<KeyAgreementAlgorithmSpecList> := Option.None)

  datatype GrantConstraints = GrantConstraints(nameonly EncryptionContextSubset: Option<EncryptionContextType> := Option.None, nameonly EncryptionContextEquals: Option<EncryptionContextType> := Option.None)

  type GrantIdType = x: string
    | IsValid_GrantIdType(x)
    witness *

  type GrantList = seq<GrantListEntry>

  datatype GrantListEntry = GrantListEntry(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly GrantId: Option<GrantIdType> := Option.None, nameonly Name: Option<GrantNameType> := Option.None, nameonly CreationDate: Option<string> := Option.None, nameonly GranteePrincipal: Option<PrincipalIdType> := Option.None, nameonly RetiringPrincipal: Option<PrincipalIdType> := Option.None, nameonly IssuingAccount: Option<PrincipalIdType> := Option.None, nameonly Operations: Option<GrantOperationList> := Option.None, nameonly Constraints: Option<GrantConstraints> := Option.None)

  type GrantNameType = x: string
    | IsValid_GrantNameType(x)
    witness *

  datatype GrantOperation = Decrypt | Encrypt | GenerateDataKey | GenerateDataKeyWithoutPlaintext | ReEncryptFrom | ReEncryptTo | Sign | Verify | GetPublicKey | CreateGrant | RetireGrant | DescribeKey | GenerateDataKeyPair | GenerateDataKeyPairWithoutPlaintext | GenerateMac | VerifyMac | DeriveSharedSecret

  type GrantOperationList = seq<GrantOperation>

  type GrantTokenList = x: seq<GrantTokenType>
    | IsValid_GrantTokenList(x)
    witness *

  type GrantTokenType = x: string
    | IsValid_GrantTokenType(x)
    witness *

  datatype ImportKeyMaterialRequest = ImportKeyMaterialRequest(nameonly KeyId: KeyIdType, nameonly ImportToken: CiphertextType, nameonly EncryptedKeyMaterial: CiphertextType, nameonly ValidTo: Option<string> := Option.None, nameonly ExpirationModel: Option<ExpirationModelType> := Option.None)

  datatype ImportKeyMaterialResponse = ImportKeyMaterialResponse

  datatype KeyAgreementAlgorithmSpec = ECDH

  type KeyAgreementAlgorithmSpecList = seq<KeyAgreementAlgorithmSpec>

  datatype KeyEncryptionMechanism = RSAES_OAEP_SHA_256

  type KeyIdType = x: string
    | IsValid_KeyIdType(x)
    witness *

  type KeyList = seq<KeyListEntry>

  datatype KeyListEntry = KeyListEntry(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly KeyArn: Option<ArnType> := Option.None)

  datatype KeyManagerType = AWS | CUSTOMER

  datatype KeyMetadata = KeyMetadata(nameonly AWSAccountId: Option<AWSAccountIdType> := Option.None, nameonly KeyId: KeyIdType, nameonly Arn: Option<ArnType> := Option.None, nameonly CreationDate: Option<string> := Option.None, nameonly Enabled: Option<BooleanType> := Option.None, nameonly Description: Option<DescriptionType> := Option.None, nameonly KeyUsage: Option<KeyUsageType> := Option.None, nameonly KeyState: Option<KeyState> := Option.None, nameonly DeletionDate: Option<string> := Option.None, nameonly ValidTo: Option<string> := Option.None, nameonly Origin: Option<OriginType> := Option.None, nameonly CustomKeyStoreId: Option<CustomKeyStoreIdType> := Option.None, nameonly CloudHsmClusterId: Option<CloudHsmClusterIdType> := Option.None, nameonly ExpirationModel: Option<ExpirationModelType> := Option.None, nameonly KeyManager: Option<KeyManagerType> := Option.None, nameonly CustomerMasterKeySpec: Option<CustomerMasterKeySpec> := Option.None, nameonly KeySpec: Option<KeySpec> := Option.None, nameonly EncryptionAlgorithms: Option<EncryptionAlgorithmSpecList> := Option.None, nameonly SigningAlgorithms: Option<SigningAlgorithmSpecList> := Option.None, nameonly KeyAgreementAlgorithms: Option<KeyAgreementAlgorithmSpecList> := Option.None, nameonly MultiRegion: Option<NullableBooleanType> := Option.None, nameonly MultiRegionConfiguration: Option<MultiRegionConfiguration> := Option.None, nameonly PendingDeletionWindowInDays: Option<PendingWindowInDaysType> := Option.None, nameonly MacAlgorithms: Option<MacAlgorithmSpecList> := Option.None, nameonly XksKeyConfiguration: Option<XksKeyConfigurationType> := Option.None)

  datatype KeySpec = RSA_2048 | RSA_3072 | RSA_4096 | ECC_NIST_P256 | ECC_NIST_P384 | ECC_NIST_P521 | ECC_SECG_P256K1 | SYMMETRIC_DEFAULT | HMAC_224 | HMAC_256 | HMAC_384 | HMAC_512 | SM2

  datatype KeyState = Creating | Enabled | Disabled | PendingDeletion | PendingImport | PendingReplicaDeletion | Unavailable | Updating

  type KeyStorePasswordType = x: string
    | IsValid_KeyStorePasswordType(x)
    witness *

  datatype KeyUsageType = SIGN_VERIFY | ENCRYPT_DECRYPT | GENERATE_VERIFY_MAC | KEY_AGREEMENT

  type LimitType = x: int32
    | IsValid_LimitType(x)
    witness *

  datatype ListAliasesRequest = ListAliasesRequest(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype ListAliasesResponse = ListAliasesResponse(nameonly Aliases: Option<AliasList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype ListGrantsRequest = ListGrantsRequest(nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None, nameonly KeyId: KeyIdType, nameonly GrantId: Option<GrantIdType> := Option.None, nameonly GranteePrincipal: Option<PrincipalIdType> := Option.None)

  datatype ListGrantsResponse = ListGrantsResponse(nameonly Grants: Option<GrantList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype ListKeyPoliciesRequest = ListKeyPoliciesRequest(nameonly KeyId: KeyIdType, nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype ListKeyPoliciesResponse = ListKeyPoliciesResponse(nameonly PolicyNames: Option<PolicyNameList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype ListKeyRotationsRequest = ListKeyRotationsRequest(nameonly KeyId: KeyIdType, nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype ListKeyRotationsResponse = ListKeyRotationsResponse(nameonly Rotations: Option<RotationsList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype ListKeysRequest = ListKeysRequest(nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype ListKeysResponse = ListKeysResponse(nameonly Keys: Option<KeyList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype ListResourceTagsRequest = ListResourceTagsRequest(nameonly KeyId: KeyIdType, nameonly Limit: Option<LimitType> := Option.None, nameonly Marker: Option<MarkerType> := Option.None)

  datatype ListResourceTagsResponse = ListResourceTagsResponse(nameonly Tags: Option<TagList> := Option.None, nameonly NextMarker: Option<MarkerType> := Option.None, nameonly Truncated: Option<BooleanType> := Option.None)

  datatype MacAlgorithmSpec = HMAC_SHA_224 | HMAC_SHA_256 | HMAC_SHA_384 | HMAC_SHA_512

  type MacAlgorithmSpecList = seq<MacAlgorithmSpec>

  type MarkerType = x: string
    | IsValid_MarkerType(x)
    witness *

  datatype MessageType = RAW | DIGEST

  datatype MultiRegionConfiguration = MultiRegionConfiguration(nameonly MultiRegionKeyType: Option<MultiRegionKeyType> := Option.None, nameonly PrimaryKey: Option<MultiRegionKey> := Option.None, nameonly ReplicaKeys: Option<MultiRegionKeyList> := Option.None)

  datatype MultiRegionKey = MultiRegionKey(nameonly Arn: Option<ArnType> := Option.None, nameonly Region: Option<RegionType> := Option.None)

  type MultiRegionKeyList = seq<MultiRegionKey>

  datatype MultiRegionKeyType = PRIMARY | REPLICA

  type NullableBooleanType = bool

  type NumberOfBytesType = x: int32
    | IsValid_NumberOfBytesType(x)
    witness *

  datatype OriginType = AWS_KMS | EXTERNAL | AWS_CLOUDHSM | EXTERNAL_KEY_STORE

  type PendingWindowInDaysType = x: int32
    | IsValid_PendingWindowInDaysType(x)
    witness *

  type PlaintextType = x: seq<uint8>
    | IsValid_PlaintextType(x)
    witness *

  type PolicyNameList = seq<PolicyNameType>

  type PolicyNameType = x: string
    | IsValid_PolicyNameType(x)
    witness *

  type PolicyType = x: string
    | IsValid_PolicyType(x)
    witness *

  type PrincipalIdType = x: string
    | IsValid_PrincipalIdType(x)
    witness *

  type PublicKeyType = x: seq<uint8>
    | IsValid_PublicKeyType(x)
    witness *

  datatype PutKeyPolicyRequest = PutKeyPolicyRequest(nameonly KeyId: KeyIdType, nameonly PolicyName: Option<PolicyNameType> := Option.None, nameonly Policy: PolicyType, nameonly BypassPolicyLockoutSafetyCheck: Option<BooleanType> := Option.None)

  datatype RecipientInfo = RecipientInfo(nameonly KeyEncryptionAlgorithm: Option<KeyEncryptionMechanism> := Option.None, nameonly AttestationDocument: Option<AttestationDocumentType> := Option.None)

  datatype ReEncryptRequest = ReEncryptRequest(nameonly CiphertextBlob: CiphertextType, nameonly SourceEncryptionContext: Option<EncryptionContextType> := Option.None, nameonly SourceKeyId: Option<KeyIdType> := Option.None, nameonly DestinationKeyId: KeyIdType, nameonly DestinationEncryptionContext: Option<EncryptionContextType> := Option.None, nameonly SourceEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly DestinationEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype ReEncryptResponse = ReEncryptResponse(nameonly CiphertextBlob: Option<CiphertextType> := Option.None, nameonly SourceKeyId: Option<KeyIdType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly SourceEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None, nameonly DestinationEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> := Option.None)

  type RegionType = x: string
    | IsValid_RegionType(x)
    witness *

  datatype ReplicateKeyRequest = ReplicateKeyRequest(nameonly KeyId: KeyIdType, nameonly ReplicaRegion: RegionType, nameonly Policy: Option<PolicyType> := Option.None, nameonly BypassPolicyLockoutSafetyCheck: Option<BooleanType> := Option.None, nameonly Description: Option<DescriptionType> := Option.None, nameonly Tags: Option<TagList> := Option.None)

  datatype ReplicateKeyResponse = ReplicateKeyResponse(nameonly ReplicaKeyMetadata: Option<KeyMetadata> := Option.None, nameonly ReplicaPolicy: Option<PolicyType> := Option.None, nameonly ReplicaTags: Option<TagList> := Option.None)

  datatype RetireGrantRequest = RetireGrantRequest(nameonly GrantToken: Option<GrantTokenType> := Option.None, nameonly KeyId: Option<KeyIdType> := Option.None, nameonly GrantId: Option<GrantIdType> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype RevokeGrantRequest = RevokeGrantRequest(nameonly KeyId: KeyIdType, nameonly GrantId: GrantIdType, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype RotateKeyOnDemandRequest = RotateKeyOnDemandRequest(nameonly KeyId: KeyIdType)

  datatype RotateKeyOnDemandResponse = RotateKeyOnDemandResponse(nameonly KeyId: Option<KeyIdType> := Option.None)

  type RotationPeriodInDaysType = x: int32
    | IsValid_RotationPeriodInDaysType(x)
    witness *

  type RotationsList = seq<RotationsListEntry>

  datatype RotationsListEntry = RotationsListEntry(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly RotationDate: Option<string> := Option.None, nameonly RotationType: Option<RotationType> := Option.None)

  datatype RotationType = AUTOMATIC | ON_DEMAND

  datatype ScheduleKeyDeletionRequest = ScheduleKeyDeletionRequest(nameonly KeyId: KeyIdType, nameonly PendingWindowInDays: Option<PendingWindowInDaysType> := Option.None)

  datatype ScheduleKeyDeletionResponse = ScheduleKeyDeletionResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly DeletionDate: Option<string> := Option.None, nameonly KeyState: Option<KeyState> := Option.None, nameonly PendingWindowInDays: Option<PendingWindowInDaysType> := Option.None)

  datatype SigningAlgorithmSpec = RSASSA_PSS_SHA_256 | RSASSA_PSS_SHA_384 | RSASSA_PSS_SHA_512 | RSASSA_PKCS1_V1_5_SHA_256 | RSASSA_PKCS1_V1_5_SHA_384 | RSASSA_PKCS1_V1_5_SHA_512 | ECDSA_SHA_256 | ECDSA_SHA_384 | ECDSA_SHA_512 | SM2DSA

  type SigningAlgorithmSpecList = seq<SigningAlgorithmSpec>

  datatype SignRequest = SignRequest(nameonly KeyId: KeyIdType, nameonly Message: PlaintextType, nameonly MessageType: Option<MessageType> := Option.None, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly SigningAlgorithm: SigningAlgorithmSpec, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype SignResponse = SignResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly Signature: Option<CiphertextType> := Option.None, nameonly SigningAlgorithm: Option<SigningAlgorithmSpec> := Option.None)

  datatype Tag = Tag(nameonly TagKey: TagKeyType, nameonly TagValue: TagValueType)

  type TagKeyList = seq<TagKeyType>

  type TagKeyType = x: string
    | IsValid_TagKeyType(x)
    witness *

  type TagList = seq<Tag>

  datatype TagResourceRequest = TagResourceRequest(nameonly KeyId: KeyIdType, nameonly Tags: TagList)

  type TagValueType = x: string
    | IsValid_TagValueType(x)
    witness *

  class IKMSClientCallHistory {
    ghost constructor ()
    {
      CancelKeyDeletion := [];
      ConnectCustomKeyStore := [];
      CreateAlias := [];
      CreateCustomKeyStore := [];
      CreateGrant := [];
      CreateKey := [];
      Decrypt := [];
      DeleteAlias := [];
      DeleteCustomKeyStore := [];
      DeleteImportedKeyMaterial := [];
      DeriveSharedSecret := [];
      DescribeCustomKeyStores := [];
      DescribeKey := [];
      DisableKey := [];
      DisableKeyRotation := [];
      DisconnectCustomKeyStore := [];
      EnableKey := [];
      EnableKeyRotation := [];
      Encrypt := [];
      GenerateDataKey := [];
      GenerateDataKeyPair := [];
      GenerateDataKeyPairWithoutPlaintext := [];
      GenerateDataKeyWithoutPlaintext := [];
      GenerateMac := [];
      GenerateRandom := [];
      GetKeyPolicy := [];
      GetKeyRotationStatus := [];
      GetParametersForImport := [];
      GetPublicKey := [];
      ImportKeyMaterial := [];
      ListAliases := [];
      ListGrants := [];
      ListKeyPolicies := [];
      ListKeyRotations := [];
      ListKeys := [];
      ListResourceTags := [];
      PutKeyPolicy := [];
      ReEncrypt := [];
      ReplicateKey := [];
      RetireGrant := [];
      RevokeGrant := [];
      RotateKeyOnDemand := [];
      ScheduleKeyDeletion := [];
      Sign := [];
      TagResource := [];
      UntagResource := [];
      UpdateAlias := [];
      UpdateCustomKeyStore := [];
      UpdateKeyDescription := [];
      UpdatePrimaryRegion := [];
      Verify := [];
      VerifyMac := [];
    }

    ghost var CancelKeyDeletion: seq<DafnyCallEvent<CancelKeyDeletionRequest, Result<CancelKeyDeletionResponse, Error>>>
    ghost var ConnectCustomKeyStore: seq<DafnyCallEvent<ConnectCustomKeyStoreRequest, Result<ConnectCustomKeyStoreResponse, Error>>>
    ghost var CreateAlias: seq<DafnyCallEvent<CreateAliasRequest, Result<(), Error>>>
    ghost var CreateCustomKeyStore: seq<DafnyCallEvent<CreateCustomKeyStoreRequest, Result<CreateCustomKeyStoreResponse, Error>>>
    ghost var CreateGrant: seq<DafnyCallEvent<CreateGrantRequest, Result<CreateGrantResponse, Error>>>
    ghost var CreateKey: seq<DafnyCallEvent<CreateKeyRequest, Result<CreateKeyResponse, Error>>>
    ghost var Decrypt: seq<DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>>>
    ghost var DeleteAlias: seq<DafnyCallEvent<DeleteAliasRequest, Result<(), Error>>>
    ghost var DeleteCustomKeyStore: seq<DafnyCallEvent<DeleteCustomKeyStoreRequest, Result<DeleteCustomKeyStoreResponse, Error>>>
    ghost var DeleteImportedKeyMaterial: seq<DafnyCallEvent<DeleteImportedKeyMaterialRequest, Result<(), Error>>>
    ghost var DeriveSharedSecret: seq<DafnyCallEvent<DeriveSharedSecretRequest, Result<DeriveSharedSecretResponse, Error>>>
    ghost var DescribeCustomKeyStores: seq<DafnyCallEvent<DescribeCustomKeyStoresRequest, Result<DescribeCustomKeyStoresResponse, Error>>>
    ghost var DescribeKey: seq<DafnyCallEvent<DescribeKeyRequest, Result<DescribeKeyResponse, Error>>>
    ghost var DisableKey: seq<DafnyCallEvent<DisableKeyRequest, Result<(), Error>>>
    ghost var DisableKeyRotation: seq<DafnyCallEvent<DisableKeyRotationRequest, Result<(), Error>>>
    ghost var DisconnectCustomKeyStore: seq<DafnyCallEvent<DisconnectCustomKeyStoreRequest, Result<DisconnectCustomKeyStoreResponse, Error>>>
    ghost var EnableKey: seq<DafnyCallEvent<EnableKeyRequest, Result<(), Error>>>
    ghost var EnableKeyRotation: seq<DafnyCallEvent<EnableKeyRotationRequest, Result<(), Error>>>
    ghost var Encrypt: seq<DafnyCallEvent<EncryptRequest, Result<EncryptResponse, Error>>>
    ghost var GenerateDataKey: seq<DafnyCallEvent<GenerateDataKeyRequest, Result<GenerateDataKeyResponse, Error>>>
    ghost var GenerateDataKeyPair: seq<DafnyCallEvent<GenerateDataKeyPairRequest, Result<GenerateDataKeyPairResponse, Error>>>
    ghost var GenerateDataKeyPairWithoutPlaintext: seq<DafnyCallEvent<GenerateDataKeyPairWithoutPlaintextRequest, Result<GenerateDataKeyPairWithoutPlaintextResponse, Error>>>
    ghost var GenerateDataKeyWithoutPlaintext: seq<DafnyCallEvent<GenerateDataKeyWithoutPlaintextRequest, Result<GenerateDataKeyWithoutPlaintextResponse, Error>>>
    ghost var GenerateMac: seq<DafnyCallEvent<GenerateMacRequest, Result<GenerateMacResponse, Error>>>
    ghost var GenerateRandom: seq<DafnyCallEvent<GenerateRandomRequest, Result<GenerateRandomResponse, Error>>>
    ghost var GetKeyPolicy: seq<DafnyCallEvent<GetKeyPolicyRequest, Result<GetKeyPolicyResponse, Error>>>
    ghost var GetKeyRotationStatus: seq<DafnyCallEvent<GetKeyRotationStatusRequest, Result<GetKeyRotationStatusResponse, Error>>>
    ghost var GetParametersForImport: seq<DafnyCallEvent<GetParametersForImportRequest, Result<GetParametersForImportResponse, Error>>>
    ghost var GetPublicKey: seq<DafnyCallEvent<GetPublicKeyRequest, Result<GetPublicKeyResponse, Error>>>
    ghost var ImportKeyMaterial: seq<DafnyCallEvent<ImportKeyMaterialRequest, Result<ImportKeyMaterialResponse, Error>>>
    ghost var ListAliases: seq<DafnyCallEvent<ListAliasesRequest, Result<ListAliasesResponse, Error>>>
    ghost var ListGrants: seq<DafnyCallEvent<ListGrantsRequest, Result<ListGrantsResponse, Error>>>
    ghost var ListKeyPolicies: seq<DafnyCallEvent<ListKeyPoliciesRequest, Result<ListKeyPoliciesResponse, Error>>>
    ghost var ListKeyRotations: seq<DafnyCallEvent<ListKeyRotationsRequest, Result<ListKeyRotationsResponse, Error>>>
    ghost var ListKeys: seq<DafnyCallEvent<ListKeysRequest, Result<ListKeysResponse, Error>>>
    ghost var ListResourceTags: seq<DafnyCallEvent<ListResourceTagsRequest, Result<ListResourceTagsResponse, Error>>>
    ghost var PutKeyPolicy: seq<DafnyCallEvent<PutKeyPolicyRequest, Result<(), Error>>>
    ghost var ReEncrypt: seq<DafnyCallEvent<ReEncryptRequest, Result<ReEncryptResponse, Error>>>
    ghost var ReplicateKey: seq<DafnyCallEvent<ReplicateKeyRequest, Result<ReplicateKeyResponse, Error>>>
    ghost var RetireGrant: seq<DafnyCallEvent<RetireGrantRequest, Result<(), Error>>>
    ghost var RevokeGrant: seq<DafnyCallEvent<RevokeGrantRequest, Result<(), Error>>>
    ghost var RotateKeyOnDemand: seq<DafnyCallEvent<RotateKeyOnDemandRequest, Result<RotateKeyOnDemandResponse, Error>>>
    ghost var ScheduleKeyDeletion: seq<DafnyCallEvent<ScheduleKeyDeletionRequest, Result<ScheduleKeyDeletionResponse, Error>>>
    ghost var Sign: seq<DafnyCallEvent<SignRequest, Result<SignResponse, Error>>>
    ghost var TagResource: seq<DafnyCallEvent<TagResourceRequest, Result<(), Error>>>
    ghost var UntagResource: seq<DafnyCallEvent<UntagResourceRequest, Result<(), Error>>>
    ghost var UpdateAlias: seq<DafnyCallEvent<UpdateAliasRequest, Result<(), Error>>>
    ghost var UpdateCustomKeyStore: seq<DafnyCallEvent<UpdateCustomKeyStoreRequest, Result<UpdateCustomKeyStoreResponse, Error>>>
    ghost var UpdateKeyDescription: seq<DafnyCallEvent<UpdateKeyDescriptionRequest, Result<(), Error>>>
    ghost var UpdatePrimaryRegion: seq<DafnyCallEvent<UpdatePrimaryRegionRequest, Result<(), Error>>>
    ghost var Verify: seq<DafnyCallEvent<VerifyRequest, Result<VerifyResponse, Error>>>
    ghost var VerifyMac: seq<DafnyCallEvent<VerifyMacRequest, Result<VerifyMacResponse, Error>>>
  }

  trait {:termination false} IKMSClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IKMSClientCallHistory

    predicate CancelKeyDeletionEnsuresPublicly(input: CancelKeyDeletionRequest, output: Result<CancelKeyDeletionResponse, Error>)
      decreases input, output

    method CancelKeyDeletion(input: CancelKeyDeletionRequest) returns (output: Result<CancelKeyDeletionResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CancelKeyDeletion
      ensures true && ValidState()
      ensures CancelKeyDeletionEnsuresPublicly(input, output)
      ensures History.CancelKeyDeletion == old(History.CancelKeyDeletion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ConnectCustomKeyStoreEnsuresPublicly(input: ConnectCustomKeyStoreRequest, output: Result<ConnectCustomKeyStoreResponse, Error>)
      decreases input, output

    method ConnectCustomKeyStore(input: ConnectCustomKeyStoreRequest) returns (output: Result<ConnectCustomKeyStoreResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ConnectCustomKeyStore
      ensures true && ValidState()
      ensures ConnectCustomKeyStoreEnsuresPublicly(input, output)
      ensures History.ConnectCustomKeyStore == old(History.ConnectCustomKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateAliasEnsuresPublicly(input: CreateAliasRequest, output: Result<(), Error>)
      decreases input, output

    method CreateAlias(input: CreateAliasRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateAlias
      ensures true && ValidState()
      ensures CreateAliasEnsuresPublicly(input, output)
      ensures History.CreateAlias == old(History.CreateAlias) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateCustomKeyStoreEnsuresPublicly(input: CreateCustomKeyStoreRequest, output: Result<CreateCustomKeyStoreResponse, Error>)
      decreases input, output

    method CreateCustomKeyStore(input: CreateCustomKeyStoreRequest) returns (output: Result<CreateCustomKeyStoreResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateCustomKeyStore
      ensures true && ValidState()
      ensures CreateCustomKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateCustomKeyStore == old(History.CreateCustomKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateGrantEnsuresPublicly(input: CreateGrantRequest, output: Result<CreateGrantResponse, Error>)
      decreases input, output

    method CreateGrant(input: CreateGrantRequest) returns (output: Result<CreateGrantResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateGrant
      ensures true && ValidState()
      ensures CreateGrantEnsuresPublicly(input, output)
      ensures History.CreateGrant == old(History.CreateGrant) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateKeyEnsuresPublicly(input: CreateKeyRequest, output: Result<CreateKeyResponse, Error>)
      decreases input, output

    method CreateKey(input: CreateKeyRequest) returns (output: Result<CreateKeyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DecryptEnsuresPublicly(input: DecryptRequest, output: Result<DecryptResponse, Error>)
      decreases input, output

    method Decrypt(input: DecryptRequest) returns (output: Result<DecryptResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Decrypt
      ensures true && ValidState()
      ensures DecryptEnsuresPublicly(input, output)
      ensures History.Decrypt == old(History.Decrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteAliasEnsuresPublicly(input: DeleteAliasRequest, output: Result<(), Error>)
      decreases input, output

    method DeleteAlias(input: DeleteAliasRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteAlias
      ensures true && ValidState()
      ensures DeleteAliasEnsuresPublicly(input, output)
      ensures History.DeleteAlias == old(History.DeleteAlias) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteCustomKeyStoreEnsuresPublicly(input: DeleteCustomKeyStoreRequest, output: Result<DeleteCustomKeyStoreResponse, Error>)
      decreases input, output

    method DeleteCustomKeyStore(input: DeleteCustomKeyStoreRequest) returns (output: Result<DeleteCustomKeyStoreResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteCustomKeyStore
      ensures true && ValidState()
      ensures DeleteCustomKeyStoreEnsuresPublicly(input, output)
      ensures History.DeleteCustomKeyStore == old(History.DeleteCustomKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteImportedKeyMaterialEnsuresPublicly(input: DeleteImportedKeyMaterialRequest, output: Result<(), Error>)
      decreases input, output

    method DeleteImportedKeyMaterial(input: DeleteImportedKeyMaterialRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteImportedKeyMaterial
      ensures true && ValidState()
      ensures DeleteImportedKeyMaterialEnsuresPublicly(input, output)
      ensures History.DeleteImportedKeyMaterial == old(History.DeleteImportedKeyMaterial) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretRequest, output: Result<DeriveSharedSecretResponse, Error>)
      decreases input, output

    method DeriveSharedSecret(input: DeriveSharedSecretRequest) returns (output: Result<DeriveSharedSecretResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeriveSharedSecret
      ensures true && ValidState()
      ensures DeriveSharedSecretEnsuresPublicly(input, output)
      ensures History.DeriveSharedSecret == old(History.DeriveSharedSecret) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeCustomKeyStoresEnsuresPublicly(input: DescribeCustomKeyStoresRequest, output: Result<DescribeCustomKeyStoresResponse, Error>)
      decreases input, output

    method DescribeCustomKeyStores(input: DescribeCustomKeyStoresRequest) returns (output: Result<DescribeCustomKeyStoresResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeCustomKeyStores
      ensures true && ValidState()
      ensures DescribeCustomKeyStoresEnsuresPublicly(input, output)
      ensures History.DescribeCustomKeyStores == old(History.DescribeCustomKeyStores) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeKeyEnsuresPublicly(input: DescribeKeyRequest, output: Result<DescribeKeyResponse, Error>)
      decreases input, output

    method DescribeKey(input: DescribeKeyRequest) returns (output: Result<DescribeKeyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeKey
      ensures true && ValidState()
      ensures DescribeKeyEnsuresPublicly(input, output)
      ensures History.DescribeKey == old(History.DescribeKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DisableKeyEnsuresPublicly(input: DisableKeyRequest, output: Result<(), Error>)
      decreases input, output

    method DisableKey(input: DisableKeyRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DisableKey
      ensures true && ValidState()
      ensures DisableKeyEnsuresPublicly(input, output)
      ensures History.DisableKey == old(History.DisableKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DisableKeyRotationEnsuresPublicly(input: DisableKeyRotationRequest, output: Result<(), Error>)
      decreases input, output

    method DisableKeyRotation(input: DisableKeyRotationRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DisableKeyRotation
      ensures true && ValidState()
      ensures DisableKeyRotationEnsuresPublicly(input, output)
      ensures History.DisableKeyRotation == old(History.DisableKeyRotation) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DisconnectCustomKeyStoreEnsuresPublicly(input: DisconnectCustomKeyStoreRequest, output: Result<DisconnectCustomKeyStoreResponse, Error>)
      decreases input, output

    method DisconnectCustomKeyStore(input: DisconnectCustomKeyStoreRequest) returns (output: Result<DisconnectCustomKeyStoreResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DisconnectCustomKeyStore
      ensures true && ValidState()
      ensures DisconnectCustomKeyStoreEnsuresPublicly(input, output)
      ensures History.DisconnectCustomKeyStore == old(History.DisconnectCustomKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate EnableKeyEnsuresPublicly(input: EnableKeyRequest, output: Result<(), Error>)
      decreases input, output

    method EnableKey(input: EnableKeyRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EnableKey
      ensures true && ValidState()
      ensures EnableKeyEnsuresPublicly(input, output)
      ensures History.EnableKey == old(History.EnableKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate EnableKeyRotationEnsuresPublicly(input: EnableKeyRotationRequest, output: Result<(), Error>)
      decreases input, output

    method EnableKeyRotation(input: EnableKeyRotationRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EnableKeyRotation
      ensures true && ValidState()
      ensures EnableKeyRotationEnsuresPublicly(input, output)
      ensures History.EnableKeyRotation == old(History.EnableKeyRotation) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate EncryptEnsuresPublicly(input: EncryptRequest, output: Result<EncryptResponse, Error>)
      decreases input, output

    method Encrypt(input: EncryptRequest) returns (output: Result<EncryptResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Encrypt
      ensures true && ValidState()
      ensures EncryptEnsuresPublicly(input, output)
      ensures History.Encrypt == old(History.Encrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateDataKeyEnsuresPublicly(input: GenerateDataKeyRequest, output: Result<GenerateDataKeyResponse, Error>)
      decreases input, output

    method GenerateDataKey(input: GenerateDataKeyRequest) returns (output: Result<GenerateDataKeyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateDataKey
      ensures true && ValidState()
      ensures GenerateDataKeyEnsuresPublicly(input, output)
      ensures History.GenerateDataKey == old(History.GenerateDataKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateDataKeyPairEnsuresPublicly(input: GenerateDataKeyPairRequest, output: Result<GenerateDataKeyPairResponse, Error>)
      decreases input, output

    method GenerateDataKeyPair(input: GenerateDataKeyPairRequest) returns (output: Result<GenerateDataKeyPairResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateDataKeyPair
      ensures true && ValidState()
      ensures GenerateDataKeyPairEnsuresPublicly(input, output)
      ensures History.GenerateDataKeyPair == old(History.GenerateDataKeyPair) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateDataKeyPairWithoutPlaintextEnsuresPublicly(input: GenerateDataKeyPairWithoutPlaintextRequest, output: Result<GenerateDataKeyPairWithoutPlaintextResponse, Error>)
      decreases input, output

    method GenerateDataKeyPairWithoutPlaintext(input: GenerateDataKeyPairWithoutPlaintextRequest) returns (output: Result<GenerateDataKeyPairWithoutPlaintextResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateDataKeyPairWithoutPlaintext
      ensures true && ValidState()
      ensures GenerateDataKeyPairWithoutPlaintextEnsuresPublicly(input, output)
      ensures History.GenerateDataKeyPairWithoutPlaintext == old(History.GenerateDataKeyPairWithoutPlaintext) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateDataKeyWithoutPlaintextEnsuresPublicly(input: GenerateDataKeyWithoutPlaintextRequest, output: Result<GenerateDataKeyWithoutPlaintextResponse, Error>)
      decreases input, output

    method GenerateDataKeyWithoutPlaintext(input: GenerateDataKeyWithoutPlaintextRequest) returns (output: Result<GenerateDataKeyWithoutPlaintextResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateDataKeyWithoutPlaintext
      ensures true && ValidState()
      ensures GenerateDataKeyWithoutPlaintextEnsuresPublicly(input, output)
      ensures History.GenerateDataKeyWithoutPlaintext == old(History.GenerateDataKeyWithoutPlaintext) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateMacEnsuresPublicly(input: GenerateMacRequest, output: Result<GenerateMacResponse, Error>)
      decreases input, output

    method GenerateMac(input: GenerateMacRequest) returns (output: Result<GenerateMacResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateMac
      ensures true && ValidState()
      ensures GenerateMacEnsuresPublicly(input, output)
      ensures History.GenerateMac == old(History.GenerateMac) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GenerateRandomEnsuresPublicly(input: GenerateRandomRequest, output: Result<GenerateRandomResponse, Error>)
      decreases input, output

    method GenerateRandom(input: GenerateRandomRequest) returns (output: Result<GenerateRandomResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GenerateRandom
      ensures true && ValidState()
      ensures GenerateRandomEnsuresPublicly(input, output)
      ensures History.GenerateRandom == old(History.GenerateRandom) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetKeyPolicyEnsuresPublicly(input: GetKeyPolicyRequest, output: Result<GetKeyPolicyResponse, Error>)
      decreases input, output

    method GetKeyPolicy(input: GetKeyPolicyRequest) returns (output: Result<GetKeyPolicyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyPolicy
      ensures true && ValidState()
      ensures GetKeyPolicyEnsuresPublicly(input, output)
      ensures History.GetKeyPolicy == old(History.GetKeyPolicy) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetKeyRotationStatusEnsuresPublicly(input: GetKeyRotationStatusRequest, output: Result<GetKeyRotationStatusResponse, Error>)
      decreases input, output

    method GetKeyRotationStatus(input: GetKeyRotationStatusRequest) returns (output: Result<GetKeyRotationStatusResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyRotationStatus
      ensures true && ValidState()
      ensures GetKeyRotationStatusEnsuresPublicly(input, output)
      ensures History.GetKeyRotationStatus == old(History.GetKeyRotationStatus) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetParametersForImportEnsuresPublicly(input: GetParametersForImportRequest, output: Result<GetParametersForImportResponse, Error>)
      decreases input, output

    method GetParametersForImport(input: GetParametersForImportRequest) returns (output: Result<GetParametersForImportResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetParametersForImport
      ensures true && ValidState()
      ensures GetParametersForImportEnsuresPublicly(input, output)
      ensures History.GetParametersForImport == old(History.GetParametersForImport) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetPublicKeyEnsuresPublicly(input: GetPublicKeyRequest, output: Result<GetPublicKeyResponse, Error>)
      decreases input, output

    method GetPublicKey(input: GetPublicKeyRequest) returns (output: Result<GetPublicKeyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetPublicKey
      ensures true && ValidState()
      ensures GetPublicKeyEnsuresPublicly(input, output)
      ensures History.GetPublicKey == old(History.GetPublicKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ImportKeyMaterialEnsuresPublicly(input: ImportKeyMaterialRequest, output: Result<ImportKeyMaterialResponse, Error>)
      decreases input, output

    method ImportKeyMaterial(input: ImportKeyMaterialRequest) returns (output: Result<ImportKeyMaterialResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ImportKeyMaterial
      ensures true && ValidState()
      ensures ImportKeyMaterialEnsuresPublicly(input, output)
      ensures History.ImportKeyMaterial == old(History.ImportKeyMaterial) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListAliasesEnsuresPublicly(input: ListAliasesRequest, output: Result<ListAliasesResponse, Error>)
      decreases input, output

    method ListAliases(input: ListAliasesRequest) returns (output: Result<ListAliasesResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListAliases
      ensures true && ValidState()
      ensures ListAliasesEnsuresPublicly(input, output)
      ensures History.ListAliases == old(History.ListAliases) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListGrantsEnsuresPublicly(input: ListGrantsRequest, output: Result<ListGrantsResponse, Error>)
      decreases input, output

    method ListGrants(input: ListGrantsRequest) returns (output: Result<ListGrantsResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListGrants
      ensures true && ValidState()
      ensures ListGrantsEnsuresPublicly(input, output)
      ensures History.ListGrants == old(History.ListGrants) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListKeyPoliciesEnsuresPublicly(input: ListKeyPoliciesRequest, output: Result<ListKeyPoliciesResponse, Error>)
      decreases input, output

    method ListKeyPolicies(input: ListKeyPoliciesRequest) returns (output: Result<ListKeyPoliciesResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListKeyPolicies
      ensures true && ValidState()
      ensures ListKeyPoliciesEnsuresPublicly(input, output)
      ensures History.ListKeyPolicies == old(History.ListKeyPolicies) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListKeyRotationsEnsuresPublicly(input: ListKeyRotationsRequest, output: Result<ListKeyRotationsResponse, Error>)
      decreases input, output

    method ListKeyRotations(input: ListKeyRotationsRequest) returns (output: Result<ListKeyRotationsResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListKeyRotations
      ensures true && ValidState()
      ensures ListKeyRotationsEnsuresPublicly(input, output)
      ensures History.ListKeyRotations == old(History.ListKeyRotations) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListKeysEnsuresPublicly(input: ListKeysRequest, output: Result<ListKeysResponse, Error>)
      decreases input, output

    method ListKeys(input: ListKeysRequest) returns (output: Result<ListKeysResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListKeys
      ensures true && ValidState()
      ensures ListKeysEnsuresPublicly(input, output)
      ensures History.ListKeys == old(History.ListKeys) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListResourceTagsEnsuresPublicly(input: ListResourceTagsRequest, output: Result<ListResourceTagsResponse, Error>)
      decreases input, output

    method ListResourceTags(input: ListResourceTagsRequest) returns (output: Result<ListResourceTagsResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListResourceTags
      ensures true && ValidState()
      ensures ListResourceTagsEnsuresPublicly(input, output)
      ensures History.ListResourceTags == old(History.ListResourceTags) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate PutKeyPolicyEnsuresPublicly(input: PutKeyPolicyRequest, output: Result<(), Error>)
      decreases input, output

    method PutKeyPolicy(input: PutKeyPolicyRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutKeyPolicy
      ensures true && ValidState()
      ensures PutKeyPolicyEnsuresPublicly(input, output)
      ensures History.PutKeyPolicy == old(History.PutKeyPolicy) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ReEncryptEnsuresPublicly(input: ReEncryptRequest, output: Result<ReEncryptResponse, Error>)
      decreases input, output

    method ReEncrypt(input: ReEncryptRequest) returns (output: Result<ReEncryptResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ReEncrypt
      ensures true && ValidState()
      ensures ReEncryptEnsuresPublicly(input, output)
      ensures History.ReEncrypt == old(History.ReEncrypt) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ReplicateKeyEnsuresPublicly(input: ReplicateKeyRequest, output: Result<ReplicateKeyResponse, Error>)
      decreases input, output

    method ReplicateKey(input: ReplicateKeyRequest) returns (output: Result<ReplicateKeyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ReplicateKey
      ensures true && ValidState()
      ensures ReplicateKeyEnsuresPublicly(input, output)
      ensures History.ReplicateKey == old(History.ReplicateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RetireGrantEnsuresPublicly(input: RetireGrantRequest, output: Result<(), Error>)
      decreases input, output

    method RetireGrant(input: RetireGrantRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RetireGrant
      ensures true && ValidState()
      ensures RetireGrantEnsuresPublicly(input, output)
      ensures History.RetireGrant == old(History.RetireGrant) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RevokeGrantEnsuresPublicly(input: RevokeGrantRequest, output: Result<(), Error>)
      decreases input, output

    method RevokeGrant(input: RevokeGrantRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RevokeGrant
      ensures true && ValidState()
      ensures RevokeGrantEnsuresPublicly(input, output)
      ensures History.RevokeGrant == old(History.RevokeGrant) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RotateKeyOnDemandEnsuresPublicly(input: RotateKeyOnDemandRequest, output: Result<RotateKeyOnDemandResponse, Error>)
      decreases input, output

    method RotateKeyOnDemand(input: RotateKeyOnDemandRequest) returns (output: Result<RotateKeyOnDemandResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RotateKeyOnDemand
      ensures true && ValidState()
      ensures RotateKeyOnDemandEnsuresPublicly(input, output)
      ensures History.RotateKeyOnDemand == old(History.RotateKeyOnDemand) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ScheduleKeyDeletionEnsuresPublicly(input: ScheduleKeyDeletionRequest, output: Result<ScheduleKeyDeletionResponse, Error>)
      decreases input, output

    method ScheduleKeyDeletion(input: ScheduleKeyDeletionRequest) returns (output: Result<ScheduleKeyDeletionResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ScheduleKeyDeletion
      ensures true && ValidState()
      ensures ScheduleKeyDeletionEnsuresPublicly(input, output)
      ensures History.ScheduleKeyDeletion == old(History.ScheduleKeyDeletion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate SignEnsuresPublicly(input: SignRequest, output: Result<SignResponse, Error>)
      decreases input, output

    method Sign(input: SignRequest) returns (output: Result<SignResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Sign
      ensures true && ValidState()
      ensures SignEnsuresPublicly(input, output)
      ensures History.Sign == old(History.Sign) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TagResourceEnsuresPublicly(input: TagResourceRequest, output: Result<(), Error>)
      decreases input, output

    method TagResource(input: TagResourceRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TagResource
      ensures true && ValidState()
      ensures TagResourceEnsuresPublicly(input, output)
      ensures History.TagResource == old(History.TagResource) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UntagResourceEnsuresPublicly(input: UntagResourceRequest, output: Result<(), Error>)
      decreases input, output

    method UntagResource(input: UntagResourceRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UntagResource
      ensures true && ValidState()
      ensures UntagResourceEnsuresPublicly(input, output)
      ensures History.UntagResource == old(History.UntagResource) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateAliasEnsuresPublicly(input: UpdateAliasRequest, output: Result<(), Error>)
      decreases input, output

    method UpdateAlias(input: UpdateAliasRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateAlias
      ensures true && ValidState()
      ensures UpdateAliasEnsuresPublicly(input, output)
      ensures History.UpdateAlias == old(History.UpdateAlias) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateCustomKeyStoreEnsuresPublicly(input: UpdateCustomKeyStoreRequest, output: Result<UpdateCustomKeyStoreResponse, Error>)
      decreases input, output

    method UpdateCustomKeyStore(input: UpdateCustomKeyStoreRequest) returns (output: Result<UpdateCustomKeyStoreResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateCustomKeyStore
      ensures true && ValidState()
      ensures UpdateCustomKeyStoreEnsuresPublicly(input, output)
      ensures History.UpdateCustomKeyStore == old(History.UpdateCustomKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateKeyDescriptionEnsuresPublicly(input: UpdateKeyDescriptionRequest, output: Result<(), Error>)
      decreases input, output

    method UpdateKeyDescription(input: UpdateKeyDescriptionRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateKeyDescription
      ensures true && ValidState()
      ensures UpdateKeyDescriptionEnsuresPublicly(input, output)
      ensures History.UpdateKeyDescription == old(History.UpdateKeyDescription) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdatePrimaryRegionEnsuresPublicly(input: UpdatePrimaryRegionRequest, output: Result<(), Error>)
      decreases input, output

    method UpdatePrimaryRegion(input: UpdatePrimaryRegionRequest) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdatePrimaryRegion
      ensures true && ValidState()
      ensures UpdatePrimaryRegionEnsuresPublicly(input, output)
      ensures History.UpdatePrimaryRegion == old(History.UpdatePrimaryRegion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate VerifyEnsuresPublicly(input: VerifyRequest, output: Result<VerifyResponse, Error>)
      decreases input, output

    method Verify(input: VerifyRequest) returns (output: Result<VerifyResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Verify
      ensures true && ValidState()
      ensures VerifyEnsuresPublicly(input, output)
      ensures History.Verify == old(History.Verify) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate VerifyMacEnsuresPublicly(input: VerifyMacRequest, output: Result<VerifyMacResponse, Error>)
      decreases input, output

    method VerifyMac(input: VerifyMacRequest) returns (output: Result<VerifyMacResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VerifyMac
      ensures true && ValidState()
      ensures VerifyMacEnsuresPublicly(input, output)
      ensures History.VerifyMac == old(History.VerifyMac) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  type TrustAnchorCertificateType = x: string
    | IsValid_TrustAnchorCertificateType(x)
    witness *

  datatype UntagResourceRequest = UntagResourceRequest(nameonly KeyId: KeyIdType, nameonly TagKeys: TagKeyList)

  datatype UpdateAliasRequest = UpdateAliasRequest(nameonly AliasName: AliasNameType, nameonly TargetKeyId: KeyIdType)

  datatype UpdateCustomKeyStoreRequest = UpdateCustomKeyStoreRequest(nameonly CustomKeyStoreId: CustomKeyStoreIdType, nameonly NewCustomKeyStoreName: Option<CustomKeyStoreNameType> := Option.None, nameonly KeyStorePassword: Option<KeyStorePasswordType> := Option.None, nameonly CloudHsmClusterId: Option<CloudHsmClusterIdType> := Option.None, nameonly XksProxyUriEndpoint: Option<XksProxyUriEndpointType> := Option.None, nameonly XksProxyUriPath: Option<XksProxyUriPathType> := Option.None, nameonly XksProxyVpcEndpointServiceName: Option<XksProxyVpcEndpointServiceNameType> := Option.None, nameonly XksProxyAuthenticationCredential: Option<XksProxyAuthenticationCredentialType> := Option.None, nameonly XksProxyConnectivity: Option<XksProxyConnectivityType> := Option.None)

  datatype UpdateCustomKeyStoreResponse = UpdateCustomKeyStoreResponse

  datatype UpdateKeyDescriptionRequest = UpdateKeyDescriptionRequest(nameonly KeyId: KeyIdType, nameonly Description: DescriptionType)

  datatype UpdatePrimaryRegionRequest = UpdatePrimaryRegionRequest(nameonly KeyId: KeyIdType, nameonly PrimaryRegion: RegionType)

  datatype VerifyMacRequest = VerifyMacRequest(nameonly Message: PlaintextType, nameonly KeyId: KeyIdType, nameonly MacAlgorithm: MacAlgorithmSpec, nameonly Mac: CiphertextType, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype VerifyMacResponse = VerifyMacResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly MacValid: Option<BooleanType> := Option.None, nameonly MacAlgorithm: Option<MacAlgorithmSpec> := Option.None)

  datatype VerifyRequest = VerifyRequest(nameonly KeyId: KeyIdType, nameonly Message: PlaintextType, nameonly MessageType: Option<MessageType> := Option.None, nameonly Signature: CiphertextType, nameonly SigningAlgorithm: SigningAlgorithmSpec, nameonly GrantTokens: Option<GrantTokenList> := Option.None, nameonly DryRun: Option<NullableBooleanType> := Option.None)

  datatype VerifyResponse = VerifyResponse(nameonly KeyId: Option<KeyIdType> := Option.None, nameonly SignatureValid: Option<BooleanType> := Option.None, nameonly SigningAlgorithm: Option<SigningAlgorithmSpec> := Option.None)

  datatype WrappingKeySpec = RSA_2048 | RSA_3072 | RSA_4096 | SM2

  datatype XksKeyConfigurationType = XksKeyConfigurationType(nameonly Id: Option<XksKeyIdType> := Option.None)

  type XksKeyIdType = x: string
    | IsValid_XksKeyIdType(x)
    witness *

  type XksProxyAuthenticationAccessKeyIdType = x: string
    | IsValid_XksProxyAuthenticationAccessKeyIdType(x)
    witness *

  datatype XksProxyAuthenticationCredentialType = XksProxyAuthenticationCredentialType(nameonly AccessKeyId: XksProxyAuthenticationAccessKeyIdType, nameonly RawSecretAccessKey: XksProxyAuthenticationRawSecretAccessKeyType)

  type XksProxyAuthenticationRawSecretAccessKeyType = x: string
    | IsValid_XksProxyAuthenticationRawSecretAccessKeyType(x)
    witness *

  datatype XksProxyConfigurationType = XksProxyConfigurationType(nameonly Connectivity: Option<XksProxyConnectivityType> := Option.None, nameonly AccessKeyId: Option<XksProxyAuthenticationAccessKeyIdType> := Option.None, nameonly UriEndpoint: Option<XksProxyUriEndpointType> := Option.None, nameonly UriPath: Option<XksProxyUriPathType> := Option.None, nameonly VpcEndpointServiceName: Option<XksProxyVpcEndpointServiceNameType> := Option.None)

  datatype XksProxyConnectivityType = PUBLIC_ENDPOINT | VPC_ENDPOINT_SERVICE

  type XksProxyUriEndpointType = x: string
    | IsValid_XksProxyUriEndpointType(x)
    witness *

  type XksProxyUriPathType = x: string
    | IsValid_XksProxyUriPathType(x)
    witness *

  type XksProxyVpcEndpointServiceNameType = x: string
    | IsValid_XksProxyVpcEndpointServiceNameType(x)
    witness *

  datatype Error = AlreadyExistsException(nameonly message: Option<ErrorMessageType> := Option.None) | CloudHsmClusterInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | CloudHsmClusterInvalidConfigurationException(nameonly message: Option<ErrorMessageType> := Option.None) | CloudHsmClusterNotActiveException(nameonly message: Option<ErrorMessageType> := Option.None) | CloudHsmClusterNotFoundException(nameonly message: Option<ErrorMessageType> := Option.None) | CloudHsmClusterNotRelatedException(nameonly message: Option<ErrorMessageType> := Option.None) | ConflictException(nameonly message: Option<ErrorMessageType> := Option.None) | CustomKeyStoreHasCMKsException(nameonly message: Option<ErrorMessageType> := Option.None) | CustomKeyStoreInvalidStateException(nameonly message: Option<ErrorMessageType> := Option.None) | CustomKeyStoreNameInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | CustomKeyStoreNotFoundException(nameonly message: Option<ErrorMessageType> := Option.None) | DependencyTimeoutException(nameonly message: Option<ErrorMessageType> := Option.None) | DisabledException(nameonly message: Option<ErrorMessageType> := Option.None) | DryRunOperationException(nameonly message: Option<ErrorMessageType> := Option.None) | ExpiredImportTokenException(nameonly message: Option<ErrorMessageType> := Option.None) | IncorrectKeyException(nameonly message: Option<ErrorMessageType> := Option.None) | IncorrectKeyMaterialException(nameonly message: Option<ErrorMessageType> := Option.None) | IncorrectTrustAnchorException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidAliasNameException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidArnException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidCiphertextException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidGrantIdException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidGrantTokenException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidImportTokenException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidKeyUsageException(nameonly message: Option<ErrorMessageType> := Option.None) | InvalidMarkerException(nameonly message: Option<ErrorMessageType> := Option.None) | KeyUnavailableException(nameonly message: Option<ErrorMessageType> := Option.None) | KMSInternalException(nameonly message: Option<ErrorMessageType> := Option.None) | KMSInvalidMacException(nameonly message: Option<ErrorMessageType> := Option.None) | KMSInvalidSignatureException(nameonly message: Option<ErrorMessageType> := Option.None) | KMSInvalidStateException(nameonly message: Option<ErrorMessageType> := Option.None) | LimitExceededException(nameonly message: Option<ErrorMessageType> := Option.None) | MalformedPolicyDocumentException(nameonly message: Option<ErrorMessageType> := Option.None) | NotFoundException(nameonly message: Option<ErrorMessageType> := Option.None) | TagException(nameonly message: Option<ErrorMessageType> := Option.None) | UnsupportedOperationException(nameonly message: Option<ErrorMessageType> := Option.None) | XksKeyAlreadyInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | XksKeyInvalidConfigurationException(nameonly message: Option<ErrorMessageType> := Option.None) | XksKeyNotFoundException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyIncorrectAuthenticationCredentialException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyInvalidConfigurationException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyInvalidResponseException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyUriEndpointInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyUriInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyUriUnreachableException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyVpcEndpointServiceInUseException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyVpcEndpointServiceInvalidConfigurationException(nameonly message: Option<ErrorMessageType> := Option.None) | XksProxyVpcEndpointServiceNotFoundException(nameonly message: Option<ErrorMessageType> := Option.None) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractComAmazonawsKmsService {
  function method DefaultKMSClientConfigType(): KMSClientConfigType

  method {:extern} KMSClient() returns (res: Result<IKMSClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()

  function method CreateSuccessOfClient(client: IKMSClient): Result<IKMSClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IKMSClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = ComAmazonawsKmsTypes

  datatype KMSClientConfigType = KMSClientConfigType
}

abstract module AbstractComAmazonawsKmsOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate CancelKeyDeletionEnsuresPublicly(input: CancelKeyDeletionRequest, output: Result<CancelKeyDeletionResponse, Error>)
    decreases input, output

  method CancelKeyDeletion(config: InternalConfig, input: CancelKeyDeletionRequest) returns (output: Result<CancelKeyDeletionResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CancelKeyDeletionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ConnectCustomKeyStoreEnsuresPublicly(input: ConnectCustomKeyStoreRequest, output: Result<ConnectCustomKeyStoreResponse, Error>)
    decreases input, output

  method ConnectCustomKeyStore(config: InternalConfig, input: ConnectCustomKeyStoreRequest) returns (output: Result<ConnectCustomKeyStoreResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ConnectCustomKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateAliasEnsuresPublicly(input: CreateAliasRequest, output: Result<(), Error>)
    decreases input, output

  method CreateAlias(config: InternalConfig, input: CreateAliasRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateAliasEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateCustomKeyStoreEnsuresPublicly(input: CreateCustomKeyStoreRequest, output: Result<CreateCustomKeyStoreResponse, Error>)
    decreases input, output

  method CreateCustomKeyStore(config: InternalConfig, input: CreateCustomKeyStoreRequest) returns (output: Result<CreateCustomKeyStoreResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateCustomKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateGrantEnsuresPublicly(input: CreateGrantRequest, output: Result<CreateGrantResponse, Error>)
    decreases input, output

  method CreateGrant(config: InternalConfig, input: CreateGrantRequest) returns (output: Result<CreateGrantResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateGrantEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateKeyEnsuresPublicly(input: CreateKeyRequest, output: Result<CreateKeyResponse, Error>)
    decreases input, output

  method CreateKey(config: InternalConfig, input: CreateKeyRequest) returns (output: Result<CreateKeyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DecryptEnsuresPublicly(input: DecryptRequest, output: Result<DecryptResponse, Error>)
    decreases input, output

  method Decrypt(config: InternalConfig, input: DecryptRequest) returns (output: Result<DecryptResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DecryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteAliasEnsuresPublicly(input: DeleteAliasRequest, output: Result<(), Error>)
    decreases input, output

  method DeleteAlias(config: InternalConfig, input: DeleteAliasRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteAliasEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteCustomKeyStoreEnsuresPublicly(input: DeleteCustomKeyStoreRequest, output: Result<DeleteCustomKeyStoreResponse, Error>)
    decreases input, output

  method DeleteCustomKeyStore(config: InternalConfig, input: DeleteCustomKeyStoreRequest) returns (output: Result<DeleteCustomKeyStoreResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteCustomKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteImportedKeyMaterialEnsuresPublicly(input: DeleteImportedKeyMaterialRequest, output: Result<(), Error>)
    decreases input, output

  method DeleteImportedKeyMaterial(config: InternalConfig, input: DeleteImportedKeyMaterialRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteImportedKeyMaterialEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeriveSharedSecretEnsuresPublicly(input: DeriveSharedSecretRequest, output: Result<DeriveSharedSecretResponse, Error>)
    decreases input, output

  method DeriveSharedSecret(config: InternalConfig, input: DeriveSharedSecretRequest) returns (output: Result<DeriveSharedSecretResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeriveSharedSecretEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeCustomKeyStoresEnsuresPublicly(input: DescribeCustomKeyStoresRequest, output: Result<DescribeCustomKeyStoresResponse, Error>)
    decreases input, output

  method DescribeCustomKeyStores(config: InternalConfig, input: DescribeCustomKeyStoresRequest) returns (output: Result<DescribeCustomKeyStoresResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeCustomKeyStoresEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeKeyEnsuresPublicly(input: DescribeKeyRequest, output: Result<DescribeKeyResponse, Error>)
    decreases input, output

  method DescribeKey(config: InternalConfig, input: DescribeKeyRequest) returns (output: Result<DescribeKeyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DisableKeyEnsuresPublicly(input: DisableKeyRequest, output: Result<(), Error>)
    decreases input, output

  method DisableKey(config: InternalConfig, input: DisableKeyRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DisableKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DisableKeyRotationEnsuresPublicly(input: DisableKeyRotationRequest, output: Result<(), Error>)
    decreases input, output

  method DisableKeyRotation(config: InternalConfig, input: DisableKeyRotationRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DisableKeyRotationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DisconnectCustomKeyStoreEnsuresPublicly(input: DisconnectCustomKeyStoreRequest, output: Result<DisconnectCustomKeyStoreResponse, Error>)
    decreases input, output

  method DisconnectCustomKeyStore(config: InternalConfig, input: DisconnectCustomKeyStoreRequest) returns (output: Result<DisconnectCustomKeyStoreResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DisconnectCustomKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate EnableKeyEnsuresPublicly(input: EnableKeyRequest, output: Result<(), Error>)
    decreases input, output

  method EnableKey(config: InternalConfig, input: EnableKeyRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EnableKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate EnableKeyRotationEnsuresPublicly(input: EnableKeyRotationRequest, output: Result<(), Error>)
    decreases input, output

  method EnableKeyRotation(config: InternalConfig, input: EnableKeyRotationRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EnableKeyRotationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate EncryptEnsuresPublicly(input: EncryptRequest, output: Result<EncryptResponse, Error>)
    decreases input, output

  method Encrypt(config: InternalConfig, input: EncryptRequest) returns (output: Result<EncryptResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateDataKeyEnsuresPublicly(input: GenerateDataKeyRequest, output: Result<GenerateDataKeyResponse, Error>)
    decreases input, output

  method GenerateDataKey(config: InternalConfig, input: GenerateDataKeyRequest) returns (output: Result<GenerateDataKeyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateDataKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateDataKeyPairEnsuresPublicly(input: GenerateDataKeyPairRequest, output: Result<GenerateDataKeyPairResponse, Error>)
    decreases input, output

  method GenerateDataKeyPair(config: InternalConfig, input: GenerateDataKeyPairRequest) returns (output: Result<GenerateDataKeyPairResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateDataKeyPairEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateDataKeyPairWithoutPlaintextEnsuresPublicly(input: GenerateDataKeyPairWithoutPlaintextRequest, output: Result<GenerateDataKeyPairWithoutPlaintextResponse, Error>)
    decreases input, output

  method GenerateDataKeyPairWithoutPlaintext(config: InternalConfig, input: GenerateDataKeyPairWithoutPlaintextRequest) returns (output: Result<GenerateDataKeyPairWithoutPlaintextResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateDataKeyPairWithoutPlaintextEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateDataKeyWithoutPlaintextEnsuresPublicly(input: GenerateDataKeyWithoutPlaintextRequest, output: Result<GenerateDataKeyWithoutPlaintextResponse, Error>)
    decreases input, output

  method GenerateDataKeyWithoutPlaintext(config: InternalConfig, input: GenerateDataKeyWithoutPlaintextRequest) returns (output: Result<GenerateDataKeyWithoutPlaintextResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateDataKeyWithoutPlaintextEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateMacEnsuresPublicly(input: GenerateMacRequest, output: Result<GenerateMacResponse, Error>)
    decreases input, output

  method GenerateMac(config: InternalConfig, input: GenerateMacRequest) returns (output: Result<GenerateMacResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateMacEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GenerateRandomEnsuresPublicly(input: GenerateRandomRequest, output: Result<GenerateRandomResponse, Error>)
    decreases input, output

  method GenerateRandom(config: InternalConfig, input: GenerateRandomRequest) returns (output: Result<GenerateRandomResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GenerateRandomEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetKeyPolicyEnsuresPublicly(input: GetKeyPolicyRequest, output: Result<GetKeyPolicyResponse, Error>)
    decreases input, output

  method GetKeyPolicy(config: InternalConfig, input: GetKeyPolicyRequest) returns (output: Result<GetKeyPolicyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyPolicyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetKeyRotationStatusEnsuresPublicly(input: GetKeyRotationStatusRequest, output: Result<GetKeyRotationStatusResponse, Error>)
    decreases input, output

  method GetKeyRotationStatus(config: InternalConfig, input: GetKeyRotationStatusRequest) returns (output: Result<GetKeyRotationStatusResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyRotationStatusEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetParametersForImportEnsuresPublicly(input: GetParametersForImportRequest, output: Result<GetParametersForImportResponse, Error>)
    decreases input, output

  method GetParametersForImport(config: InternalConfig, input: GetParametersForImportRequest) returns (output: Result<GetParametersForImportResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetParametersForImportEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetPublicKeyEnsuresPublicly(input: GetPublicKeyRequest, output: Result<GetPublicKeyResponse, Error>)
    decreases input, output

  method GetPublicKey(config: InternalConfig, input: GetPublicKeyRequest) returns (output: Result<GetPublicKeyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetPublicKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ImportKeyMaterialEnsuresPublicly(input: ImportKeyMaterialRequest, output: Result<ImportKeyMaterialResponse, Error>)
    decreases input, output

  method ImportKeyMaterial(config: InternalConfig, input: ImportKeyMaterialRequest) returns (output: Result<ImportKeyMaterialResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ImportKeyMaterialEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListAliasesEnsuresPublicly(input: ListAliasesRequest, output: Result<ListAliasesResponse, Error>)
    decreases input, output

  method ListAliases(config: InternalConfig, input: ListAliasesRequest) returns (output: Result<ListAliasesResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListAliasesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListGrantsEnsuresPublicly(input: ListGrantsRequest, output: Result<ListGrantsResponse, Error>)
    decreases input, output

  method ListGrants(config: InternalConfig, input: ListGrantsRequest) returns (output: Result<ListGrantsResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListGrantsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListKeyPoliciesEnsuresPublicly(input: ListKeyPoliciesRequest, output: Result<ListKeyPoliciesResponse, Error>)
    decreases input, output

  method ListKeyPolicies(config: InternalConfig, input: ListKeyPoliciesRequest) returns (output: Result<ListKeyPoliciesResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListKeyPoliciesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListKeyRotationsEnsuresPublicly(input: ListKeyRotationsRequest, output: Result<ListKeyRotationsResponse, Error>)
    decreases input, output

  method ListKeyRotations(config: InternalConfig, input: ListKeyRotationsRequest) returns (output: Result<ListKeyRotationsResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListKeyRotationsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListKeysEnsuresPublicly(input: ListKeysRequest, output: Result<ListKeysResponse, Error>)
    decreases input, output

  method ListKeys(config: InternalConfig, input: ListKeysRequest) returns (output: Result<ListKeysResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListKeysEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListResourceTagsEnsuresPublicly(input: ListResourceTagsRequest, output: Result<ListResourceTagsResponse, Error>)
    decreases input, output

  method ListResourceTags(config: InternalConfig, input: ListResourceTagsRequest) returns (output: Result<ListResourceTagsResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListResourceTagsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate PutKeyPolicyEnsuresPublicly(input: PutKeyPolicyRequest, output: Result<(), Error>)
    decreases input, output

  method PutKeyPolicy(config: InternalConfig, input: PutKeyPolicyRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutKeyPolicyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ReEncryptEnsuresPublicly(input: ReEncryptRequest, output: Result<ReEncryptResponse, Error>)
    decreases input, output

  method ReEncrypt(config: InternalConfig, input: ReEncryptRequest) returns (output: Result<ReEncryptResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ReEncryptEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ReplicateKeyEnsuresPublicly(input: ReplicateKeyRequest, output: Result<ReplicateKeyResponse, Error>)
    decreases input, output

  method ReplicateKey(config: InternalConfig, input: ReplicateKeyRequest) returns (output: Result<ReplicateKeyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ReplicateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RetireGrantEnsuresPublicly(input: RetireGrantRequest, output: Result<(), Error>)
    decreases input, output

  method RetireGrant(config: InternalConfig, input: RetireGrantRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RetireGrantEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RevokeGrantEnsuresPublicly(input: RevokeGrantRequest, output: Result<(), Error>)
    decreases input, output

  method RevokeGrant(config: InternalConfig, input: RevokeGrantRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RevokeGrantEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RotateKeyOnDemandEnsuresPublicly(input: RotateKeyOnDemandRequest, output: Result<RotateKeyOnDemandResponse, Error>)
    decreases input, output

  method RotateKeyOnDemand(config: InternalConfig, input: RotateKeyOnDemandRequest) returns (output: Result<RotateKeyOnDemandResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RotateKeyOnDemandEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ScheduleKeyDeletionEnsuresPublicly(input: ScheduleKeyDeletionRequest, output: Result<ScheduleKeyDeletionResponse, Error>)
    decreases input, output

  method ScheduleKeyDeletion(config: InternalConfig, input: ScheduleKeyDeletionRequest) returns (output: Result<ScheduleKeyDeletionResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScheduleKeyDeletionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate SignEnsuresPublicly(input: SignRequest, output: Result<SignResponse, Error>)
    decreases input, output

  method Sign(config: InternalConfig, input: SignRequest) returns (output: Result<SignResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures SignEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TagResourceEnsuresPublicly(input: TagResourceRequest, output: Result<(), Error>)
    decreases input, output

  method TagResource(config: InternalConfig, input: TagResourceRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TagResourceEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UntagResourceEnsuresPublicly(input: UntagResourceRequest, output: Result<(), Error>)
    decreases input, output

  method UntagResource(config: InternalConfig, input: UntagResourceRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UntagResourceEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateAliasEnsuresPublicly(input: UpdateAliasRequest, output: Result<(), Error>)
    decreases input, output

  method UpdateAlias(config: InternalConfig, input: UpdateAliasRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateAliasEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateCustomKeyStoreEnsuresPublicly(input: UpdateCustomKeyStoreRequest, output: Result<UpdateCustomKeyStoreResponse, Error>)
    decreases input, output

  method UpdateCustomKeyStore(config: InternalConfig, input: UpdateCustomKeyStoreRequest) returns (output: Result<UpdateCustomKeyStoreResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateCustomKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateKeyDescriptionEnsuresPublicly(input: UpdateKeyDescriptionRequest, output: Result<(), Error>)
    decreases input, output

  method UpdateKeyDescription(config: InternalConfig, input: UpdateKeyDescriptionRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateKeyDescriptionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdatePrimaryRegionEnsuresPublicly(input: UpdatePrimaryRegionRequest, output: Result<(), Error>)
    decreases input, output

  method UpdatePrimaryRegion(config: InternalConfig, input: UpdatePrimaryRegionRequest) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdatePrimaryRegionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate VerifyEnsuresPublicly(input: VerifyRequest, output: Result<VerifyResponse, Error>)
    decreases input, output

  method Verify(config: InternalConfig, input: VerifyRequest) returns (output: Result<VerifyResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VerifyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate VerifyMacEnsuresPublicly(input: VerifyMacRequest, output: Result<VerifyMacResponse, Error>)
    decreases input, output

  method VerifyMac(config: InternalConfig, input: VerifyMacRequest) returns (output: Result<VerifyMacResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VerifyMacEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = ComAmazonawsKmsTypes

  type InternalConfig
}

module {:extern "software.amazon.cryptography.services.dynamodb.internaldafny.types"} ComAmazonawsDynamodbTypes {
  predicate method IsValid_AttributeName(x: string)
    decreases x
  {
    0 <= |x| <= 65535
  }

  predicate method IsValid_AttributeNameList(x: seq<AttributeName>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_AutoScalingPolicyName(x: string)
    decreases x
  {
    1 <= |x| <= 256
  }

  predicate method IsValid_AutoScalingRoleArn(x: string)
    decreases x
  {
    1 <= |x| <= 1600
  }

  predicate method IsValid_BackupArn(x: string)
    decreases x
  {
    37 <= |x| <= 1024
  }

  predicate method IsValid_BackupName(x: string)
    decreases x
  {
    3 <= |x| <= 255
  }

  predicate method IsValid_BackupsInputLimit(x: int32)
    decreases x
  {
    1 <= x <= 100
  }

  predicate method IsValid_BackupSizeBytes(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_BatchGetRequestMap(x: map<TableArn, KeysAndAttributes>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_BatchWriteItemRequestMap(x: map<TableArn, WriteRequests>)
    decreases x
  {
    1 <= |x| <= 25
  }

  predicate method IsValid_BilledSizeBytes(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_CancellationReasonList(x: seq<CancellationReason>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_ClientRequestToken(x: string)
    decreases x
  {
    1 <= |x| <= 36
  }

  predicate method IsValid_CloudWatchLogGroupArn(x: string)
    decreases x
  {
    1 <= |x| <= 1024
  }

  predicate method IsValid_ConsumedCapacityUnits(x: seq<uint8>)
    decreases x
  {
    8 <= |x| <= 8
  }

  predicate method IsValid_CsvDelimiter(x: string)
    decreases x
  {
    1 <= |x| <= 1
  }

  predicate method IsValid_CsvHeader(x: string)
    decreases x
  {
    1 <= |x| <= 65536
  }

  predicate method IsValid_CsvHeaderList(x: seq<CsvHeader>)
    decreases x
  {
    1 <= |x| <= 255
  }

  predicate method IsValid_DoubleObject(x: seq<uint8>)
    decreases x
  {
    8 <= |x| <= 8
  }

  predicate method IsValid_ErrorCount(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_ExportArn(x: string)
    decreases x
  {
    37 <= |x| <= 1024
  }

  predicate method IsValid_GlobalSecondaryIndexAutoScalingUpdateList(x: seq<GlobalSecondaryIndexAutoScalingUpdate>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_GlobalTableGlobalSecondaryIndexSettingsUpdateList(x: seq<GlobalTableGlobalSecondaryIndexSettingsUpdate>)
    decreases x
  {
    1 <= |x| <= 20
  }

  predicate method IsValid_ImportArn(x: string)
    decreases x
  {
    37 <= |x| <= 1024
  }

  predicate method IsValid_ImportedItemCount(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_ImportNextToken(x: string)
    decreases x
  {
    112 <= |x| <= 1024
  }

  predicate method IsValid_IndexName(x: string)
    decreases x
  {
    3 <= |x| <= 255
  }

  predicate method IsValid_ItemCollectionSizeEstimateBound(x: seq<uint8>)
    decreases x
  {
    8 <= |x| <= 8
  }

  predicate method IsValid_ItemCount(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_ItemResponseList(x: seq<ItemResponse>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_KeyList(x: seq<Key>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_KeySchema(x: seq<KeySchemaElement>)
    decreases x
  {
    1 <= |x| <= 2
  }

  predicate method IsValid_KeySchemaAttributeName(x: string)
    decreases x
  {
    1 <= |x| <= 255
  }

  predicate method IsValid_ListContributorInsightsLimit(x: int32)
    decreases x
  {
    x <= 100
  }

  predicate method IsValid_ListExportsMaxLimit(x: int32)
    decreases x
  {
    1 <= x <= 25
  }

  predicate method IsValid_ListImportsMaxLimit(x: int32)
    decreases x
  {
    1 <= x <= 25
  }

  predicate method IsValid_ListTablesInputLimit(x: int32)
    decreases x
  {
    1 <= x <= 100
  }

  predicate method IsValid_NonKeyAttributeName(x: string)
    decreases x
  {
    1 <= |x| <= 255
  }

  predicate method IsValid_NonKeyAttributeNameList(x: seq<NonKeyAttributeName>)
    decreases x
  {
    1 <= |x| <= 20
  }

  predicate method IsValid_NonNegativeLongObject(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_ParameterizedStatements(x: seq<ParameterizedStatement>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_PartiQLBatchRequest(x: seq<BatchStatementRequest>)
    decreases x
  {
    1 <= |x| <= 25
  }

  predicate method IsValid_PartiQLNextToken(x: string)
    decreases x
  {
    1 <= |x| <= 32768
  }

  predicate method IsValid_PartiQLStatement(x: string)
    decreases x
  {
    1 <= |x| <= 8192
  }

  predicate method IsValid_PolicyRevisionId(x: string)
    decreases x
  {
    1 <= |x| <= 255
  }

  predicate method IsValid_PositiveIntegerObject(x: int32)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_PositiveLongObject(x: int64)
    decreases x
  {
    1 <= x
  }

  predicate method IsValid_PreparedStatementParameters(x: seq<AttributeValue>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ProcessedItemCount(x: int64)
    decreases x
  {
    0 <= x
  }

  predicate method IsValid_ReplicaAutoScalingUpdateList(x: seq<ReplicaAutoScalingUpdate>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ReplicaGlobalSecondaryIndexList(x: seq<ReplicaGlobalSecondaryIndex>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ReplicaGlobalSecondaryIndexSettingsUpdateList(x: seq<ReplicaGlobalSecondaryIndexSettingsUpdate>)
    decreases x
  {
    1 <= |x| <= 20
  }

  predicate method IsValid_ReplicaSettingsUpdateList(x: seq<ReplicaSettingsUpdate>)
    decreases x
  {
    1 <= |x| <= 50
  }

  predicate method IsValid_ReplicationGroupUpdateList(x: seq<ReplicationGroupUpdate>)
    decreases x
  {
    1 <= |x|
  }

  predicate method IsValid_ResourceArnString(x: string)
    decreases x
  {
    1 <= |x| <= 1283
  }

  predicate method IsValid_S3Bucket(x: string)
    decreases x
  {
    0 <= |x| <= 255
  }

  predicate method IsValid_S3Prefix(x: string)
    decreases x
  {
    0 <= |x| <= 1024
  }

  predicate method IsValid_S3SseKmsKeyId(x: string)
    decreases x
  {
    1 <= |x| <= 2048
  }

  predicate method IsValid_ScanSegment(x: int32)
    decreases x
  {
    0 <= x <= 999999
  }

  predicate method IsValid_ScanTotalSegments(x: int32)
    decreases x
  {
    1 <= x <= 1000000
  }

  predicate method IsValid_StreamArn(x: string)
    decreases x
  {
    37 <= |x| <= 1024
  }

  predicate method IsValid_TableArn(x: string)
    decreases x
  {
    1 <= |x| <= 1024
  }

  predicate method IsValid_TableName(x: string)
    decreases x
  {
    3 <= |x| <= 255
  }

  predicate method IsValid_TagKeyString(x: string)
    decreases x
  {
    1 <= |x| <= 128
  }

  predicate method IsValid_TagValueString(x: string)
    decreases x
  {
    0 <= |x| <= 256
  }

  predicate method IsValid_TimeToLiveAttributeName(x: string)
    decreases x
  {
    1 <= |x| <= 255
  }

  predicate method IsValid_TransactGetItemList(x: seq<TransactGetItem>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_TransactWriteItemList(x: seq<TransactWriteItem>)
    decreases x
  {
    1 <= |x| <= 100
  }

  predicate method IsValid_WriteRequests(x: seq<WriteRequest>)
    decreases x
  {
    1 <= |x| <= 25
  }

  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype ApproximateCreationDateTimePrecision = MILLISECOND | MICROSECOND

  type ArchivalReason = string

  datatype ArchivalSummary = ArchivalSummary(nameonly ArchivalDateTime: Option<string> := Option.None, nameonly ArchivalReason: Option<ArchivalReason> := Option.None, nameonly ArchivalBackupArn: Option<BackupArn> := Option.None)

  datatype AttributeAction = ADD | PUT | DELETE

  datatype AttributeDefinition = AttributeDefinition(nameonly AttributeName: KeySchemaAttributeName, nameonly AttributeType: ScalarAttributeType)

  type AttributeDefinitions = seq<AttributeDefinition>

  type AttributeMap = map<AttributeName, AttributeValue>

  type AttributeName = x: string
    | IsValid_AttributeName(x)
    witness *

  type AttributeNameList = x: seq<AttributeName>
    | IsValid_AttributeNameList(x)
    witness *

  type AttributeUpdates = map<AttributeName, AttributeValueUpdate>

  datatype AttributeValue = S(S: StringAttributeValue) | N(N: NumberAttributeValue) | B(B: BinaryAttributeValue) | SS(SS: StringSetAttributeValue) | NS(NS: NumberSetAttributeValue) | BS(BS: BinarySetAttributeValue) | M(M: MapAttributeValue) | L(L: ListAttributeValue) | NULL(NULL: NullAttributeValue) | BOOL(BOOL: BooleanAttributeValue)

  type AttributeValueList = seq<AttributeValue>

  datatype AttributeValueUpdate = AttributeValueUpdate(nameonly Value: Option<AttributeValue> := Option.None, nameonly Action: Option<AttributeAction> := Option.None)

  datatype AutoScalingPolicyDescription = AutoScalingPolicyDescription(nameonly PolicyName: Option<AutoScalingPolicyName> := Option.None, nameonly TargetTrackingScalingPolicyConfiguration: Option<AutoScalingTargetTrackingScalingPolicyConfigurationDescription> := Option.None)

  type AutoScalingPolicyDescriptionList = seq<AutoScalingPolicyDescription>

  type AutoScalingPolicyName = x: string
    | IsValid_AutoScalingPolicyName(x)
    witness *

  datatype AutoScalingPolicyUpdate = AutoScalingPolicyUpdate(nameonly PolicyName: Option<AutoScalingPolicyName> := Option.None, nameonly TargetTrackingScalingPolicyConfiguration: AutoScalingTargetTrackingScalingPolicyConfigurationUpdate)

  type AutoScalingRoleArn = x: string
    | IsValid_AutoScalingRoleArn(x)
    witness *

  datatype AutoScalingSettingsDescription = AutoScalingSettingsDescription(nameonly MinimumUnits: Option<PositiveLongObject> := Option.None, nameonly MaximumUnits: Option<PositiveLongObject> := Option.None, nameonly AutoScalingDisabled: Option<BooleanObject> := Option.None, nameonly AutoScalingRoleArn: Option<String> := Option.None, nameonly ScalingPolicies: Option<AutoScalingPolicyDescriptionList> := Option.None)

  datatype AutoScalingSettingsUpdate = AutoScalingSettingsUpdate(nameonly MinimumUnits: Option<PositiveLongObject> := Option.None, nameonly MaximumUnits: Option<PositiveLongObject> := Option.None, nameonly AutoScalingDisabled: Option<BooleanObject> := Option.None, nameonly AutoScalingRoleArn: Option<AutoScalingRoleArn> := Option.None, nameonly ScalingPolicyUpdate: Option<AutoScalingPolicyUpdate> := Option.None)

  datatype AutoScalingTargetTrackingScalingPolicyConfigurationDescription = AutoScalingTargetTrackingScalingPolicyConfigurationDescription(nameonly DisableScaleIn: Option<BooleanObject> := Option.None, nameonly ScaleInCooldown: Option<IntegerObject> := Option.None, nameonly ScaleOutCooldown: Option<IntegerObject> := Option.None, nameonly TargetValue: DoubleObject)

  datatype AutoScalingTargetTrackingScalingPolicyConfigurationUpdate = AutoScalingTargetTrackingScalingPolicyConfigurationUpdate(nameonly DisableScaleIn: Option<BooleanObject> := Option.None, nameonly ScaleInCooldown: Option<IntegerObject> := Option.None, nameonly ScaleOutCooldown: Option<IntegerObject> := Option.None, nameonly TargetValue: DoubleObject)

  type Backfilling = bool

  type BackupArn = x: string
    | IsValid_BackupArn(x)
    witness *

  datatype BackupDescription = BackupDescription(nameonly BackupDetails: Option<BackupDetails> := Option.None, nameonly SourceTableDetails: Option<SourceTableDetails> := Option.None, nameonly SourceTableFeatureDetails: Option<SourceTableFeatureDetails> := Option.None)

  datatype BackupDetails = BackupDetails(nameonly BackupArn: BackupArn, nameonly BackupName: BackupName, nameonly BackupSizeBytes: Option<BackupSizeBytes> := Option.None, nameonly BackupStatus: BackupStatus, nameonly BackupType: BackupType, nameonly BackupCreationDateTime: string, nameonly BackupExpiryDateTime: Option<string> := Option.None)

  type BackupName = x: string
    | IsValid_BackupName(x)
    witness *

  type BackupsInputLimit = x: int32
    | IsValid_BackupsInputLimit(x)
    witness *

  type BackupSizeBytes = x: int64
    | IsValid_BackupSizeBytes(x)
    witness *

  datatype BackupStatus = CREATING | DELETED | AVAILABLE

  type BackupSummaries = seq<BackupSummary>

  datatype BackupSummary = BackupSummary(nameonly TableName: Option<TableName> := Option.None, nameonly TableId: Option<TableId> := Option.None, nameonly TableArn: Option<TableArn> := Option.None, nameonly BackupArn: Option<BackupArn> := Option.None, nameonly BackupName: Option<BackupName> := Option.None, nameonly BackupCreationDateTime: Option<string> := Option.None, nameonly BackupExpiryDateTime: Option<string> := Option.None, nameonly BackupStatus: Option<BackupStatus> := Option.None, nameonly BackupType: Option<BackupType> := Option.None, nameonly BackupSizeBytes: Option<BackupSizeBytes> := Option.None)

  datatype BackupType = USER | SYSTEM | AWS_BACKUP

  datatype BackupTypeFilter = USER | SYSTEM | AWS_BACKUP | ALL

  datatype BatchExecuteStatementInput = BatchExecuteStatementInput(nameonly Statements: PartiQLBatchRequest, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None)

  datatype BatchExecuteStatementOutput = BatchExecuteStatementOutput(nameonly Responses: Option<PartiQLBatchResponse> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None)

  datatype BatchGetItemInput = BatchGetItemInput(nameonly RequestItems: BatchGetRequestMap, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None)

  datatype BatchGetItemOutput = BatchGetItemOutput(nameonly Responses: Option<BatchGetResponseMap> := Option.None, nameonly UnprocessedKeys: Option<BatchGetRequestMap> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None)

  type BatchGetRequestMap = x: map<TableArn, KeysAndAttributes>
    | IsValid_BatchGetRequestMap(x)
    witness *

  type BatchGetResponseMap = map<TableArn, ItemList>

  datatype BatchStatementError = BatchStatementError(nameonly Code: Option<BatchStatementErrorCodeEnum> := Option.None, nameonly Message: Option<String> := Option.None, nameonly Item: Option<AttributeMap> := Option.None)

  datatype BatchStatementErrorCodeEnum = ConditionalCheckFailed | ItemCollectionSizeLimitExceeded | RequestLimitExceeded | ValidationError | ProvisionedThroughputExceeded | TransactionConflict | ThrottlingError | InternalServerError | ResourceNotFound | AccessDenied | DuplicateItem

  datatype BatchStatementRequest = BatchStatementRequest(nameonly Statement: PartiQLStatement, nameonly Parameters: Option<PreparedStatementParameters> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype BatchStatementResponse = BatchStatementResponse(nameonly Error: Option<BatchStatementError> := Option.None, nameonly TableName: Option<TableName> := Option.None, nameonly Item: Option<AttributeMap> := Option.None)

  datatype BatchWriteItemInput = BatchWriteItemInput(nameonly RequestItems: BatchWriteItemRequestMap, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ReturnItemCollectionMetrics: Option<ReturnItemCollectionMetrics> := Option.None)

  datatype BatchWriteItemOutput = BatchWriteItemOutput(nameonly UnprocessedItems: Option<BatchWriteItemRequestMap> := Option.None, nameonly ItemCollectionMetrics: Option<ItemCollectionMetricsPerTable> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None)

  type BatchWriteItemRequestMap = x: map<TableArn, WriteRequests>
    | IsValid_BatchWriteItemRequestMap(x)
    witness *

  type BilledSizeBytes = x: int64
    | IsValid_BilledSizeBytes(x)
    witness *

  datatype BillingMode = PROVISIONED | PAY_PER_REQUEST

  datatype BillingModeSummary = BillingModeSummary(nameonly BillingMode: Option<BillingMode> := Option.None, nameonly LastUpdateToPayPerRequestDateTime: Option<string> := Option.None)

  type BinaryAttributeValue = seq<uint8>

  type BinarySetAttributeValue = seq<BinaryAttributeValue>

  type BooleanAttributeValue = bool

  type BooleanObject = bool

  datatype CancellationReason = CancellationReason(nameonly Item: Option<AttributeMap> := Option.None, nameonly Code: Option<Code> := Option.None, nameonly Message: Option<ErrorMessage> := Option.None)

  type CancellationReasonList = x: seq<CancellationReason>
    | IsValid_CancellationReasonList(x)
    witness *

  datatype Capacity = Capacity(nameonly ReadCapacityUnits: Option<ConsumedCapacityUnits> := Option.None, nameonly WriteCapacityUnits: Option<ConsumedCapacityUnits> := Option.None, nameonly CapacityUnits: Option<ConsumedCapacityUnits> := Option.None)

  type ClientRequestToken = x: string
    | IsValid_ClientRequestToken(x)
    witness *

  type ClientToken = string

  type CloudWatchLogGroupArn = x: string
    | IsValid_CloudWatchLogGroupArn(x)
    witness *

  type Code = string

  datatype ComparisonOperator = EQ | NE | IN | LE | LT | GE | GT | BETWEEN | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS | BEGINS_WITH

  datatype Condition = Condition(nameonly AttributeValueList: Option<AttributeValueList> := Option.None, nameonly ComparisonOperator: ComparisonOperator)

  datatype ConditionalOperator = AND | OR

  datatype ConditionCheck = ConditionCheck(nameonly Key: Key, nameonly TableName: TableArn, nameonly ConditionExpression: ConditionExpression, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  type ConditionExpression = string

  type ConfirmRemoveSelfResourceAccess = bool

  type ConsistentRead = bool

  datatype ConsumedCapacity = ConsumedCapacity(nameonly TableName: Option<TableArn> := Option.None, nameonly CapacityUnits: Option<ConsumedCapacityUnits> := Option.None, nameonly ReadCapacityUnits: Option<ConsumedCapacityUnits> := Option.None, nameonly WriteCapacityUnits: Option<ConsumedCapacityUnits> := Option.None, nameonly Table: Option<Capacity> := Option.None, nameonly LocalSecondaryIndexes: Option<SecondaryIndexesCapacityMap> := Option.None, nameonly GlobalSecondaryIndexes: Option<SecondaryIndexesCapacityMap> := Option.None)

  type ConsumedCapacityMultiple = seq<ConsumedCapacity>

  type ConsumedCapacityUnits = x: seq<uint8>
    | IsValid_ConsumedCapacityUnits(x)
    witness *

  datatype ContinuousBackupsDescription = ContinuousBackupsDescription(nameonly ContinuousBackupsStatus: ContinuousBackupsStatus, nameonly PointInTimeRecoveryDescription: Option<PointInTimeRecoveryDescription> := Option.None)

  datatype ContinuousBackupsStatus = ENABLED | DISABLED

  datatype ContributorInsightsAction = ENABLE | DISABLE

  type ContributorInsightsRule = string

  type ContributorInsightsRuleList = seq<ContributorInsightsRule>

  datatype ContributorInsightsStatus = ENABLING | ENABLED | DISABLING | DISABLED | FAILED

  type ContributorInsightsSummaries = seq<ContributorInsightsSummary>

  datatype ContributorInsightsSummary = ContributorInsightsSummary(nameonly TableName: Option<TableName> := Option.None, nameonly IndexName: Option<IndexName> := Option.None, nameonly ContributorInsightsStatus: Option<ContributorInsightsStatus> := Option.None)

  datatype CreateBackupInput = CreateBackupInput(nameonly TableName: TableArn, nameonly BackupName: BackupName)

  datatype CreateBackupOutput = CreateBackupOutput(nameonly BackupDetails: Option<BackupDetails> := Option.None)

  datatype CreateGlobalSecondaryIndexAction = CreateGlobalSecondaryIndexAction(nameonly IndexName: IndexName, nameonly KeySchema: KeySchema, nameonly Projection: Projection, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  datatype CreateGlobalTableInput = CreateGlobalTableInput(nameonly GlobalTableName: TableName, nameonly ReplicationGroup: ReplicaList)

  datatype CreateGlobalTableOutput = CreateGlobalTableOutput(nameonly GlobalTableDescription: Option<GlobalTableDescription> := Option.None)

  datatype CreateReplicaAction = CreateReplicaAction(nameonly RegionName: RegionName)

  datatype CreateReplicationGroupMemberAction = CreateReplicationGroupMemberAction(nameonly RegionName: RegionName, nameonly KMSMasterKeyId: Option<KMSMasterKeyId> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughputOverride> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughputOverride> := Option.None, nameonly GlobalSecondaryIndexes: Option<ReplicaGlobalSecondaryIndexList> := Option.None, nameonly TableClassOverride: Option<TableClass> := Option.None)

  datatype CreateTableInput = CreateTableInput(nameonly AttributeDefinitions: AttributeDefinitions, nameonly TableName: TableArn, nameonly KeySchema: KeySchema, nameonly LocalSecondaryIndexes: Option<LocalSecondaryIndexList> := Option.None, nameonly GlobalSecondaryIndexes: Option<GlobalSecondaryIndexList> := Option.None, nameonly BillingMode: Option<BillingMode> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly StreamSpecification: Option<StreamSpecification> := Option.None, nameonly SSESpecification: Option<SSESpecification> := Option.None, nameonly Tags: Option<TagList> := Option.None, nameonly TableClass: Option<TableClass> := Option.None, nameonly DeletionProtectionEnabled: Option<DeletionProtectionEnabled> := Option.None, nameonly ResourcePolicy: Option<ResourcePolicy> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  datatype CreateTableOutput = CreateTableOutput(nameonly TableDescription: Option<TableDescription> := Option.None)

  type CsvDelimiter = x: string
    | IsValid_CsvDelimiter(x)
    witness *

  type CsvHeader = x: string
    | IsValid_CsvHeader(x)
    witness *

  type CsvHeaderList = x: seq<CsvHeader>
    | IsValid_CsvHeaderList(x)
    witness *

  datatype CsvOptions = CsvOptions(nameonly Delimiter: Option<CsvDelimiter> := Option.None, nameonly HeaderList: Option<CsvHeaderList> := Option.None)

  datatype Delete = Delete(nameonly Key: Key, nameonly TableName: TableArn, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype DeleteBackupInput = DeleteBackupInput(nameonly BackupArn: BackupArn)

  datatype DeleteBackupOutput = DeleteBackupOutput(nameonly BackupDescription: Option<BackupDescription> := Option.None)

  datatype DeleteGlobalSecondaryIndexAction = DeleteGlobalSecondaryIndexAction(nameonly IndexName: IndexName)

  datatype DeleteItemInput = DeleteItemInput(nameonly TableName: TableArn, nameonly Key: Key, nameonly Expected: Option<ExpectedAttributeMap> := Option.None, nameonly ConditionalOperator: Option<ConditionalOperator> := Option.None, nameonly ReturnValues: Option<ReturnValue> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ReturnItemCollectionMetrics: Option<ReturnItemCollectionMetrics> := Option.None, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype DeleteItemOutput = DeleteItemOutput(nameonly Attributes: Option<AttributeMap> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None, nameonly ItemCollectionMetrics: Option<ItemCollectionMetrics> := Option.None)

  datatype DeleteReplicaAction = DeleteReplicaAction(nameonly RegionName: RegionName)

  datatype DeleteReplicationGroupMemberAction = DeleteReplicationGroupMemberAction(nameonly RegionName: RegionName)

  datatype DeleteRequest = DeleteRequest(nameonly Key: Key)

  datatype DeleteResourcePolicyInput = DeleteResourcePolicyInput(nameonly ResourceArn: ResourceArnString, nameonly ExpectedRevisionId: Option<PolicyRevisionId> := Option.None)

  datatype DeleteResourcePolicyOutput = DeleteResourcePolicyOutput(nameonly RevisionId: Option<PolicyRevisionId> := Option.None)

  datatype DeleteTableInput = DeleteTableInput(nameonly TableName: TableArn)

  datatype DeleteTableOutput = DeleteTableOutput(nameonly TableDescription: Option<TableDescription> := Option.None)

  type DeletionProtectionEnabled = bool

  datatype DescribeBackupInput = DescribeBackupInput(nameonly BackupArn: BackupArn)

  datatype DescribeBackupOutput = DescribeBackupOutput(nameonly BackupDescription: Option<BackupDescription> := Option.None)

  datatype DescribeContinuousBackupsInput = DescribeContinuousBackupsInput(nameonly TableName: TableArn)

  datatype DescribeContinuousBackupsOutput = DescribeContinuousBackupsOutput(nameonly ContinuousBackupsDescription: Option<ContinuousBackupsDescription> := Option.None)

  datatype DescribeContributorInsightsInput = DescribeContributorInsightsInput(nameonly TableName: TableArn, nameonly IndexName: Option<IndexName> := Option.None)

  datatype DescribeContributorInsightsOutput = DescribeContributorInsightsOutput(nameonly TableName: Option<TableName> := Option.None, nameonly IndexName: Option<IndexName> := Option.None, nameonly ContributorInsightsRuleList: Option<ContributorInsightsRuleList> := Option.None, nameonly ContributorInsightsStatus: Option<ContributorInsightsStatus> := Option.None, nameonly LastUpdateDateTime: Option<string> := Option.None, nameonly FailureException: Option<FailureException> := Option.None)

  datatype DescribeEndpointsRequest = DescribeEndpointsRequest

  datatype DescribeEndpointsResponse = DescribeEndpointsResponse(nameonly Endpoints: Endpoints)

  datatype DescribeExportInput = DescribeExportInput(nameonly ExportArn: ExportArn)

  datatype DescribeExportOutput = DescribeExportOutput(nameonly ExportDescription: Option<ExportDescription> := Option.None)

  datatype DescribeGlobalTableInput = DescribeGlobalTableInput(nameonly GlobalTableName: TableName)

  datatype DescribeGlobalTableOutput = DescribeGlobalTableOutput(nameonly GlobalTableDescription: Option<GlobalTableDescription> := Option.None)

  datatype DescribeGlobalTableSettingsInput = DescribeGlobalTableSettingsInput(nameonly GlobalTableName: TableName)

  datatype DescribeGlobalTableSettingsOutput = DescribeGlobalTableSettingsOutput(nameonly GlobalTableName: Option<TableName> := Option.None, nameonly ReplicaSettings: Option<ReplicaSettingsDescriptionList> := Option.None)

  datatype DescribeImportInput = DescribeImportInput(nameonly ImportArn: ImportArn)

  datatype DescribeImportOutput = DescribeImportOutput(nameonly ImportTableDescription: ImportTableDescription)

  datatype DescribeKinesisStreamingDestinationInput = DescribeKinesisStreamingDestinationInput(nameonly TableName: TableArn)

  datatype DescribeKinesisStreamingDestinationOutput = DescribeKinesisStreamingDestinationOutput(nameonly TableName: Option<TableName> := Option.None, nameonly KinesisDataStreamDestinations: Option<KinesisDataStreamDestinations> := Option.None)

  datatype DescribeLimitsInput = DescribeLimitsInput

  datatype DescribeLimitsOutput = DescribeLimitsOutput(nameonly AccountMaxReadCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly AccountMaxWriteCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly TableMaxReadCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly TableMaxWriteCapacityUnits: Option<PositiveLongObject> := Option.None)

  datatype DescribeTableInput = DescribeTableInput(nameonly TableName: TableArn)

  datatype DescribeTableOutput = DescribeTableOutput(nameonly Table: Option<TableDescription> := Option.None)

  datatype DescribeTableReplicaAutoScalingInput = DescribeTableReplicaAutoScalingInput(nameonly TableName: TableArn)

  datatype DescribeTableReplicaAutoScalingOutput = DescribeTableReplicaAutoScalingOutput(nameonly TableAutoScalingDescription: Option<TableAutoScalingDescription> := Option.None)

  datatype DescribeTimeToLiveInput = DescribeTimeToLiveInput(nameonly TableName: TableArn)

  datatype DescribeTimeToLiveOutput = DescribeTimeToLiveOutput(nameonly TimeToLiveDescription: Option<TimeToLiveDescription> := Option.None)

  datatype DestinationStatus = ENABLING | ACTIVE | DISABLING | DISABLED | ENABLE_FAILED | UPDATING

  datatype DisableKinesisStreamingDestinationInput = DisableKinesisStreamingDestinationInput(nameonly TableName: TableArn, nameonly StreamArn: StreamArn, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  datatype DisableKinesisStreamingDestinationOutput = DisableKinesisStreamingDestinationOutput(nameonly TableName: Option<TableName> := Option.None, nameonly StreamArn: Option<StreamArn> := Option.None, nameonly DestinationStatus: Option<DestinationStatus> := Option.None, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  type DoubleObject = x: seq<uint8>
    | IsValid_DoubleObject(x)
    witness *

  class IDynamoDBClientCallHistory {
    ghost constructor ()
    {
      BatchExecuteStatement := [];
      BatchGetItem := [];
      BatchWriteItem := [];
      CreateBackup := [];
      CreateGlobalTable := [];
      CreateTable := [];
      DeleteBackup := [];
      DeleteItem := [];
      DeleteResourcePolicy := [];
      DeleteTable := [];
      DescribeBackup := [];
      DescribeContinuousBackups := [];
      DescribeContributorInsights := [];
      DescribeEndpoints := [];
      DescribeExport := [];
      DescribeGlobalTable := [];
      DescribeGlobalTableSettings := [];
      DescribeImport := [];
      DescribeKinesisStreamingDestination := [];
      DescribeLimits := [];
      DescribeTable := [];
      DescribeTableReplicaAutoScaling := [];
      DescribeTimeToLive := [];
      DisableKinesisStreamingDestination := [];
      EnableKinesisStreamingDestination := [];
      ExecuteStatement := [];
      ExecuteTransaction := [];
      ExportTableToPointInTime := [];
      GetItem := [];
      GetResourcePolicy := [];
      ImportTable := [];
      ListBackups := [];
      ListContributorInsights := [];
      ListExports := [];
      ListGlobalTables := [];
      ListImports := [];
      ListTables := [];
      ListTagsOfResource := [];
      PutItem := [];
      PutResourcePolicy := [];
      Query := [];
      RestoreTableFromBackup := [];
      RestoreTableToPointInTime := [];
      Scan := [];
      TagResource := [];
      TransactGetItems := [];
      TransactWriteItems := [];
      UntagResource := [];
      UpdateContinuousBackups := [];
      UpdateContributorInsights := [];
      UpdateGlobalTable := [];
      UpdateGlobalTableSettings := [];
      UpdateItem := [];
      UpdateKinesisStreamingDestination := [];
      UpdateTable := [];
      UpdateTableReplicaAutoScaling := [];
      UpdateTimeToLive := [];
    }

    ghost var BatchExecuteStatement: seq<DafnyCallEvent<BatchExecuteStatementInput, Result<BatchExecuteStatementOutput, Error>>>
    ghost var BatchGetItem: seq<DafnyCallEvent<BatchGetItemInput, Result<BatchGetItemOutput, Error>>>
    ghost var BatchWriteItem: seq<DafnyCallEvent<BatchWriteItemInput, Result<BatchWriteItemOutput, Error>>>
    ghost var CreateBackup: seq<DafnyCallEvent<CreateBackupInput, Result<CreateBackupOutput, Error>>>
    ghost var CreateGlobalTable: seq<DafnyCallEvent<CreateGlobalTableInput, Result<CreateGlobalTableOutput, Error>>>
    ghost var CreateTable: seq<DafnyCallEvent<CreateTableInput, Result<CreateTableOutput, Error>>>
    ghost var DeleteBackup: seq<DafnyCallEvent<DeleteBackupInput, Result<DeleteBackupOutput, Error>>>
    ghost var DeleteItem: seq<DafnyCallEvent<DeleteItemInput, Result<DeleteItemOutput, Error>>>
    ghost var DeleteResourcePolicy: seq<DafnyCallEvent<DeleteResourcePolicyInput, Result<DeleteResourcePolicyOutput, Error>>>
    ghost var DeleteTable: seq<DafnyCallEvent<DeleteTableInput, Result<DeleteTableOutput, Error>>>
    ghost var DescribeBackup: seq<DafnyCallEvent<DescribeBackupInput, Result<DescribeBackupOutput, Error>>>
    ghost var DescribeContinuousBackups: seq<DafnyCallEvent<DescribeContinuousBackupsInput, Result<DescribeContinuousBackupsOutput, Error>>>
    ghost var DescribeContributorInsights: seq<DafnyCallEvent<DescribeContributorInsightsInput, Result<DescribeContributorInsightsOutput, Error>>>
    ghost var DescribeEndpoints: seq<DafnyCallEvent<DescribeEndpointsRequest, Result<DescribeEndpointsResponse, Error>>>
    ghost var DescribeExport: seq<DafnyCallEvent<DescribeExportInput, Result<DescribeExportOutput, Error>>>
    ghost var DescribeGlobalTable: seq<DafnyCallEvent<DescribeGlobalTableInput, Result<DescribeGlobalTableOutput, Error>>>
    ghost var DescribeGlobalTableSettings: seq<DafnyCallEvent<DescribeGlobalTableSettingsInput, Result<DescribeGlobalTableSettingsOutput, Error>>>
    ghost var DescribeImport: seq<DafnyCallEvent<DescribeImportInput, Result<DescribeImportOutput, Error>>>
    ghost var DescribeKinesisStreamingDestination: seq<DafnyCallEvent<DescribeKinesisStreamingDestinationInput, Result<DescribeKinesisStreamingDestinationOutput, Error>>>
    ghost var DescribeLimits: seq<DafnyCallEvent<DescribeLimitsInput, Result<DescribeLimitsOutput, Error>>>
    ghost var DescribeTable: seq<DafnyCallEvent<DescribeTableInput, Result<DescribeTableOutput, Error>>>
    ghost var DescribeTableReplicaAutoScaling: seq<DafnyCallEvent<DescribeTableReplicaAutoScalingInput, Result<DescribeTableReplicaAutoScalingOutput, Error>>>
    ghost var DescribeTimeToLive: seq<DafnyCallEvent<DescribeTimeToLiveInput, Result<DescribeTimeToLiveOutput, Error>>>
    ghost var DisableKinesisStreamingDestination: seq<DafnyCallEvent<DisableKinesisStreamingDestinationInput, Result<DisableKinesisStreamingDestinationOutput, Error>>>
    ghost var EnableKinesisStreamingDestination: seq<DafnyCallEvent<EnableKinesisStreamingDestinationInput, Result<EnableKinesisStreamingDestinationOutput, Error>>>
    ghost var ExecuteStatement: seq<DafnyCallEvent<ExecuteStatementInput, Result<ExecuteStatementOutput, Error>>>
    ghost var ExecuteTransaction: seq<DafnyCallEvent<ExecuteTransactionInput, Result<ExecuteTransactionOutput, Error>>>
    ghost var ExportTableToPointInTime: seq<DafnyCallEvent<ExportTableToPointInTimeInput, Result<ExportTableToPointInTimeOutput, Error>>>
    ghost var GetItem: seq<DafnyCallEvent<GetItemInput, Result<GetItemOutput, Error>>>
    ghost var GetResourcePolicy: seq<DafnyCallEvent<GetResourcePolicyInput, Result<GetResourcePolicyOutput, Error>>>
    ghost var ImportTable: seq<DafnyCallEvent<ImportTableInput, Result<ImportTableOutput, Error>>>
    ghost var ListBackups: seq<DafnyCallEvent<ListBackupsInput, Result<ListBackupsOutput, Error>>>
    ghost var ListContributorInsights: seq<DafnyCallEvent<ListContributorInsightsInput, Result<ListContributorInsightsOutput, Error>>>
    ghost var ListExports: seq<DafnyCallEvent<ListExportsInput, Result<ListExportsOutput, Error>>>
    ghost var ListGlobalTables: seq<DafnyCallEvent<ListGlobalTablesInput, Result<ListGlobalTablesOutput, Error>>>
    ghost var ListImports: seq<DafnyCallEvent<ListImportsInput, Result<ListImportsOutput, Error>>>
    ghost var ListTables: seq<DafnyCallEvent<ListTablesInput, Result<ListTablesOutput, Error>>>
    ghost var ListTagsOfResource: seq<DafnyCallEvent<ListTagsOfResourceInput, Result<ListTagsOfResourceOutput, Error>>>
    ghost var PutItem: seq<DafnyCallEvent<PutItemInput, Result<PutItemOutput, Error>>>
    ghost var PutResourcePolicy: seq<DafnyCallEvent<PutResourcePolicyInput, Result<PutResourcePolicyOutput, Error>>>
    ghost var Query: seq<DafnyCallEvent<QueryInput, Result<QueryOutput, Error>>>
    ghost var RestoreTableFromBackup: seq<DafnyCallEvent<RestoreTableFromBackupInput, Result<RestoreTableFromBackupOutput, Error>>>
    ghost var RestoreTableToPointInTime: seq<DafnyCallEvent<RestoreTableToPointInTimeInput, Result<RestoreTableToPointInTimeOutput, Error>>>
    ghost var Scan: seq<DafnyCallEvent<ScanInput, Result<ScanOutput, Error>>>
    ghost var TagResource: seq<DafnyCallEvent<TagResourceInput, Result<(), Error>>>
    ghost var TransactGetItems: seq<DafnyCallEvent<TransactGetItemsInput, Result<TransactGetItemsOutput, Error>>>
    ghost var TransactWriteItems: seq<DafnyCallEvent<TransactWriteItemsInput, Result<TransactWriteItemsOutput, Error>>>
    ghost var UntagResource: seq<DafnyCallEvent<UntagResourceInput, Result<(), Error>>>
    ghost var UpdateContinuousBackups: seq<DafnyCallEvent<UpdateContinuousBackupsInput, Result<UpdateContinuousBackupsOutput, Error>>>
    ghost var UpdateContributorInsights: seq<DafnyCallEvent<UpdateContributorInsightsInput, Result<UpdateContributorInsightsOutput, Error>>>
    ghost var UpdateGlobalTable: seq<DafnyCallEvent<UpdateGlobalTableInput, Result<UpdateGlobalTableOutput, Error>>>
    ghost var UpdateGlobalTableSettings: seq<DafnyCallEvent<UpdateGlobalTableSettingsInput, Result<UpdateGlobalTableSettingsOutput, Error>>>
    ghost var UpdateItem: seq<DafnyCallEvent<UpdateItemInput, Result<UpdateItemOutput, Error>>>
    ghost var UpdateKinesisStreamingDestination: seq<DafnyCallEvent<UpdateKinesisStreamingDestinationInput, Result<UpdateKinesisStreamingDestinationOutput, Error>>>
    ghost var UpdateTable: seq<DafnyCallEvent<UpdateTableInput, Result<UpdateTableOutput, Error>>>
    ghost var UpdateTableReplicaAutoScaling: seq<DafnyCallEvent<UpdateTableReplicaAutoScalingInput, Result<UpdateTableReplicaAutoScalingOutput, Error>>>
    ghost var UpdateTimeToLive: seq<DafnyCallEvent<UpdateTimeToLiveInput, Result<UpdateTimeToLiveOutput, Error>>>
  }

  trait {:termination false} IDynamoDBClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IDynamoDBClientCallHistory

    predicate BatchExecuteStatementEnsuresPublicly(input: BatchExecuteStatementInput, output: Result<BatchExecuteStatementOutput, Error>)
      decreases input, output

    method BatchExecuteStatement(input: BatchExecuteStatementInput) returns (output: Result<BatchExecuteStatementOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchExecuteStatement
      ensures true && ValidState()
      ensures BatchExecuteStatementEnsuresPublicly(input, output)
      ensures History.BatchExecuteStatement == old(History.BatchExecuteStatement) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchGetItemEnsuresPublicly(input: BatchGetItemInput, output: Result<BatchGetItemOutput, Error>)
      decreases input, output

    method BatchGetItem(input: BatchGetItemInput) returns (output: Result<BatchGetItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchGetItem
      ensures true && ValidState()
      ensures BatchGetItemEnsuresPublicly(input, output)
      ensures History.BatchGetItem == old(History.BatchGetItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate BatchWriteItemEnsuresPublicly(input: BatchWriteItemInput, output: Result<BatchWriteItemOutput, Error>)
      decreases input, output

    method BatchWriteItem(input: BatchWriteItemInput) returns (output: Result<BatchWriteItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`BatchWriteItem
      ensures true && ValidState()
      ensures BatchWriteItemEnsuresPublicly(input, output)
      ensures History.BatchWriteItem == old(History.BatchWriteItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateBackupEnsuresPublicly(input: CreateBackupInput, output: Result<CreateBackupOutput, Error>)
      decreases input, output

    method CreateBackup(input: CreateBackupInput) returns (output: Result<CreateBackupOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateBackup
      ensures true && ValidState()
      ensures CreateBackupEnsuresPublicly(input, output)
      ensures History.CreateBackup == old(History.CreateBackup) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateGlobalTableEnsuresPublicly(input: CreateGlobalTableInput, output: Result<CreateGlobalTableOutput, Error>)
      decreases input, output

    method CreateGlobalTable(input: CreateGlobalTableInput) returns (output: Result<CreateGlobalTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateGlobalTable
      ensures true && ValidState()
      ensures CreateGlobalTableEnsuresPublicly(input, output)
      ensures History.CreateGlobalTable == old(History.CreateGlobalTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateTableEnsuresPublicly(input: CreateTableInput, output: Result<CreateTableOutput, Error>)
      decreases input, output

    method CreateTable(input: CreateTableInput) returns (output: Result<CreateTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateTable
      ensures true && ValidState()
      ensures CreateTableEnsuresPublicly(input, output)
      ensures History.CreateTable == old(History.CreateTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteBackupEnsuresPublicly(input: DeleteBackupInput, output: Result<DeleteBackupOutput, Error>)
      decreases input, output

    method DeleteBackup(input: DeleteBackupInput) returns (output: Result<DeleteBackupOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteBackup
      ensures true && ValidState()
      ensures DeleteBackupEnsuresPublicly(input, output)
      ensures History.DeleteBackup == old(History.DeleteBackup) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteItemEnsuresPublicly(input: DeleteItemInput, output: Result<DeleteItemOutput, Error>)
      decreases input, output

    method DeleteItem(input: DeleteItemInput) returns (output: Result<DeleteItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteItem
      ensures true && ValidState()
      ensures DeleteItemEnsuresPublicly(input, output)
      ensures History.DeleteItem == old(History.DeleteItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteResourcePolicyEnsuresPublicly(input: DeleteResourcePolicyInput, output: Result<DeleteResourcePolicyOutput, Error>)
      decreases input, output

    method DeleteResourcePolicy(input: DeleteResourcePolicyInput) returns (output: Result<DeleteResourcePolicyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteResourcePolicy
      ensures true && ValidState()
      ensures DeleteResourcePolicyEnsuresPublicly(input, output)
      ensures History.DeleteResourcePolicy == old(History.DeleteResourcePolicy) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DeleteTableEnsuresPublicly(input: DeleteTableInput, output: Result<DeleteTableOutput, Error>)
      decreases input, output

    method DeleteTable(input: DeleteTableInput) returns (output: Result<DeleteTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DeleteTable
      ensures true && ValidState()
      ensures DeleteTableEnsuresPublicly(input, output)
      ensures History.DeleteTable == old(History.DeleteTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeBackupEnsuresPublicly(input: DescribeBackupInput, output: Result<DescribeBackupOutput, Error>)
      decreases input, output

    method DescribeBackup(input: DescribeBackupInput) returns (output: Result<DescribeBackupOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeBackup
      ensures true && ValidState()
      ensures DescribeBackupEnsuresPublicly(input, output)
      ensures History.DescribeBackup == old(History.DescribeBackup) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeContinuousBackupsEnsuresPublicly(input: DescribeContinuousBackupsInput, output: Result<DescribeContinuousBackupsOutput, Error>)
      decreases input, output

    method DescribeContinuousBackups(input: DescribeContinuousBackupsInput) returns (output: Result<DescribeContinuousBackupsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeContinuousBackups
      ensures true && ValidState()
      ensures DescribeContinuousBackupsEnsuresPublicly(input, output)
      ensures History.DescribeContinuousBackups == old(History.DescribeContinuousBackups) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeContributorInsightsEnsuresPublicly(input: DescribeContributorInsightsInput, output: Result<DescribeContributorInsightsOutput, Error>)
      decreases input, output

    method DescribeContributorInsights(input: DescribeContributorInsightsInput) returns (output: Result<DescribeContributorInsightsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeContributorInsights
      ensures true && ValidState()
      ensures DescribeContributorInsightsEnsuresPublicly(input, output)
      ensures History.DescribeContributorInsights == old(History.DescribeContributorInsights) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeEndpointsEnsuresPublicly(input: DescribeEndpointsRequest, output: Result<DescribeEndpointsResponse, Error>)
      decreases input, output

    method DescribeEndpoints(input: DescribeEndpointsRequest) returns (output: Result<DescribeEndpointsResponse, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeEndpoints
      ensures true && ValidState()
      ensures DescribeEndpointsEnsuresPublicly(input, output)
      ensures History.DescribeEndpoints == old(History.DescribeEndpoints) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeExportEnsuresPublicly(input: DescribeExportInput, output: Result<DescribeExportOutput, Error>)
      decreases input, output

    method DescribeExport(input: DescribeExportInput) returns (output: Result<DescribeExportOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeExport
      ensures true && ValidState()
      ensures DescribeExportEnsuresPublicly(input, output)
      ensures History.DescribeExport == old(History.DescribeExport) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeGlobalTableEnsuresPublicly(input: DescribeGlobalTableInput, output: Result<DescribeGlobalTableOutput, Error>)
      decreases input, output

    method DescribeGlobalTable(input: DescribeGlobalTableInput) returns (output: Result<DescribeGlobalTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeGlobalTable
      ensures true && ValidState()
      ensures DescribeGlobalTableEnsuresPublicly(input, output)
      ensures History.DescribeGlobalTable == old(History.DescribeGlobalTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeGlobalTableSettingsEnsuresPublicly(input: DescribeGlobalTableSettingsInput, output: Result<DescribeGlobalTableSettingsOutput, Error>)
      decreases input, output

    method DescribeGlobalTableSettings(input: DescribeGlobalTableSettingsInput) returns (output: Result<DescribeGlobalTableSettingsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeGlobalTableSettings
      ensures true && ValidState()
      ensures DescribeGlobalTableSettingsEnsuresPublicly(input, output)
      ensures History.DescribeGlobalTableSettings == old(History.DescribeGlobalTableSettings) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeImportEnsuresPublicly(input: DescribeImportInput, output: Result<DescribeImportOutput, Error>)
      decreases input, output

    method DescribeImport(input: DescribeImportInput) returns (output: Result<DescribeImportOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeImport
      ensures true && ValidState()
      ensures DescribeImportEnsuresPublicly(input, output)
      ensures History.DescribeImport == old(History.DescribeImport) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeKinesisStreamingDestinationEnsuresPublicly(input: DescribeKinesisStreamingDestinationInput, output: Result<DescribeKinesisStreamingDestinationOutput, Error>)
      decreases input, output

    method DescribeKinesisStreamingDestination(input: DescribeKinesisStreamingDestinationInput) returns (output: Result<DescribeKinesisStreamingDestinationOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeKinesisStreamingDestination
      ensures true && ValidState()
      ensures DescribeKinesisStreamingDestinationEnsuresPublicly(input, output)
      ensures History.DescribeKinesisStreamingDestination == old(History.DescribeKinesisStreamingDestination) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeLimitsEnsuresPublicly(input: DescribeLimitsInput, output: Result<DescribeLimitsOutput, Error>)
      decreases input, output

    method DescribeLimits(input: DescribeLimitsInput) returns (output: Result<DescribeLimitsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeLimits
      ensures true && ValidState()
      ensures DescribeLimitsEnsuresPublicly(input, output)
      ensures History.DescribeLimits == old(History.DescribeLimits) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeTableEnsuresPublicly(input: DescribeTableInput, output: Result<DescribeTableOutput, Error>)
      decreases input, output

    method DescribeTable(input: DescribeTableInput) returns (output: Result<DescribeTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeTable
      ensures true && ValidState()
      ensures DescribeTableEnsuresPublicly(input, output)
      ensures History.DescribeTable == old(History.DescribeTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeTableReplicaAutoScalingEnsuresPublicly(input: DescribeTableReplicaAutoScalingInput, output: Result<DescribeTableReplicaAutoScalingOutput, Error>)
      decreases input, output

    method DescribeTableReplicaAutoScaling(input: DescribeTableReplicaAutoScalingInput) returns (output: Result<DescribeTableReplicaAutoScalingOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeTableReplicaAutoScaling
      ensures true && ValidState()
      ensures DescribeTableReplicaAutoScalingEnsuresPublicly(input, output)
      ensures History.DescribeTableReplicaAutoScaling == old(History.DescribeTableReplicaAutoScaling) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DescribeTimeToLiveEnsuresPublicly(input: DescribeTimeToLiveInput, output: Result<DescribeTimeToLiveOutput, Error>)
      decreases input, output

    method DescribeTimeToLive(input: DescribeTimeToLiveInput) returns (output: Result<DescribeTimeToLiveOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DescribeTimeToLive
      ensures true && ValidState()
      ensures DescribeTimeToLiveEnsuresPublicly(input, output)
      ensures History.DescribeTimeToLive == old(History.DescribeTimeToLive) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate DisableKinesisStreamingDestinationEnsuresPublicly(input: DisableKinesisStreamingDestinationInput, output: Result<DisableKinesisStreamingDestinationOutput, Error>)
      decreases input, output

    method DisableKinesisStreamingDestination(input: DisableKinesisStreamingDestinationInput) returns (output: Result<DisableKinesisStreamingDestinationOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`DisableKinesisStreamingDestination
      ensures true && ValidState()
      ensures DisableKinesisStreamingDestinationEnsuresPublicly(input, output)
      ensures History.DisableKinesisStreamingDestination == old(History.DisableKinesisStreamingDestination) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate EnableKinesisStreamingDestinationEnsuresPublicly(input: EnableKinesisStreamingDestinationInput, output: Result<EnableKinesisStreamingDestinationOutput, Error>)
      decreases input, output

    method EnableKinesisStreamingDestination(input: EnableKinesisStreamingDestinationInput) returns (output: Result<EnableKinesisStreamingDestinationOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`EnableKinesisStreamingDestination
      ensures true && ValidState()
      ensures EnableKinesisStreamingDestinationEnsuresPublicly(input, output)
      ensures History.EnableKinesisStreamingDestination == old(History.EnableKinesisStreamingDestination) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteStatementEnsuresPublicly(input: ExecuteStatementInput, output: Result<ExecuteStatementOutput, Error>)
      decreases input, output

    method ExecuteStatement(input: ExecuteStatementInput) returns (output: Result<ExecuteStatementOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteStatement
      ensures true && ValidState()
      ensures ExecuteStatementEnsuresPublicly(input, output)
      ensures History.ExecuteStatement == old(History.ExecuteStatement) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExecuteTransactionEnsuresPublicly(input: ExecuteTransactionInput, output: Result<ExecuteTransactionOutput, Error>)
      decreases input, output

    method ExecuteTransaction(input: ExecuteTransactionInput) returns (output: Result<ExecuteTransactionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExecuteTransaction
      ensures true && ValidState()
      ensures ExecuteTransactionEnsuresPublicly(input, output)
      ensures History.ExecuteTransaction == old(History.ExecuteTransaction) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ExportTableToPointInTimeEnsuresPublicly(input: ExportTableToPointInTimeInput, output: Result<ExportTableToPointInTimeOutput, Error>)
      decreases input, output

    method ExportTableToPointInTime(input: ExportTableToPointInTimeInput) returns (output: Result<ExportTableToPointInTimeOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ExportTableToPointInTime
      ensures true && ValidState()
      ensures ExportTableToPointInTimeEnsuresPublicly(input, output)
      ensures History.ExportTableToPointInTime == old(History.ExportTableToPointInTime) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetItemEnsuresPublicly(input: GetItemInput, output: Result<GetItemOutput, Error>)
      decreases input, output

    method GetItem(input: GetItemInput) returns (output: Result<GetItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetItem
      ensures true && ValidState()
      ensures GetItemEnsuresPublicly(input, output)
      ensures History.GetItem == old(History.GetItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetResourcePolicyEnsuresPublicly(input: GetResourcePolicyInput, output: Result<GetResourcePolicyOutput, Error>)
      decreases input, output

    method GetResourcePolicy(input: GetResourcePolicyInput) returns (output: Result<GetResourcePolicyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetResourcePolicy
      ensures true && ValidState()
      ensures GetResourcePolicyEnsuresPublicly(input, output)
      ensures History.GetResourcePolicy == old(History.GetResourcePolicy) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ImportTableEnsuresPublicly(input: ImportTableInput, output: Result<ImportTableOutput, Error>)
      decreases input, output

    method ImportTable(input: ImportTableInput) returns (output: Result<ImportTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ImportTable
      ensures true && ValidState()
      ensures ImportTableEnsuresPublicly(input, output)
      ensures History.ImportTable == old(History.ImportTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListBackupsEnsuresPublicly(input: ListBackupsInput, output: Result<ListBackupsOutput, Error>)
      decreases input, output

    method ListBackups(input: ListBackupsInput) returns (output: Result<ListBackupsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListBackups
      ensures true && ValidState()
      ensures ListBackupsEnsuresPublicly(input, output)
      ensures History.ListBackups == old(History.ListBackups) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListContributorInsightsEnsuresPublicly(input: ListContributorInsightsInput, output: Result<ListContributorInsightsOutput, Error>)
      decreases input, output

    method ListContributorInsights(input: ListContributorInsightsInput) returns (output: Result<ListContributorInsightsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListContributorInsights
      ensures true && ValidState()
      ensures ListContributorInsightsEnsuresPublicly(input, output)
      ensures History.ListContributorInsights == old(History.ListContributorInsights) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListExportsEnsuresPublicly(input: ListExportsInput, output: Result<ListExportsOutput, Error>)
      decreases input, output

    method ListExports(input: ListExportsInput) returns (output: Result<ListExportsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListExports
      ensures true && ValidState()
      ensures ListExportsEnsuresPublicly(input, output)
      ensures History.ListExports == old(History.ListExports) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListGlobalTablesEnsuresPublicly(input: ListGlobalTablesInput, output: Result<ListGlobalTablesOutput, Error>)
      decreases input, output

    method ListGlobalTables(input: ListGlobalTablesInput) returns (output: Result<ListGlobalTablesOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListGlobalTables
      ensures true && ValidState()
      ensures ListGlobalTablesEnsuresPublicly(input, output)
      ensures History.ListGlobalTables == old(History.ListGlobalTables) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListImportsEnsuresPublicly(input: ListImportsInput, output: Result<ListImportsOutput, Error>)
      decreases input, output

    method ListImports(input: ListImportsInput) returns (output: Result<ListImportsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListImports
      ensures true && ValidState()
      ensures ListImportsEnsuresPublicly(input, output)
      ensures History.ListImports == old(History.ListImports) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListTablesEnsuresPublicly(input: ListTablesInput, output: Result<ListTablesOutput, Error>)
      decreases input, output

    method ListTables(input: ListTablesInput) returns (output: Result<ListTablesOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListTables
      ensures true && ValidState()
      ensures ListTablesEnsuresPublicly(input, output)
      ensures History.ListTables == old(History.ListTables) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ListTagsOfResourceEnsuresPublicly(input: ListTagsOfResourceInput, output: Result<ListTagsOfResourceOutput, Error>)
      decreases input, output

    method ListTagsOfResource(input: ListTagsOfResourceInput) returns (output: Result<ListTagsOfResourceOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`ListTagsOfResource
      ensures true && ValidState()
      ensures ListTagsOfResourceEnsuresPublicly(input, output)
      ensures History.ListTagsOfResource == old(History.ListTagsOfResource) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate PutItemEnsuresPublicly(input: PutItemInput, output: Result<PutItemOutput, Error>)
      decreases input, output

    method PutItem(input: PutItemInput) returns (output: Result<PutItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutItem
      ensures true && ValidState()
      ensures PutItemEnsuresPublicly(input, output)
      ensures History.PutItem == old(History.PutItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate PutResourcePolicyEnsuresPublicly(input: PutResourcePolicyInput, output: Result<PutResourcePolicyOutput, Error>)
      decreases input, output

    method PutResourcePolicy(input: PutResourcePolicyInput) returns (output: Result<PutResourcePolicyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`PutResourcePolicy
      ensures true && ValidState()
      ensures PutResourcePolicyEnsuresPublicly(input, output)
      ensures History.PutResourcePolicy == old(History.PutResourcePolicy) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate QueryEnsuresPublicly(input: QueryInput, output: Result<QueryOutput, Error>)
      decreases input, output

    method Query(input: QueryInput) returns (output: Result<QueryOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Query
      ensures true && ValidState()
      ensures QueryEnsuresPublicly(input, output)
      ensures History.Query == old(History.Query) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RestoreTableFromBackupEnsuresPublicly(input: RestoreTableFromBackupInput, output: Result<RestoreTableFromBackupOutput, Error>)
      decreases input, output

    method RestoreTableFromBackup(input: RestoreTableFromBackupInput) returns (output: Result<RestoreTableFromBackupOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RestoreTableFromBackup
      ensures true && ValidState()
      ensures RestoreTableFromBackupEnsuresPublicly(input, output)
      ensures History.RestoreTableFromBackup == old(History.RestoreTableFromBackup) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate RestoreTableToPointInTimeEnsuresPublicly(input: RestoreTableToPointInTimeInput, output: Result<RestoreTableToPointInTimeOutput, Error>)
      decreases input, output

    method RestoreTableToPointInTime(input: RestoreTableToPointInTimeInput) returns (output: Result<RestoreTableToPointInTimeOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`RestoreTableToPointInTime
      ensures true && ValidState()
      ensures RestoreTableToPointInTimeEnsuresPublicly(input, output)
      ensures History.RestoreTableToPointInTime == old(History.RestoreTableToPointInTime) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate ScanEnsuresPublicly(input: ScanInput, output: Result<ScanOutput, Error>)
      decreases input, output

    method Scan(input: ScanInput) returns (output: Result<ScanOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`Scan
      ensures true && ValidState()
      ensures ScanEnsuresPublicly(input, output)
      ensures History.Scan == old(History.Scan) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TagResourceEnsuresPublicly(input: TagResourceInput, output: Result<(), Error>)
      decreases input, output

    method TagResource(input: TagResourceInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TagResource
      ensures true && ValidState()
      ensures TagResourceEnsuresPublicly(input, output)
      ensures History.TagResource == old(History.TagResource) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactGetItemsEnsuresPublicly(input: TransactGetItemsInput, output: Result<TransactGetItemsOutput, Error>)
      decreases input, output

    method TransactGetItems(input: TransactGetItemsInput) returns (output: Result<TransactGetItemsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactGetItems
      ensures true && ValidState()
      ensures TransactGetItemsEnsuresPublicly(input, output)
      ensures History.TransactGetItems == old(History.TransactGetItems) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate TransactWriteItemsEnsuresPublicly(input: TransactWriteItemsInput, output: Result<TransactWriteItemsOutput, Error>)
      decreases input, output

    method TransactWriteItems(input: TransactWriteItemsInput) returns (output: Result<TransactWriteItemsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`TransactWriteItems
      ensures true && ValidState()
      ensures TransactWriteItemsEnsuresPublicly(input, output)
      ensures History.TransactWriteItems == old(History.TransactWriteItems) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UntagResourceEnsuresPublicly(input: UntagResourceInput, output: Result<(), Error>)
      decreases input, output

    method UntagResource(input: UntagResourceInput) returns (output: Result<(), Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UntagResource
      ensures true && ValidState()
      ensures UntagResourceEnsuresPublicly(input, output)
      ensures History.UntagResource == old(History.UntagResource) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateContinuousBackupsEnsuresPublicly(input: UpdateContinuousBackupsInput, output: Result<UpdateContinuousBackupsOutput, Error>)
      decreases input, output

    method UpdateContinuousBackups(input: UpdateContinuousBackupsInput) returns (output: Result<UpdateContinuousBackupsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateContinuousBackups
      ensures true && ValidState()
      ensures UpdateContinuousBackupsEnsuresPublicly(input, output)
      ensures History.UpdateContinuousBackups == old(History.UpdateContinuousBackups) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateContributorInsightsEnsuresPublicly(input: UpdateContributorInsightsInput, output: Result<UpdateContributorInsightsOutput, Error>)
      decreases input, output

    method UpdateContributorInsights(input: UpdateContributorInsightsInput) returns (output: Result<UpdateContributorInsightsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateContributorInsights
      ensures true && ValidState()
      ensures UpdateContributorInsightsEnsuresPublicly(input, output)
      ensures History.UpdateContributorInsights == old(History.UpdateContributorInsights) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateGlobalTableEnsuresPublicly(input: UpdateGlobalTableInput, output: Result<UpdateGlobalTableOutput, Error>)
      decreases input, output

    method UpdateGlobalTable(input: UpdateGlobalTableInput) returns (output: Result<UpdateGlobalTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateGlobalTable
      ensures true && ValidState()
      ensures UpdateGlobalTableEnsuresPublicly(input, output)
      ensures History.UpdateGlobalTable == old(History.UpdateGlobalTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateGlobalTableSettingsEnsuresPublicly(input: UpdateGlobalTableSettingsInput, output: Result<UpdateGlobalTableSettingsOutput, Error>)
      decreases input, output

    method UpdateGlobalTableSettings(input: UpdateGlobalTableSettingsInput) returns (output: Result<UpdateGlobalTableSettingsOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateGlobalTableSettings
      ensures true && ValidState()
      ensures UpdateGlobalTableSettingsEnsuresPublicly(input, output)
      ensures History.UpdateGlobalTableSettings == old(History.UpdateGlobalTableSettings) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateItemEnsuresPublicly(input: UpdateItemInput, output: Result<UpdateItemOutput, Error>)
      decreases input, output

    method UpdateItem(input: UpdateItemInput) returns (output: Result<UpdateItemOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateItem
      ensures true && ValidState()
      ensures UpdateItemEnsuresPublicly(input, output)
      ensures History.UpdateItem == old(History.UpdateItem) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateKinesisStreamingDestinationEnsuresPublicly(input: UpdateKinesisStreamingDestinationInput, output: Result<UpdateKinesisStreamingDestinationOutput, Error>)
      decreases input, output

    method UpdateKinesisStreamingDestination(input: UpdateKinesisStreamingDestinationInput) returns (output: Result<UpdateKinesisStreamingDestinationOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateKinesisStreamingDestination
      ensures true && ValidState()
      ensures UpdateKinesisStreamingDestinationEnsuresPublicly(input, output)
      ensures History.UpdateKinesisStreamingDestination == old(History.UpdateKinesisStreamingDestination) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateTableEnsuresPublicly(input: UpdateTableInput, output: Result<UpdateTableOutput, Error>)
      decreases input, output

    method UpdateTable(input: UpdateTableInput) returns (output: Result<UpdateTableOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateTable
      ensures true && ValidState()
      ensures UpdateTableEnsuresPublicly(input, output)
      ensures History.UpdateTable == old(History.UpdateTable) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateTableReplicaAutoScalingEnsuresPublicly(input: UpdateTableReplicaAutoScalingInput, output: Result<UpdateTableReplicaAutoScalingOutput, Error>)
      decreases input, output

    method UpdateTableReplicaAutoScaling(input: UpdateTableReplicaAutoScalingInput) returns (output: Result<UpdateTableReplicaAutoScalingOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateTableReplicaAutoScaling
      ensures true && ValidState()
      ensures UpdateTableReplicaAutoScalingEnsuresPublicly(input, output)
      ensures History.UpdateTableReplicaAutoScaling == old(History.UpdateTableReplicaAutoScaling) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate UpdateTimeToLiveEnsuresPublicly(input: UpdateTimeToLiveInput, output: Result<UpdateTimeToLiveOutput, Error>)
      decreases input, output

    method UpdateTimeToLive(input: UpdateTimeToLiveInput) returns (output: Result<UpdateTimeToLiveOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`UpdateTimeToLive
      ensures true && ValidState()
      ensures UpdateTimeToLiveEnsuresPublicly(input, output)
      ensures History.UpdateTimeToLive == old(History.UpdateTimeToLive) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype EnableKinesisStreamingConfiguration = EnableKinesisStreamingConfiguration(nameonly ApproximateCreationDateTimePrecision: Option<ApproximateCreationDateTimePrecision> := Option.None)

  datatype EnableKinesisStreamingDestinationInput = EnableKinesisStreamingDestinationInput(nameonly TableName: TableArn, nameonly StreamArn: StreamArn, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  datatype EnableKinesisStreamingDestinationOutput = EnableKinesisStreamingDestinationOutput(nameonly TableName: Option<TableName> := Option.None, nameonly StreamArn: Option<StreamArn> := Option.None, nameonly DestinationStatus: Option<DestinationStatus> := Option.None, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  datatype Endpoint = Endpoint(nameonly Address: String, nameonly CachePeriodInMinutes: Long)

  type Endpoints = seq<Endpoint>

  type ErrorCount = x: int64
    | IsValid_ErrorCount(x)
    witness *

  type ErrorMessage = string

  type ExceptionDescription = string

  type ExceptionName = string

  datatype ExecuteStatementInput = ExecuteStatementInput(nameonly Statement: PartiQLStatement, nameonly Parameters: Option<PreparedStatementParameters> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None, nameonly NextToken: Option<PartiQLNextToken> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly Limit: Option<PositiveIntegerObject> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype ExecuteStatementOutput = ExecuteStatementOutput(nameonly Items: Option<ItemList> := Option.None, nameonly NextToken: Option<PartiQLNextToken> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None, nameonly LastEvaluatedKey: Option<Key> := Option.None)

  datatype ExecuteTransactionInput = ExecuteTransactionInput(nameonly TransactStatements: ParameterizedStatements, nameonly ClientRequestToken: Option<ClientRequestToken> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None)

  datatype ExecuteTransactionOutput = ExecuteTransactionOutput(nameonly Responses: Option<ItemResponseList> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None)

  type ExpectedAttributeMap = map<AttributeName, ExpectedAttributeValue>

  datatype ExpectedAttributeValue = ExpectedAttributeValue(nameonly Value: Option<AttributeValue> := Option.None, nameonly Exists: Option<BooleanObject> := Option.None, nameonly ComparisonOperator: Option<ComparisonOperator> := Option.None, nameonly AttributeValueList: Option<AttributeValueList> := Option.None)

  type ExportArn = x: string
    | IsValid_ExportArn(x)
    witness *

  datatype ExportDescription = ExportDescription(nameonly ExportArn: Option<ExportArn> := Option.None, nameonly ExportStatus: Option<ExportStatus> := Option.None, nameonly StartTime: Option<string> := Option.None, nameonly EndTime: Option<string> := Option.None, nameonly ExportManifest: Option<ExportManifest> := Option.None, nameonly TableArn: Option<TableArn> := Option.None, nameonly TableId: Option<TableId> := Option.None, nameonly ExportTime: Option<string> := Option.None, nameonly ClientToken: Option<ClientToken> := Option.None, nameonly S3Bucket: Option<S3Bucket> := Option.None, nameonly S3BucketOwner: Option<S3BucketOwner> := Option.None, nameonly S3Prefix: Option<S3Prefix> := Option.None, nameonly S3SseAlgorithm: Option<S3SseAlgorithm> := Option.None, nameonly S3SseKmsKeyId: Option<S3SseKmsKeyId> := Option.None, nameonly FailureCode: Option<FailureCode> := Option.None, nameonly FailureMessage: Option<FailureMessage> := Option.None, nameonly ExportFormat: Option<ExportFormat> := Option.None, nameonly BilledSizeBytes: Option<BilledSizeBytes> := Option.None, nameonly ItemCount: Option<ItemCount> := Option.None, nameonly ExportType: Option<ExportType> := Option.None, nameonly IncrementalExportSpecification: Option<IncrementalExportSpecification> := Option.None)

  datatype ExportFormat = DYNAMODB_JSON | ION

  type ExportManifest = string

  type ExportNextToken = string

  datatype ExportStatus = IN_PROGRESS | COMPLETED | FAILED

  type ExportSummaries = seq<ExportSummary>

  datatype ExportSummary = ExportSummary(nameonly ExportArn: Option<ExportArn> := Option.None, nameonly ExportStatus: Option<ExportStatus> := Option.None, nameonly ExportType: Option<ExportType> := Option.None)

  datatype ExportTableToPointInTimeInput = ExportTableToPointInTimeInput(nameonly TableArn: TableArn, nameonly ExportTime: Option<string> := Option.None, nameonly ClientToken: Option<ClientToken> := Option.None, nameonly S3Bucket: S3Bucket, nameonly S3BucketOwner: Option<S3BucketOwner> := Option.None, nameonly S3Prefix: Option<S3Prefix> := Option.None, nameonly S3SseAlgorithm: Option<S3SseAlgorithm> := Option.None, nameonly S3SseKmsKeyId: Option<S3SseKmsKeyId> := Option.None, nameonly ExportFormat: Option<ExportFormat> := Option.None, nameonly ExportType: Option<ExportType> := Option.None, nameonly IncrementalExportSpecification: Option<IncrementalExportSpecification> := Option.None)

  datatype ExportTableToPointInTimeOutput = ExportTableToPointInTimeOutput(nameonly ExportDescription: Option<ExportDescription> := Option.None)

  datatype ExportType = FULL_EXPORT | INCREMENTAL_EXPORT

  datatype ExportViewType = NEW_IMAGE | NEW_AND_OLD_IMAGES

  type ExpressionAttributeNameMap = map<ExpressionAttributeNameVariable, AttributeName>

  type ExpressionAttributeNameVariable = string

  type ExpressionAttributeValueMap = map<ExpressionAttributeValueVariable, AttributeValue>

  type ExpressionAttributeValueVariable = string

  type FailureCode = string

  datatype FailureException = FailureException(nameonly ExceptionName: Option<ExceptionName> := Option.None, nameonly ExceptionDescription: Option<ExceptionDescription> := Option.None)

  type FailureMessage = string

  type FilterConditionMap = map<AttributeName, Condition>

  datatype Get = Get(nameonly Key: Key, nameonly TableName: TableArn, nameonly ProjectionExpression: Option<ProjectionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None)

  datatype GetItemInput = GetItemInput(nameonly TableName: TableArn, nameonly Key: Key, nameonly AttributesToGet: Option<AttributeNameList> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ProjectionExpression: Option<ProjectionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None)

  datatype GetItemOutput = GetItemOutput(nameonly Item: Option<AttributeMap> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None)

  datatype GetResourcePolicyInput = GetResourcePolicyInput(nameonly ResourceArn: ResourceArnString)

  datatype GetResourcePolicyOutput = GetResourcePolicyOutput(nameonly Policy: Option<ResourcePolicy> := Option.None, nameonly RevisionId: Option<PolicyRevisionId> := Option.None)

  datatype GlobalSecondaryIndex = GlobalSecondaryIndex(nameonly IndexName: IndexName, nameonly KeySchema: KeySchema, nameonly Projection: Projection, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  datatype GlobalSecondaryIndexAutoScalingUpdate = GlobalSecondaryIndexAutoScalingUpdate(nameonly IndexName: Option<IndexName> := Option.None, nameonly ProvisionedWriteCapacityAutoScalingUpdate: Option<AutoScalingSettingsUpdate> := Option.None)

  type GlobalSecondaryIndexAutoScalingUpdateList = x: seq<GlobalSecondaryIndexAutoScalingUpdate>
    | IsValid_GlobalSecondaryIndexAutoScalingUpdateList(x)
    witness *

  datatype GlobalSecondaryIndexDescription = GlobalSecondaryIndexDescription(nameonly IndexName: Option<IndexName> := Option.None, nameonly KeySchema: Option<KeySchema> := Option.None, nameonly Projection: Option<Projection> := Option.None, nameonly IndexStatus: Option<IndexStatus> := Option.None, nameonly Backfilling: Option<Backfilling> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughputDescription> := Option.None, nameonly IndexSizeBytes: Option<LongObject> := Option.None, nameonly ItemCount: Option<LongObject> := Option.None, nameonly IndexArn: Option<String> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  type GlobalSecondaryIndexDescriptionList = seq<GlobalSecondaryIndexDescription>

  type GlobalSecondaryIndexes = seq<GlobalSecondaryIndexInfo>

  datatype GlobalSecondaryIndexInfo = GlobalSecondaryIndexInfo(nameonly IndexName: Option<IndexName> := Option.None, nameonly KeySchema: Option<KeySchema> := Option.None, nameonly Projection: Option<Projection> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  type GlobalSecondaryIndexList = seq<GlobalSecondaryIndex>

  datatype GlobalSecondaryIndexUpdate = GlobalSecondaryIndexUpdate(nameonly Update: Option<UpdateGlobalSecondaryIndexAction> := Option.None, nameonly Create: Option<CreateGlobalSecondaryIndexAction> := Option.None, nameonly Delete: Option<DeleteGlobalSecondaryIndexAction> := Option.None)

  type GlobalSecondaryIndexUpdateList = seq<GlobalSecondaryIndexUpdate>

  datatype GlobalTable = GlobalTable(nameonly GlobalTableName: Option<TableName> := Option.None, nameonly ReplicationGroup: Option<ReplicaList> := Option.None)

  type GlobalTableArnString = string

  datatype GlobalTableDescription = GlobalTableDescription(nameonly ReplicationGroup: Option<ReplicaDescriptionList> := Option.None, nameonly GlobalTableArn: Option<GlobalTableArnString> := Option.None, nameonly CreationDateTime: Option<string> := Option.None, nameonly GlobalTableStatus: Option<GlobalTableStatus> := Option.None, nameonly GlobalTableName: Option<TableName> := Option.None)

  datatype GlobalTableGlobalSecondaryIndexSettingsUpdate = GlobalTableGlobalSecondaryIndexSettingsUpdate(nameonly IndexName: IndexName, nameonly ProvisionedWriteCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly ProvisionedWriteCapacityAutoScalingSettingsUpdate: Option<AutoScalingSettingsUpdate> := Option.None)

  type GlobalTableGlobalSecondaryIndexSettingsUpdateList = x: seq<GlobalTableGlobalSecondaryIndexSettingsUpdate>
    | IsValid_GlobalTableGlobalSecondaryIndexSettingsUpdateList(x)
    witness *

  type GlobalTableList = seq<GlobalTable>

  datatype GlobalTableStatus = CREATING | ACTIVE | DELETING | UPDATING

  type ImportArn = x: string
    | IsValid_ImportArn(x)
    witness *

  type ImportedItemCount = x: int64
    | IsValid_ImportedItemCount(x)
    witness *

  type ImportNextToken = x: string
    | IsValid_ImportNextToken(x)
    witness *

  datatype ImportStatus = IN_PROGRESS | COMPLETED | CANCELLING | CANCELLED | FAILED

  datatype ImportSummary = ImportSummary(nameonly ImportArn: Option<ImportArn> := Option.None, nameonly ImportStatus: Option<ImportStatus> := Option.None, nameonly TableArn: Option<TableArn> := Option.None, nameonly S3BucketSource: Option<S3BucketSource> := Option.None, nameonly CloudWatchLogGroupArn: Option<CloudWatchLogGroupArn> := Option.None, nameonly InputFormat: Option<InputFormat> := Option.None, nameonly StartTime: Option<string> := Option.None, nameonly EndTime: Option<string> := Option.None)

  type ImportSummaryList = seq<ImportSummary>

  datatype ImportTableDescription = ImportTableDescription(nameonly ImportArn: Option<ImportArn> := Option.None, nameonly ImportStatus: Option<ImportStatus> := Option.None, nameonly TableArn: Option<TableArn> := Option.None, nameonly TableId: Option<TableId> := Option.None, nameonly ClientToken: Option<ClientToken> := Option.None, nameonly S3BucketSource: Option<S3BucketSource> := Option.None, nameonly ErrorCount: Option<ErrorCount> := Option.None, nameonly CloudWatchLogGroupArn: Option<CloudWatchLogGroupArn> := Option.None, nameonly InputFormat: Option<InputFormat> := Option.None, nameonly InputFormatOptions: Option<InputFormatOptions> := Option.None, nameonly InputCompressionType: Option<InputCompressionType> := Option.None, nameonly TableCreationParameters: Option<TableCreationParameters> := Option.None, nameonly StartTime: Option<string> := Option.None, nameonly EndTime: Option<string> := Option.None, nameonly ProcessedSizeBytes: Option<LongObject> := Option.None, nameonly ProcessedItemCount: Option<ProcessedItemCount> := Option.None, nameonly ImportedItemCount: Option<ImportedItemCount> := Option.None, nameonly FailureCode: Option<FailureCode> := Option.None, nameonly FailureMessage: Option<FailureMessage> := Option.None)

  datatype ImportTableInput = ImportTableInput(nameonly ClientToken: Option<ClientToken> := Option.None, nameonly S3BucketSource: S3BucketSource, nameonly InputFormat: InputFormat, nameonly InputFormatOptions: Option<InputFormatOptions> := Option.None, nameonly InputCompressionType: Option<InputCompressionType> := Option.None, nameonly TableCreationParameters: TableCreationParameters)

  datatype ImportTableOutput = ImportTableOutput(nameonly ImportTableDescription: ImportTableDescription)

  datatype IncrementalExportSpecification = IncrementalExportSpecification(nameonly ExportFromTime: Option<string> := Option.None, nameonly ExportToTime: Option<string> := Option.None, nameonly ExportViewType: Option<ExportViewType> := Option.None)

  type IndexName = x: string
    | IsValid_IndexName(x)
    witness *

  datatype IndexStatus = CREATING | UPDATING | DELETING | ACTIVE

  datatype InputCompressionType = GZIP | ZSTD | NONE

  datatype InputFormat = DYNAMODB_JSON | ION | CSV

  datatype InputFormatOptions = InputFormatOptions(nameonly Csv: Option<CsvOptions> := Option.None)

  type Integer = int32

  type IntegerObject = int32

  type ItemCollectionKeyAttributeMap = map<AttributeName, AttributeValue>

  datatype ItemCollectionMetrics = ItemCollectionMetrics(nameonly ItemCollectionKey: Option<ItemCollectionKeyAttributeMap> := Option.None, nameonly SizeEstimateRangeGB: Option<ItemCollectionSizeEstimateRange> := Option.None)

  type ItemCollectionMetricsMultiple = seq<ItemCollectionMetrics>

  type ItemCollectionMetricsPerTable = map<TableArn, ItemCollectionMetricsMultiple>

  type ItemCollectionSizeEstimateBound = x: seq<uint8>
    | IsValid_ItemCollectionSizeEstimateBound(x)
    witness *

  type ItemCollectionSizeEstimateRange = seq<ItemCollectionSizeEstimateBound>

  type ItemCount = x: int64
    | IsValid_ItemCount(x)
    witness *

  type ItemList = seq<AttributeMap>

  datatype ItemResponse = ItemResponse(nameonly Item: Option<AttributeMap> := Option.None)

  type ItemResponseList = x: seq<ItemResponse>
    | IsValid_ItemResponseList(x)
    witness *

  type Key = map<AttributeName, AttributeValue>

  type KeyConditions = map<AttributeName, Condition>

  type KeyExpression = string

  type KeyList = x: seq<Key>
    | IsValid_KeyList(x)
    witness *

  datatype KeysAndAttributes = KeysAndAttributes(nameonly Keys: KeyList, nameonly AttributesToGet: Option<AttributeNameList> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None, nameonly ProjectionExpression: Option<ProjectionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None)

  type KeySchema = x: seq<KeySchemaElement>
    | IsValid_KeySchema(x)
    witness *

  type KeySchemaAttributeName = x: string
    | IsValid_KeySchemaAttributeName(x)
    witness *

  datatype KeySchemaElement = KeySchemaElement(nameonly AttributeName: KeySchemaAttributeName, nameonly KeyType: KeyType)

  datatype KeyType = HASH | RANGE

  datatype KinesisDataStreamDestination = KinesisDataStreamDestination(nameonly StreamArn: Option<StreamArn> := Option.None, nameonly DestinationStatus: Option<DestinationStatus> := Option.None, nameonly DestinationStatusDescription: Option<String> := Option.None, nameonly ApproximateCreationDateTimePrecision: Option<ApproximateCreationDateTimePrecision> := Option.None)

  type KinesisDataStreamDestinations = seq<KinesisDataStreamDestination>

  datatype KinesisStreamingDestinationInput = KinesisStreamingDestinationInput(nameonly TableName: TableArn, nameonly StreamArn: StreamArn, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  datatype KinesisStreamingDestinationOutput = KinesisStreamingDestinationOutput(nameonly TableName: Option<TableName> := Option.None, nameonly StreamArn: Option<StreamArn> := Option.None, nameonly DestinationStatus: Option<DestinationStatus> := Option.None, nameonly EnableKinesisStreamingConfiguration: Option<EnableKinesisStreamingConfiguration> := Option.None)

  type KMSMasterKeyArn = string

  type KMSMasterKeyId = string

  type ListAttributeValue = seq<AttributeValue>

  datatype ListBackupsInput = ListBackupsInput(nameonly TableName: Option<TableArn> := Option.None, nameonly Limit: Option<BackupsInputLimit> := Option.None, nameonly TimeRangeLowerBound: Option<string> := Option.None, nameonly TimeRangeUpperBound: Option<string> := Option.None, nameonly ExclusiveStartBackupArn: Option<BackupArn> := Option.None, nameonly BackupType: Option<BackupTypeFilter> := Option.None)

  datatype ListBackupsOutput = ListBackupsOutput(nameonly BackupSummaries: Option<BackupSummaries> := Option.None, nameonly LastEvaluatedBackupArn: Option<BackupArn> := Option.None)

  datatype ListContributorInsightsInput = ListContributorInsightsInput(nameonly TableName: Option<TableArn> := Option.None, nameonly NextToken: Option<NextTokenString> := Option.None, nameonly MaxResults: Option<ListContributorInsightsLimit> := Option.None)

  type ListContributorInsightsLimit = x: int32
    | IsValid_ListContributorInsightsLimit(x)
    witness *

  datatype ListContributorInsightsOutput = ListContributorInsightsOutput(nameonly ContributorInsightsSummaries: Option<ContributorInsightsSummaries> := Option.None, nameonly NextToken: Option<NextTokenString> := Option.None)

  datatype ListExportsInput = ListExportsInput(nameonly TableArn: Option<TableArn> := Option.None, nameonly MaxResults: Option<ListExportsMaxLimit> := Option.None, nameonly NextToken: Option<ExportNextToken> := Option.None)

  type ListExportsMaxLimit = x: int32
    | IsValid_ListExportsMaxLimit(x)
    witness *

  datatype ListExportsOutput = ListExportsOutput(nameonly ExportSummaries: Option<ExportSummaries> := Option.None, nameonly NextToken: Option<ExportNextToken> := Option.None)

  datatype ListGlobalTablesInput = ListGlobalTablesInput(nameonly ExclusiveStartGlobalTableName: Option<TableName> := Option.None, nameonly Limit: Option<PositiveIntegerObject> := Option.None, nameonly RegionName: Option<RegionName> := Option.None)

  datatype ListGlobalTablesOutput = ListGlobalTablesOutput(nameonly GlobalTables: Option<GlobalTableList> := Option.None, nameonly LastEvaluatedGlobalTableName: Option<TableName> := Option.None)

  datatype ListImportsInput = ListImportsInput(nameonly TableArn: Option<TableArn> := Option.None, nameonly PageSize: Option<ListImportsMaxLimit> := Option.None, nameonly NextToken: Option<ImportNextToken> := Option.None)

  type ListImportsMaxLimit = x: int32
    | IsValid_ListImportsMaxLimit(x)
    witness *

  datatype ListImportsOutput = ListImportsOutput(nameonly ImportSummaryList: Option<ImportSummaryList> := Option.None, nameonly NextToken: Option<ImportNextToken> := Option.None)

  datatype ListTablesInput = ListTablesInput(nameonly ExclusiveStartTableName: Option<TableName> := Option.None, nameonly Limit: Option<ListTablesInputLimit> := Option.None)

  type ListTablesInputLimit = x: int32
    | IsValid_ListTablesInputLimit(x)
    witness *

  datatype ListTablesOutput = ListTablesOutput(nameonly TableNames: Option<TableNameList> := Option.None, nameonly LastEvaluatedTableName: Option<TableName> := Option.None)

  datatype ListTagsOfResourceInput = ListTagsOfResourceInput(nameonly ResourceArn: ResourceArnString, nameonly NextToken: Option<NextTokenString> := Option.None)

  datatype ListTagsOfResourceOutput = ListTagsOfResourceOutput(nameonly Tags: Option<TagList> := Option.None, nameonly NextToken: Option<NextTokenString> := Option.None)

  datatype LocalSecondaryIndex = LocalSecondaryIndex(nameonly IndexName: IndexName, nameonly KeySchema: KeySchema, nameonly Projection: Projection)

  datatype LocalSecondaryIndexDescription = LocalSecondaryIndexDescription(nameonly IndexName: Option<IndexName> := Option.None, nameonly KeySchema: Option<KeySchema> := Option.None, nameonly Projection: Option<Projection> := Option.None, nameonly IndexSizeBytes: Option<LongObject> := Option.None, nameonly ItemCount: Option<LongObject> := Option.None, nameonly IndexArn: Option<String> := Option.None)

  type LocalSecondaryIndexDescriptionList = seq<LocalSecondaryIndexDescription>

  type LocalSecondaryIndexes = seq<LocalSecondaryIndexInfo>

  datatype LocalSecondaryIndexInfo = LocalSecondaryIndexInfo(nameonly IndexName: Option<IndexName> := Option.None, nameonly KeySchema: Option<KeySchema> := Option.None, nameonly Projection: Option<Projection> := Option.None)

  type LocalSecondaryIndexList = seq<LocalSecondaryIndex>

  type Long = int64

  type LongObject = int64

  type MapAttributeValue = map<AttributeName, AttributeValue>

  type NextTokenString = string

  type NonKeyAttributeName = x: string
    | IsValid_NonKeyAttributeName(x)
    witness *

  type NonKeyAttributeNameList = x: seq<NonKeyAttributeName>
    | IsValid_NonKeyAttributeNameList(x)
    witness *

  type NonNegativeLongObject = x: int64
    | IsValid_NonNegativeLongObject(x)
    witness *

  type NullAttributeValue = bool

  type NumberAttributeValue = string

  type NumberSetAttributeValue = seq<NumberAttributeValue>

  datatype OnDemandThroughput = OnDemandThroughput(nameonly MaxReadRequestUnits: Option<LongObject> := Option.None, nameonly MaxWriteRequestUnits: Option<LongObject> := Option.None)

  datatype OnDemandThroughputOverride = OnDemandThroughputOverride(nameonly MaxReadRequestUnits: Option<LongObject> := Option.None)

  datatype ParameterizedStatement = ParameterizedStatement(nameonly Statement: PartiQLStatement, nameonly Parameters: Option<PreparedStatementParameters> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  type ParameterizedStatements = x: seq<ParameterizedStatement>
    | IsValid_ParameterizedStatements(x)
    witness *

  type PartiQLBatchRequest = x: seq<BatchStatementRequest>
    | IsValid_PartiQLBatchRequest(x)
    witness *

  type PartiQLBatchResponse = seq<BatchStatementResponse>

  type PartiQLNextToken = x: string
    | IsValid_PartiQLNextToken(x)
    witness *

  type PartiQLStatement = x: string
    | IsValid_PartiQLStatement(x)
    witness *

  datatype PointInTimeRecoveryDescription = PointInTimeRecoveryDescription(nameonly PointInTimeRecoveryStatus: Option<PointInTimeRecoveryStatus> := Option.None, nameonly EarliestRestorableDateTime: Option<string> := Option.None, nameonly LatestRestorableDateTime: Option<string> := Option.None)

  datatype PointInTimeRecoverySpecification = PointInTimeRecoverySpecification(nameonly PointInTimeRecoveryEnabled: BooleanObject)

  datatype PointInTimeRecoveryStatus = ENABLED | DISABLED

  type PolicyRevisionId = x: string
    | IsValid_PolicyRevisionId(x)
    witness *

  type PositiveIntegerObject = x: int32
    | IsValid_PositiveIntegerObject(x)
    witness *

  type PositiveLongObject = x: int64
    | IsValid_PositiveLongObject(x)
    witness *

  type PreparedStatementParameters = x: seq<AttributeValue>
    | IsValid_PreparedStatementParameters(x)
    witness *

  type ProcessedItemCount = x: int64
    | IsValid_ProcessedItemCount(x)
    witness *

  datatype Projection = Projection(nameonly ProjectionType: Option<ProjectionType> := Option.None, nameonly NonKeyAttributes: Option<NonKeyAttributeNameList> := Option.None)

  type ProjectionExpression = string

  datatype ProjectionType = ALL | KEYS_ONLY | INCLUDE

  datatype ProvisionedThroughput = ProvisionedThroughput(nameonly ReadCapacityUnits: PositiveLongObject, nameonly WriteCapacityUnits: PositiveLongObject)

  datatype ProvisionedThroughputDescription = ProvisionedThroughputDescription(nameonly LastIncreaseDateTime: Option<string> := Option.None, nameonly LastDecreaseDateTime: Option<string> := Option.None, nameonly NumberOfDecreasesToday: Option<PositiveLongObject> := Option.None, nameonly ReadCapacityUnits: Option<NonNegativeLongObject> := Option.None, nameonly WriteCapacityUnits: Option<NonNegativeLongObject> := Option.None)

  datatype ProvisionedThroughputOverride = ProvisionedThroughputOverride(nameonly ReadCapacityUnits: Option<PositiveLongObject> := Option.None)

  datatype Put = Put(nameonly Item: PutItemInputAttributeMap, nameonly TableName: TableArn, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype PutItemInput = PutItemInput(nameonly TableName: TableArn, nameonly Item: PutItemInputAttributeMap, nameonly Expected: Option<ExpectedAttributeMap> := Option.None, nameonly ReturnValues: Option<ReturnValue> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ReturnItemCollectionMetrics: Option<ReturnItemCollectionMetrics> := Option.None, nameonly ConditionalOperator: Option<ConditionalOperator> := Option.None, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  type PutItemInputAttributeMap = map<AttributeName, AttributeValue>

  datatype PutItemOutput = PutItemOutput(nameonly Attributes: Option<AttributeMap> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None, nameonly ItemCollectionMetrics: Option<ItemCollectionMetrics> := Option.None)

  datatype PutRequest = PutRequest(nameonly Item: PutItemInputAttributeMap)

  datatype PutResourcePolicyInput = PutResourcePolicyInput(nameonly ResourceArn: ResourceArnString, nameonly Policy: ResourcePolicy, nameonly ExpectedRevisionId: Option<PolicyRevisionId> := Option.None, nameonly ConfirmRemoveSelfResourceAccess: Option<ConfirmRemoveSelfResourceAccess> := Option.None)

  datatype PutResourcePolicyOutput = PutResourcePolicyOutput(nameonly RevisionId: Option<PolicyRevisionId> := Option.None)

  datatype QueryInput = QueryInput(nameonly TableName: TableArn, nameonly IndexName: Option<IndexName> := Option.None, nameonly Select: Option<Select> := Option.None, nameonly AttributesToGet: Option<AttributeNameList> := Option.None, nameonly Limit: Option<PositiveIntegerObject> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None, nameonly KeyConditions: Option<KeyConditions> := Option.None, nameonly QueryFilter: Option<FilterConditionMap> := Option.None, nameonly ConditionalOperator: Option<ConditionalOperator> := Option.None, nameonly ScanIndexForward: Option<BooleanObject> := Option.None, nameonly ExclusiveStartKey: Option<Key> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ProjectionExpression: Option<ProjectionExpression> := Option.None, nameonly FilterExpression: Option<ConditionExpression> := Option.None, nameonly KeyConditionExpression: Option<KeyExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None)

  datatype QueryOutput = QueryOutput(nameonly Items: Option<ItemList> := Option.None, nameonly Count: Option<Integer> := Option.None, nameonly ScannedCount: Option<Integer> := Option.None, nameonly LastEvaluatedKey: Option<Key> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None)

  type RegionName = string

  datatype Replica = Replica(nameonly RegionName: Option<RegionName> := Option.None)

  datatype ReplicaAutoScalingDescription = ReplicaAutoScalingDescription(nameonly RegionName: Option<RegionName> := Option.None, nameonly GlobalSecondaryIndexes: Option<ReplicaGlobalSecondaryIndexAutoScalingDescriptionList> := Option.None, nameonly ReplicaProvisionedReadCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ReplicaProvisionedWriteCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ReplicaStatus: Option<ReplicaStatus> := Option.None)

  type ReplicaAutoScalingDescriptionList = seq<ReplicaAutoScalingDescription>

  datatype ReplicaAutoScalingUpdate = ReplicaAutoScalingUpdate(nameonly RegionName: RegionName, nameonly ReplicaGlobalSecondaryIndexUpdates: Option<ReplicaGlobalSecondaryIndexAutoScalingUpdateList> := Option.None, nameonly ReplicaProvisionedReadCapacityAutoScalingUpdate: Option<AutoScalingSettingsUpdate> := Option.None)

  type ReplicaAutoScalingUpdateList = x: seq<ReplicaAutoScalingUpdate>
    | IsValid_ReplicaAutoScalingUpdateList(x)
    witness *

  datatype ReplicaDescription = ReplicaDescription(nameonly RegionName: Option<RegionName> := Option.None, nameonly ReplicaStatus: Option<ReplicaStatus> := Option.None, nameonly ReplicaStatusDescription: Option<ReplicaStatusDescription> := Option.None, nameonly ReplicaStatusPercentProgress: Option<ReplicaStatusPercentProgress> := Option.None, nameonly KMSMasterKeyId: Option<KMSMasterKeyId> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughputOverride> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughputOverride> := Option.None, nameonly GlobalSecondaryIndexes: Option<ReplicaGlobalSecondaryIndexDescriptionList> := Option.None, nameonly ReplicaInaccessibleDateTime: Option<string> := Option.None, nameonly ReplicaTableClassSummary: Option<TableClassSummary> := Option.None)

  type ReplicaDescriptionList = seq<ReplicaDescription>

  datatype ReplicaGlobalSecondaryIndex = ReplicaGlobalSecondaryIndex(nameonly IndexName: IndexName, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughputOverride> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughputOverride> := Option.None)

  datatype ReplicaGlobalSecondaryIndexAutoScalingDescription = ReplicaGlobalSecondaryIndexAutoScalingDescription(nameonly IndexName: Option<IndexName> := Option.None, nameonly IndexStatus: Option<IndexStatus> := Option.None, nameonly ProvisionedReadCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ProvisionedWriteCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None)

  type ReplicaGlobalSecondaryIndexAutoScalingDescriptionList = seq<ReplicaGlobalSecondaryIndexAutoScalingDescription>

  datatype ReplicaGlobalSecondaryIndexAutoScalingUpdate = ReplicaGlobalSecondaryIndexAutoScalingUpdate(nameonly IndexName: Option<IndexName> := Option.None, nameonly ProvisionedReadCapacityAutoScalingUpdate: Option<AutoScalingSettingsUpdate> := Option.None)

  type ReplicaGlobalSecondaryIndexAutoScalingUpdateList = seq<ReplicaGlobalSecondaryIndexAutoScalingUpdate>

  datatype ReplicaGlobalSecondaryIndexDescription = ReplicaGlobalSecondaryIndexDescription(nameonly IndexName: Option<IndexName> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughputOverride> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughputOverride> := Option.None)

  type ReplicaGlobalSecondaryIndexDescriptionList = seq<ReplicaGlobalSecondaryIndexDescription>

  type ReplicaGlobalSecondaryIndexList = x: seq<ReplicaGlobalSecondaryIndex>
    | IsValid_ReplicaGlobalSecondaryIndexList(x)
    witness *

  datatype ReplicaGlobalSecondaryIndexSettingsDescription = ReplicaGlobalSecondaryIndexSettingsDescription(nameonly IndexName: IndexName, nameonly IndexStatus: Option<IndexStatus> := Option.None, nameonly ProvisionedReadCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly ProvisionedReadCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ProvisionedWriteCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly ProvisionedWriteCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None)

  type ReplicaGlobalSecondaryIndexSettingsDescriptionList = seq<ReplicaGlobalSecondaryIndexSettingsDescription>

  datatype ReplicaGlobalSecondaryIndexSettingsUpdate = ReplicaGlobalSecondaryIndexSettingsUpdate(nameonly IndexName: IndexName, nameonly ProvisionedReadCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly ProvisionedReadCapacityAutoScalingSettingsUpdate: Option<AutoScalingSettingsUpdate> := Option.None)

  type ReplicaGlobalSecondaryIndexSettingsUpdateList = x: seq<ReplicaGlobalSecondaryIndexSettingsUpdate>
    | IsValid_ReplicaGlobalSecondaryIndexSettingsUpdateList(x)
    witness *

  type ReplicaList = seq<Replica>

  datatype ReplicaSettingsDescription = ReplicaSettingsDescription(nameonly RegionName: RegionName, nameonly ReplicaStatus: Option<ReplicaStatus> := Option.None, nameonly ReplicaBillingModeSummary: Option<BillingModeSummary> := Option.None, nameonly ReplicaProvisionedReadCapacityUnits: Option<NonNegativeLongObject> := Option.None, nameonly ReplicaProvisionedReadCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ReplicaProvisionedWriteCapacityUnits: Option<NonNegativeLongObject> := Option.None, nameonly ReplicaProvisionedWriteCapacityAutoScalingSettings: Option<AutoScalingSettingsDescription> := Option.None, nameonly ReplicaGlobalSecondaryIndexSettings: Option<ReplicaGlobalSecondaryIndexSettingsDescriptionList> := Option.None, nameonly ReplicaTableClassSummary: Option<TableClassSummary> := Option.None)

  type ReplicaSettingsDescriptionList = seq<ReplicaSettingsDescription>

  datatype ReplicaSettingsUpdate = ReplicaSettingsUpdate(nameonly RegionName: RegionName, nameonly ReplicaProvisionedReadCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: Option<AutoScalingSettingsUpdate> := Option.None, nameonly ReplicaGlobalSecondaryIndexSettingsUpdate: Option<ReplicaGlobalSecondaryIndexSettingsUpdateList> := Option.None, nameonly ReplicaTableClass: Option<TableClass> := Option.None)

  type ReplicaSettingsUpdateList = x: seq<ReplicaSettingsUpdate>
    | IsValid_ReplicaSettingsUpdateList(x)
    witness *

  datatype ReplicaStatus = CREATING | CREATION_FAILED | UPDATING | DELETING | ACTIVE | REGION_DISABLED | INACCESSIBLE_ENCRYPTION_CREDENTIALS

  type ReplicaStatusDescription = string

  type ReplicaStatusPercentProgress = string

  datatype ReplicationGroupUpdate = ReplicationGroupUpdate(nameonly Create: Option<CreateReplicationGroupMemberAction> := Option.None, nameonly Update: Option<UpdateReplicationGroupMemberAction> := Option.None, nameonly Delete: Option<DeleteReplicationGroupMemberAction> := Option.None)

  type ReplicationGroupUpdateList = x: seq<ReplicationGroupUpdate>
    | IsValid_ReplicationGroupUpdateList(x)
    witness *

  datatype ReplicaUpdate = ReplicaUpdate(nameonly Create: Option<CreateReplicaAction> := Option.None, nameonly Delete: Option<DeleteReplicaAction> := Option.None)

  type ReplicaUpdateList = seq<ReplicaUpdate>

  type ResourceArnString = x: string
    | IsValid_ResourceArnString(x)
    witness *

  type ResourcePolicy = string

  type RestoreInProgress = bool

  datatype RestoreSummary = RestoreSummary(nameonly SourceBackupArn: Option<BackupArn> := Option.None, nameonly SourceTableArn: Option<TableArn> := Option.None, nameonly RestoreDateTime: string, nameonly RestoreInProgress: RestoreInProgress)

  datatype RestoreTableFromBackupInput = RestoreTableFromBackupInput(nameonly TargetTableName: TableName, nameonly BackupArn: BackupArn, nameonly BillingModeOverride: Option<BillingMode> := Option.None, nameonly GlobalSecondaryIndexOverride: Option<GlobalSecondaryIndexList> := Option.None, nameonly LocalSecondaryIndexOverride: Option<LocalSecondaryIndexList> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughput> := Option.None, nameonly SSESpecificationOverride: Option<SSESpecification> := Option.None)

  datatype RestoreTableFromBackupOutput = RestoreTableFromBackupOutput(nameonly TableDescription: Option<TableDescription> := Option.None)

  datatype RestoreTableToPointInTimeInput = RestoreTableToPointInTimeInput(nameonly SourceTableArn: Option<TableArn> := Option.None, nameonly SourceTableName: Option<TableName> := Option.None, nameonly TargetTableName: TableName, nameonly UseLatestRestorableTime: Option<BooleanObject> := Option.None, nameonly RestoreDateTime: Option<string> := Option.None, nameonly BillingModeOverride: Option<BillingMode> := Option.None, nameonly GlobalSecondaryIndexOverride: Option<GlobalSecondaryIndexList> := Option.None, nameonly LocalSecondaryIndexOverride: Option<LocalSecondaryIndexList> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughput> := Option.None, nameonly SSESpecificationOverride: Option<SSESpecification> := Option.None)

  datatype RestoreTableToPointInTimeOutput = RestoreTableToPointInTimeOutput(nameonly TableDescription: Option<TableDescription> := Option.None)

  datatype ReturnConsumedCapacity = INDEXES | TOTAL | NONE

  datatype ReturnItemCollectionMetrics = SIZE | NONE

  datatype ReturnValue = NONE | ALL_OLD | UPDATED_OLD | ALL_NEW | UPDATED_NEW

  datatype ReturnValuesOnConditionCheckFailure = ALL_OLD | NONE

  type S3Bucket = x: string
    | IsValid_S3Bucket(x)
    witness *

  type S3BucketOwner = string

  datatype S3BucketSource = S3BucketSource(nameonly S3BucketOwner: Option<S3BucketOwner> := Option.None, nameonly S3Bucket: S3Bucket, nameonly S3KeyPrefix: Option<S3Prefix> := Option.None)

  type S3Prefix = x: string
    | IsValid_S3Prefix(x)
    witness *

  datatype S3SseAlgorithm = AES256 | KMS

  type S3SseKmsKeyId = x: string
    | IsValid_S3SseKmsKeyId(x)
    witness *

  datatype ScalarAttributeType = S | N | B

  datatype ScanInput = ScanInput(nameonly TableName: TableArn, nameonly IndexName: Option<IndexName> := Option.None, nameonly AttributesToGet: Option<AttributeNameList> := Option.None, nameonly Limit: Option<PositiveIntegerObject> := Option.None, nameonly Select: Option<Select> := Option.None, nameonly ScanFilter: Option<FilterConditionMap> := Option.None, nameonly ConditionalOperator: Option<ConditionalOperator> := Option.None, nameonly ExclusiveStartKey: Option<Key> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly TotalSegments: Option<ScanTotalSegments> := Option.None, nameonly Segment: Option<ScanSegment> := Option.None, nameonly ProjectionExpression: Option<ProjectionExpression> := Option.None, nameonly FilterExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ConsistentRead: Option<ConsistentRead> := Option.None)

  datatype ScanOutput = ScanOutput(nameonly Items: Option<ItemList> := Option.None, nameonly Count: Option<Integer> := Option.None, nameonly ScannedCount: Option<Integer> := Option.None, nameonly LastEvaluatedKey: Option<Key> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None)

  type ScanSegment = x: int32
    | IsValid_ScanSegment(x)
    witness *

  type ScanTotalSegments = x: int32
    | IsValid_ScanTotalSegments(x)
    witness *

  type SecondaryIndexesCapacityMap = map<IndexName, Capacity>

  datatype Select = ALL_ATTRIBUTES | ALL_PROJECTED_ATTRIBUTES | SPECIFIC_ATTRIBUTES | COUNT

  datatype SourceTableDetails = SourceTableDetails(nameonly TableName: TableName, nameonly TableId: TableId, nameonly TableArn: Option<TableArn> := Option.None, nameonly TableSizeBytes: Option<LongObject> := Option.None, nameonly KeySchema: KeySchema, nameonly TableCreationDateTime: string, nameonly ProvisionedThroughput: ProvisionedThroughput, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None, nameonly ItemCount: Option<ItemCount> := Option.None, nameonly BillingMode: Option<BillingMode> := Option.None)

  datatype SourceTableFeatureDetails = SourceTableFeatureDetails(nameonly LocalSecondaryIndexes: Option<LocalSecondaryIndexes> := Option.None, nameonly GlobalSecondaryIndexes: Option<GlobalSecondaryIndexes> := Option.None, nameonly StreamDescription: Option<StreamSpecification> := Option.None, nameonly TimeToLiveDescription: Option<TimeToLiveDescription> := Option.None, nameonly SSEDescription: Option<SSEDescription> := Option.None)

  datatype SSEDescription = SSEDescription(nameonly Status: Option<SSEStatus> := Option.None, nameonly SSEType: Option<SSEType> := Option.None, nameonly KMSMasterKeyArn: Option<KMSMasterKeyArn> := Option.None, nameonly InaccessibleEncryptionDateTime: Option<string> := Option.None)

  type SSEEnabled = bool

  datatype SSESpecification = SSESpecification(nameonly Enabled: Option<SSEEnabled> := Option.None, nameonly SSEType: Option<SSEType> := Option.None, nameonly KMSMasterKeyId: Option<KMSMasterKeyId> := Option.None)

  datatype SSEStatus = ENABLING | ENABLED | DISABLING | DISABLED | UPDATING

  datatype SSEType = AES256 | KMS

  type StreamArn = x: string
    | IsValid_StreamArn(x)
    witness *

  type StreamEnabled = bool

  datatype StreamSpecification = StreamSpecification(nameonly StreamEnabled: StreamEnabled, nameonly StreamViewType: Option<StreamViewType> := Option.None)

  datatype StreamViewType = NEW_IMAGE | OLD_IMAGE | NEW_AND_OLD_IMAGES | KEYS_ONLY

  type String = string

  type StringAttributeValue = string

  type StringSetAttributeValue = seq<StringAttributeValue>

  type TableArn = x: string
    | IsValid_TableArn(x)
    witness *

  datatype TableAutoScalingDescription = TableAutoScalingDescription(nameonly TableName: Option<TableName> := Option.None, nameonly TableStatus: Option<TableStatus> := Option.None, nameonly Replicas: Option<ReplicaAutoScalingDescriptionList> := Option.None)

  datatype TableClass = STANDARD | STANDARD_INFREQUENT_ACCESS

  datatype TableClassSummary = TableClassSummary(nameonly TableClass: Option<TableClass> := Option.None, nameonly LastUpdateDateTime: Option<string> := Option.None)

  datatype TableCreationParameters = TableCreationParameters(nameonly TableName: TableName, nameonly AttributeDefinitions: AttributeDefinitions, nameonly KeySchema: KeySchema, nameonly BillingMode: Option<BillingMode> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None, nameonly SSESpecification: Option<SSESpecification> := Option.None, nameonly GlobalSecondaryIndexes: Option<GlobalSecondaryIndexList> := Option.None)

  datatype TableDescription = TableDescription(nameonly AttributeDefinitions: Option<AttributeDefinitions> := Option.None, nameonly TableName: Option<TableName> := Option.None, nameonly KeySchema: Option<KeySchema> := Option.None, nameonly TableStatus: Option<TableStatus> := Option.None, nameonly CreationDateTime: Option<string> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughputDescription> := Option.None, nameonly TableSizeBytes: Option<LongObject> := Option.None, nameonly ItemCount: Option<LongObject> := Option.None, nameonly TableArn: Option<String> := Option.None, nameonly TableId: Option<TableId> := Option.None, nameonly BillingModeSummary: Option<BillingModeSummary> := Option.None, nameonly LocalSecondaryIndexes: Option<LocalSecondaryIndexDescriptionList> := Option.None, nameonly GlobalSecondaryIndexes: Option<GlobalSecondaryIndexDescriptionList> := Option.None, nameonly StreamSpecification: Option<StreamSpecification> := Option.None, nameonly LatestStreamLabel: Option<String> := Option.None, nameonly LatestStreamArn: Option<StreamArn> := Option.None, nameonly GlobalTableVersion: Option<String> := Option.None, nameonly Replicas: Option<ReplicaDescriptionList> := Option.None, nameonly RestoreSummary: Option<RestoreSummary> := Option.None, nameonly SSEDescription: Option<SSEDescription> := Option.None, nameonly ArchivalSummary: Option<ArchivalSummary> := Option.None, nameonly TableClassSummary: Option<TableClassSummary> := Option.None, nameonly DeletionProtectionEnabled: Option<DeletionProtectionEnabled> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  type TableId = string

  type TableName = x: string
    | IsValid_TableName(x)
    witness *

  type TableNameList = seq<TableName>

  datatype TableStatus = CREATING | UPDATING | DELETING | ACTIVE | INACCESSIBLE_ENCRYPTION_CREDENTIALS | ARCHIVING | ARCHIVED

  datatype Tag = Tag(nameonly Key: TagKeyString, nameonly Value: TagValueString)

  type TagKeyList = seq<TagKeyString>

  type TagKeyString = x: string
    | IsValid_TagKeyString(x)
    witness *

  type TagList = seq<Tag>

  datatype TagResourceInput = TagResourceInput(nameonly ResourceArn: ResourceArnString, nameonly Tags: TagList)

  type TagValueString = x: string
    | IsValid_TagValueString(x)
    witness *

  type TimeToLiveAttributeName = x: string
    | IsValid_TimeToLiveAttributeName(x)
    witness *

  datatype TimeToLiveDescription = TimeToLiveDescription(nameonly TimeToLiveStatus: Option<TimeToLiveStatus> := Option.None, nameonly AttributeName: Option<TimeToLiveAttributeName> := Option.None)

  type TimeToLiveEnabled = bool

  datatype TimeToLiveSpecification = TimeToLiveSpecification(nameonly Enabled: TimeToLiveEnabled, nameonly AttributeName: TimeToLiveAttributeName)

  datatype TimeToLiveStatus = ENABLING | DISABLING | ENABLED | DISABLED

  datatype TransactGetItem = TransactGetItem(nameonly Get: Get)

  type TransactGetItemList = x: seq<TransactGetItem>
    | IsValid_TransactGetItemList(x)
    witness *

  datatype TransactGetItemsInput = TransactGetItemsInput(nameonly TransactItems: TransactGetItemList, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None)

  datatype TransactGetItemsOutput = TransactGetItemsOutput(nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None, nameonly Responses: Option<ItemResponseList> := Option.None)

  datatype TransactWriteItem = TransactWriteItem(nameonly ConditionCheck: Option<ConditionCheck> := Option.None, nameonly Put: Option<Put> := Option.None, nameonly Delete: Option<Delete> := Option.None, nameonly Update: Option<Update> := Option.None)

  type TransactWriteItemList = x: seq<TransactWriteItem>
    | IsValid_TransactWriteItemList(x)
    witness *

  datatype TransactWriteItemsInput = TransactWriteItemsInput(nameonly TransactItems: TransactWriteItemList, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ReturnItemCollectionMetrics: Option<ReturnItemCollectionMetrics> := Option.None, nameonly ClientRequestToken: Option<ClientRequestToken> := Option.None)

  datatype TransactWriteItemsOutput = TransactWriteItemsOutput(nameonly ConsumedCapacity: Option<ConsumedCapacityMultiple> := Option.None, nameonly ItemCollectionMetrics: Option<ItemCollectionMetricsPerTable> := Option.None)

  datatype UntagResourceInput = UntagResourceInput(nameonly ResourceArn: ResourceArnString, nameonly TagKeys: TagKeyList)

  datatype Update = Update(nameonly Key: Key, nameonly UpdateExpression: UpdateExpression, nameonly TableName: TableArn, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype UpdateContinuousBackupsInput = UpdateContinuousBackupsInput(nameonly TableName: TableArn, nameonly PointInTimeRecoverySpecification: PointInTimeRecoverySpecification)

  datatype UpdateContinuousBackupsOutput = UpdateContinuousBackupsOutput(nameonly ContinuousBackupsDescription: Option<ContinuousBackupsDescription> := Option.None)

  datatype UpdateContributorInsightsInput = UpdateContributorInsightsInput(nameonly TableName: TableArn, nameonly IndexName: Option<IndexName> := Option.None, nameonly ContributorInsightsAction: ContributorInsightsAction)

  datatype UpdateContributorInsightsOutput = UpdateContributorInsightsOutput(nameonly TableName: Option<TableName> := Option.None, nameonly IndexName: Option<IndexName> := Option.None, nameonly ContributorInsightsStatus: Option<ContributorInsightsStatus> := Option.None)

  type UpdateExpression = string

  datatype UpdateGlobalSecondaryIndexAction = UpdateGlobalSecondaryIndexAction(nameonly IndexName: IndexName, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  datatype UpdateGlobalTableInput = UpdateGlobalTableInput(nameonly GlobalTableName: TableName, nameonly ReplicaUpdates: ReplicaUpdateList)

  datatype UpdateGlobalTableOutput = UpdateGlobalTableOutput(nameonly GlobalTableDescription: Option<GlobalTableDescription> := Option.None)

  datatype UpdateGlobalTableSettingsInput = UpdateGlobalTableSettingsInput(nameonly GlobalTableName: TableName, nameonly GlobalTableBillingMode: Option<BillingMode> := Option.None, nameonly GlobalTableProvisionedWriteCapacityUnits: Option<PositiveLongObject> := Option.None, nameonly GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: Option<AutoScalingSettingsUpdate> := Option.None, nameonly GlobalTableGlobalSecondaryIndexSettingsUpdate: Option<GlobalTableGlobalSecondaryIndexSettingsUpdateList> := Option.None, nameonly ReplicaSettingsUpdate: Option<ReplicaSettingsUpdateList> := Option.None)

  datatype UpdateGlobalTableSettingsOutput = UpdateGlobalTableSettingsOutput(nameonly GlobalTableName: Option<TableName> := Option.None, nameonly ReplicaSettings: Option<ReplicaSettingsDescriptionList> := Option.None)

  datatype UpdateItemInput = UpdateItemInput(nameonly TableName: TableArn, nameonly Key: Key, nameonly AttributeUpdates: Option<AttributeUpdates> := Option.None, nameonly Expected: Option<ExpectedAttributeMap> := Option.None, nameonly ConditionalOperator: Option<ConditionalOperator> := Option.None, nameonly ReturnValues: Option<ReturnValue> := Option.None, nameonly ReturnConsumedCapacity: Option<ReturnConsumedCapacity> := Option.None, nameonly ReturnItemCollectionMetrics: Option<ReturnItemCollectionMetrics> := Option.None, nameonly UpdateExpression: Option<UpdateExpression> := Option.None, nameonly ConditionExpression: Option<ConditionExpression> := Option.None, nameonly ExpressionAttributeNames: Option<ExpressionAttributeNameMap> := Option.None, nameonly ExpressionAttributeValues: Option<ExpressionAttributeValueMap> := Option.None, nameonly ReturnValuesOnConditionCheckFailure: Option<ReturnValuesOnConditionCheckFailure> := Option.None)

  datatype UpdateItemOutput = UpdateItemOutput(nameonly Attributes: Option<AttributeMap> := Option.None, nameonly ConsumedCapacity: Option<ConsumedCapacity> := Option.None, nameonly ItemCollectionMetrics: Option<ItemCollectionMetrics> := Option.None)

  datatype UpdateKinesisStreamingConfiguration = UpdateKinesisStreamingConfiguration(nameonly ApproximateCreationDateTimePrecision: Option<ApproximateCreationDateTimePrecision> := Option.None)

  datatype UpdateKinesisStreamingDestinationInput = UpdateKinesisStreamingDestinationInput(nameonly TableName: TableArn, nameonly StreamArn: StreamArn, nameonly UpdateKinesisStreamingConfiguration: Option<UpdateKinesisStreamingConfiguration> := Option.None)

  datatype UpdateKinesisStreamingDestinationOutput = UpdateKinesisStreamingDestinationOutput(nameonly TableName: Option<TableName> := Option.None, nameonly StreamArn: Option<StreamArn> := Option.None, nameonly DestinationStatus: Option<DestinationStatus> := Option.None, nameonly UpdateKinesisStreamingConfiguration: Option<UpdateKinesisStreamingConfiguration> := Option.None)

  datatype UpdateReplicationGroupMemberAction = UpdateReplicationGroupMemberAction(nameonly RegionName: RegionName, nameonly KMSMasterKeyId: Option<KMSMasterKeyId> := Option.None, nameonly ProvisionedThroughputOverride: Option<ProvisionedThroughputOverride> := Option.None, nameonly OnDemandThroughputOverride: Option<OnDemandThroughputOverride> := Option.None, nameonly GlobalSecondaryIndexes: Option<ReplicaGlobalSecondaryIndexList> := Option.None, nameonly TableClassOverride: Option<TableClass> := Option.None)

  datatype UpdateTableInput = UpdateTableInput(nameonly AttributeDefinitions: Option<AttributeDefinitions> := Option.None, nameonly TableName: TableArn, nameonly BillingMode: Option<BillingMode> := Option.None, nameonly ProvisionedThroughput: Option<ProvisionedThroughput> := Option.None, nameonly GlobalSecondaryIndexUpdates: Option<GlobalSecondaryIndexUpdateList> := Option.None, nameonly StreamSpecification: Option<StreamSpecification> := Option.None, nameonly SSESpecification: Option<SSESpecification> := Option.None, nameonly ReplicaUpdates: Option<ReplicationGroupUpdateList> := Option.None, nameonly TableClass: Option<TableClass> := Option.None, nameonly DeletionProtectionEnabled: Option<DeletionProtectionEnabled> := Option.None, nameonly OnDemandThroughput: Option<OnDemandThroughput> := Option.None)

  datatype UpdateTableOutput = UpdateTableOutput(nameonly TableDescription: Option<TableDescription> := Option.None)

  datatype UpdateTableReplicaAutoScalingInput = UpdateTableReplicaAutoScalingInput(nameonly GlobalSecondaryIndexUpdates: Option<GlobalSecondaryIndexAutoScalingUpdateList> := Option.None, nameonly TableName: TableArn, nameonly ProvisionedWriteCapacityAutoScalingUpdate: Option<AutoScalingSettingsUpdate> := Option.None, nameonly ReplicaUpdates: Option<ReplicaAutoScalingUpdateList> := Option.None)

  datatype UpdateTableReplicaAutoScalingOutput = UpdateTableReplicaAutoScalingOutput(nameonly TableAutoScalingDescription: Option<TableAutoScalingDescription> := Option.None)

  datatype UpdateTimeToLiveInput = UpdateTimeToLiveInput(nameonly TableName: TableArn, nameonly TimeToLiveSpecification: TimeToLiveSpecification)

  datatype UpdateTimeToLiveOutput = UpdateTimeToLiveOutput(nameonly TimeToLiveSpecification: Option<TimeToLiveSpecification> := Option.None)

  datatype WriteRequest = WriteRequest(nameonly PutRequest: Option<PutRequest> := Option.None, nameonly DeleteRequest: Option<DeleteRequest> := Option.None)

  type WriteRequests = x: seq<WriteRequest>
    | IsValid_WriteRequests(x)
    witness *

  datatype Error = BackupInUseException(nameonly message: Option<ErrorMessage> := Option.None) | BackupNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | ConditionalCheckFailedException(nameonly message: Option<ErrorMessage> := Option.None, nameonly Item: Option<AttributeMap> := Option.None) | ContinuousBackupsUnavailableException(nameonly message: Option<ErrorMessage> := Option.None) | DuplicateItemException(nameonly message: Option<ErrorMessage> := Option.None) | ExportConflictException(nameonly message: Option<ErrorMessage> := Option.None) | ExportNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | GlobalTableAlreadyExistsException(nameonly message: Option<ErrorMessage> := Option.None) | GlobalTableNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | IdempotentParameterMismatchException(nameonly Message: Option<ErrorMessage> := Option.None) | ImportConflictException(nameonly message: Option<ErrorMessage> := Option.None) | ImportNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | IndexNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | InternalServerError(nameonly message: Option<ErrorMessage> := Option.None) | InvalidEndpointException(nameonly Message: Option<String> := Option.None) | InvalidExportTimeException(nameonly message: Option<ErrorMessage> := Option.None) | InvalidRestoreTimeException(nameonly message: Option<ErrorMessage> := Option.None) | ItemCollectionSizeLimitExceededException(nameonly message: Option<ErrorMessage> := Option.None) | LimitExceededException(nameonly message: Option<ErrorMessage> := Option.None) | PointInTimeRecoveryUnavailableException(nameonly message: Option<ErrorMessage> := Option.None) | PolicyNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | ProvisionedThroughputExceededException(nameonly message: Option<ErrorMessage> := Option.None) | ReplicaAlreadyExistsException(nameonly message: Option<ErrorMessage> := Option.None) | ReplicaNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | RequestLimitExceeded(nameonly message: Option<ErrorMessage> := Option.None) | ResourceInUseException(nameonly message: Option<ErrorMessage> := Option.None) | ResourceNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | TableAlreadyExistsException(nameonly message: Option<ErrorMessage> := Option.None) | TableInUseException(nameonly message: Option<ErrorMessage> := Option.None) | TableNotFoundException(nameonly message: Option<ErrorMessage> := Option.None) | TransactionCanceledException(nameonly Message: Option<ErrorMessage> := Option.None, nameonly CancellationReasons: Option<CancellationReasonList> := Option.None) | TransactionConflictException(nameonly message: Option<ErrorMessage> := Option.None) | TransactionInProgressException(nameonly Message: Option<ErrorMessage> := Option.None) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractComAmazonawsDynamodbService {
  function method DefaultDynamoDBClientConfigType(): DynamoDBClientConfigType

  method {:extern} DynamoDBClient() returns (res: Result<IDynamoDBClient, Error>)
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies) && fresh(res.value.History) && res.value.ValidState()

  function method CreateSuccessOfClient(client: IDynamoDBClient): Result<IDynamoDBClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IDynamoDBClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = ComAmazonawsDynamodbTypes

  datatype DynamoDBClientConfigType = DynamoDBClientConfigType
}

abstract module AbstractComAmazonawsDynamodbOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate BatchExecuteStatementEnsuresPublicly(input: BatchExecuteStatementInput, output: Result<BatchExecuteStatementOutput, Error>)
    decreases input, output

  method BatchExecuteStatement(config: InternalConfig, input: BatchExecuteStatementInput) returns (output: Result<BatchExecuteStatementOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchExecuteStatementEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchGetItemEnsuresPublicly(input: BatchGetItemInput, output: Result<BatchGetItemOutput, Error>)
    decreases input, output

  method BatchGetItem(config: InternalConfig, input: BatchGetItemInput) returns (output: Result<BatchGetItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchGetItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate BatchWriteItemEnsuresPublicly(input: BatchWriteItemInput, output: Result<BatchWriteItemOutput, Error>)
    decreases input, output

  method BatchWriteItem(config: InternalConfig, input: BatchWriteItemInput) returns (output: Result<BatchWriteItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures BatchWriteItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateBackupEnsuresPublicly(input: CreateBackupInput, output: Result<CreateBackupOutput, Error>)
    decreases input, output

  method CreateBackup(config: InternalConfig, input: CreateBackupInput) returns (output: Result<CreateBackupOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateBackupEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateGlobalTableEnsuresPublicly(input: CreateGlobalTableInput, output: Result<CreateGlobalTableOutput, Error>)
    decreases input, output

  method CreateGlobalTable(config: InternalConfig, input: CreateGlobalTableInput) returns (output: Result<CreateGlobalTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateGlobalTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateTableEnsuresPublicly(input: CreateTableInput, output: Result<CreateTableOutput, Error>)
    decreases input, output

  method CreateTable(config: InternalConfig, input: CreateTableInput) returns (output: Result<CreateTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteBackupEnsuresPublicly(input: DeleteBackupInput, output: Result<DeleteBackupOutput, Error>)
    decreases input, output

  method DeleteBackup(config: InternalConfig, input: DeleteBackupInput) returns (output: Result<DeleteBackupOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteBackupEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteItemEnsuresPublicly(input: DeleteItemInput, output: Result<DeleteItemOutput, Error>)
    decreases input, output

  method DeleteItem(config: InternalConfig, input: DeleteItemInput) returns (output: Result<DeleteItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteResourcePolicyEnsuresPublicly(input: DeleteResourcePolicyInput, output: Result<DeleteResourcePolicyOutput, Error>)
    decreases input, output

  method DeleteResourcePolicy(config: InternalConfig, input: DeleteResourcePolicyInput) returns (output: Result<DeleteResourcePolicyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteResourcePolicyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DeleteTableEnsuresPublicly(input: DeleteTableInput, output: Result<DeleteTableOutput, Error>)
    decreases input, output

  method DeleteTable(config: InternalConfig, input: DeleteTableInput) returns (output: Result<DeleteTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DeleteTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeBackupEnsuresPublicly(input: DescribeBackupInput, output: Result<DescribeBackupOutput, Error>)
    decreases input, output

  method DescribeBackup(config: InternalConfig, input: DescribeBackupInput) returns (output: Result<DescribeBackupOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeBackupEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeContinuousBackupsEnsuresPublicly(input: DescribeContinuousBackupsInput, output: Result<DescribeContinuousBackupsOutput, Error>)
    decreases input, output

  method DescribeContinuousBackups(config: InternalConfig, input: DescribeContinuousBackupsInput) returns (output: Result<DescribeContinuousBackupsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeContinuousBackupsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeContributorInsightsEnsuresPublicly(input: DescribeContributorInsightsInput, output: Result<DescribeContributorInsightsOutput, Error>)
    decreases input, output

  method DescribeContributorInsights(config: InternalConfig, input: DescribeContributorInsightsInput) returns (output: Result<DescribeContributorInsightsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeContributorInsightsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeEndpointsEnsuresPublicly(input: DescribeEndpointsRequest, output: Result<DescribeEndpointsResponse, Error>)
    decreases input, output

  method DescribeEndpoints(config: InternalConfig, input: DescribeEndpointsRequest) returns (output: Result<DescribeEndpointsResponse, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeEndpointsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeExportEnsuresPublicly(input: DescribeExportInput, output: Result<DescribeExportOutput, Error>)
    decreases input, output

  method DescribeExport(config: InternalConfig, input: DescribeExportInput) returns (output: Result<DescribeExportOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeExportEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeGlobalTableEnsuresPublicly(input: DescribeGlobalTableInput, output: Result<DescribeGlobalTableOutput, Error>)
    decreases input, output

  method DescribeGlobalTable(config: InternalConfig, input: DescribeGlobalTableInput) returns (output: Result<DescribeGlobalTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeGlobalTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeGlobalTableSettingsEnsuresPublicly(input: DescribeGlobalTableSettingsInput, output: Result<DescribeGlobalTableSettingsOutput, Error>)
    decreases input, output

  method DescribeGlobalTableSettings(config: InternalConfig, input: DescribeGlobalTableSettingsInput) returns (output: Result<DescribeGlobalTableSettingsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeGlobalTableSettingsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeImportEnsuresPublicly(input: DescribeImportInput, output: Result<DescribeImportOutput, Error>)
    decreases input, output

  method DescribeImport(config: InternalConfig, input: DescribeImportInput) returns (output: Result<DescribeImportOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeImportEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeKinesisStreamingDestinationEnsuresPublicly(input: DescribeKinesisStreamingDestinationInput, output: Result<DescribeKinesisStreamingDestinationOutput, Error>)
    decreases input, output

  method DescribeKinesisStreamingDestination(config: InternalConfig, input: DescribeKinesisStreamingDestinationInput) returns (output: Result<DescribeKinesisStreamingDestinationOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeKinesisStreamingDestinationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeLimitsEnsuresPublicly(input: DescribeLimitsInput, output: Result<DescribeLimitsOutput, Error>)
    decreases input, output

  method DescribeLimits(config: InternalConfig, input: DescribeLimitsInput) returns (output: Result<DescribeLimitsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeLimitsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeTableEnsuresPublicly(input: DescribeTableInput, output: Result<DescribeTableOutput, Error>)
    decreases input, output

  method DescribeTable(config: InternalConfig, input: DescribeTableInput) returns (output: Result<DescribeTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeTableReplicaAutoScalingEnsuresPublicly(input: DescribeTableReplicaAutoScalingInput, output: Result<DescribeTableReplicaAutoScalingOutput, Error>)
    decreases input, output

  method DescribeTableReplicaAutoScaling(config: InternalConfig, input: DescribeTableReplicaAutoScalingInput) returns (output: Result<DescribeTableReplicaAutoScalingOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeTableReplicaAutoScalingEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DescribeTimeToLiveEnsuresPublicly(input: DescribeTimeToLiveInput, output: Result<DescribeTimeToLiveOutput, Error>)
    decreases input, output

  method DescribeTimeToLive(config: InternalConfig, input: DescribeTimeToLiveInput) returns (output: Result<DescribeTimeToLiveOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DescribeTimeToLiveEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate DisableKinesisStreamingDestinationEnsuresPublicly(input: DisableKinesisStreamingDestinationInput, output: Result<DisableKinesisStreamingDestinationOutput, Error>)
    decreases input, output

  method DisableKinesisStreamingDestination(config: InternalConfig, input: DisableKinesisStreamingDestinationInput) returns (output: Result<DisableKinesisStreamingDestinationOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures DisableKinesisStreamingDestinationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate EnableKinesisStreamingDestinationEnsuresPublicly(input: EnableKinesisStreamingDestinationInput, output: Result<EnableKinesisStreamingDestinationOutput, Error>)
    decreases input, output

  method EnableKinesisStreamingDestination(config: InternalConfig, input: EnableKinesisStreamingDestinationInput) returns (output: Result<EnableKinesisStreamingDestinationOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures EnableKinesisStreamingDestinationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteStatementEnsuresPublicly(input: ExecuteStatementInput, output: Result<ExecuteStatementOutput, Error>)
    decreases input, output

  method ExecuteStatement(config: InternalConfig, input: ExecuteStatementInput) returns (output: Result<ExecuteStatementOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteStatementEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExecuteTransactionEnsuresPublicly(input: ExecuteTransactionInput, output: Result<ExecuteTransactionOutput, Error>)
    decreases input, output

  method ExecuteTransaction(config: InternalConfig, input: ExecuteTransactionInput) returns (output: Result<ExecuteTransactionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExecuteTransactionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ExportTableToPointInTimeEnsuresPublicly(input: ExportTableToPointInTimeInput, output: Result<ExportTableToPointInTimeOutput, Error>)
    decreases input, output

  method ExportTableToPointInTime(config: InternalConfig, input: ExportTableToPointInTimeInput) returns (output: Result<ExportTableToPointInTimeOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ExportTableToPointInTimeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetItemEnsuresPublicly(input: GetItemInput, output: Result<GetItemOutput, Error>)
    decreases input, output

  method GetItem(config: InternalConfig, input: GetItemInput) returns (output: Result<GetItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetResourcePolicyEnsuresPublicly(input: GetResourcePolicyInput, output: Result<GetResourcePolicyOutput, Error>)
    decreases input, output

  method GetResourcePolicy(config: InternalConfig, input: GetResourcePolicyInput) returns (output: Result<GetResourcePolicyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetResourcePolicyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ImportTableEnsuresPublicly(input: ImportTableInput, output: Result<ImportTableOutput, Error>)
    decreases input, output

  method ImportTable(config: InternalConfig, input: ImportTableInput) returns (output: Result<ImportTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ImportTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListBackupsEnsuresPublicly(input: ListBackupsInput, output: Result<ListBackupsOutput, Error>)
    decreases input, output

  method ListBackups(config: InternalConfig, input: ListBackupsInput) returns (output: Result<ListBackupsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListBackupsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListContributorInsightsEnsuresPublicly(input: ListContributorInsightsInput, output: Result<ListContributorInsightsOutput, Error>)
    decreases input, output

  method ListContributorInsights(config: InternalConfig, input: ListContributorInsightsInput) returns (output: Result<ListContributorInsightsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListContributorInsightsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListExportsEnsuresPublicly(input: ListExportsInput, output: Result<ListExportsOutput, Error>)
    decreases input, output

  method ListExports(config: InternalConfig, input: ListExportsInput) returns (output: Result<ListExportsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListExportsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListGlobalTablesEnsuresPublicly(input: ListGlobalTablesInput, output: Result<ListGlobalTablesOutput, Error>)
    decreases input, output

  method ListGlobalTables(config: InternalConfig, input: ListGlobalTablesInput) returns (output: Result<ListGlobalTablesOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListGlobalTablesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListImportsEnsuresPublicly(input: ListImportsInput, output: Result<ListImportsOutput, Error>)
    decreases input, output

  method ListImports(config: InternalConfig, input: ListImportsInput) returns (output: Result<ListImportsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListImportsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListTablesEnsuresPublicly(input: ListTablesInput, output: Result<ListTablesOutput, Error>)
    decreases input, output

  method ListTables(config: InternalConfig, input: ListTablesInput) returns (output: Result<ListTablesOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListTablesEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ListTagsOfResourceEnsuresPublicly(input: ListTagsOfResourceInput, output: Result<ListTagsOfResourceOutput, Error>)
    decreases input, output

  method ListTagsOfResource(config: InternalConfig, input: ListTagsOfResourceInput) returns (output: Result<ListTagsOfResourceOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ListTagsOfResourceEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate PutItemEnsuresPublicly(input: PutItemInput, output: Result<PutItemOutput, Error>)
    decreases input, output

  method PutItem(config: InternalConfig, input: PutItemInput) returns (output: Result<PutItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate PutResourcePolicyEnsuresPublicly(input: PutResourcePolicyInput, output: Result<PutResourcePolicyOutput, Error>)
    decreases input, output

  method PutResourcePolicy(config: InternalConfig, input: PutResourcePolicyInput) returns (output: Result<PutResourcePolicyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures PutResourcePolicyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate QueryEnsuresPublicly(input: QueryInput, output: Result<QueryOutput, Error>)
    decreases input, output

  method Query(config: InternalConfig, input: QueryInput) returns (output: Result<QueryOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures QueryEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RestoreTableFromBackupEnsuresPublicly(input: RestoreTableFromBackupInput, output: Result<RestoreTableFromBackupOutput, Error>)
    decreases input, output

  method RestoreTableFromBackup(config: InternalConfig, input: RestoreTableFromBackupInput) returns (output: Result<RestoreTableFromBackupOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RestoreTableFromBackupEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate RestoreTableToPointInTimeEnsuresPublicly(input: RestoreTableToPointInTimeInput, output: Result<RestoreTableToPointInTimeOutput, Error>)
    decreases input, output

  method RestoreTableToPointInTime(config: InternalConfig, input: RestoreTableToPointInTimeInput) returns (output: Result<RestoreTableToPointInTimeOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures RestoreTableToPointInTimeEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate ScanEnsuresPublicly(input: ScanInput, output: Result<ScanOutput, Error>)
    decreases input, output

  method Scan(config: InternalConfig, input: ScanInput) returns (output: Result<ScanOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures ScanEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TagResourceEnsuresPublicly(input: TagResourceInput, output: Result<(), Error>)
    decreases input, output

  method TagResource(config: InternalConfig, input: TagResourceInput) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TagResourceEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactGetItemsEnsuresPublicly(input: TransactGetItemsInput, output: Result<TransactGetItemsOutput, Error>)
    decreases input, output

  method TransactGetItems(config: InternalConfig, input: TransactGetItemsInput) returns (output: Result<TransactGetItemsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactGetItemsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate TransactWriteItemsEnsuresPublicly(input: TransactWriteItemsInput, output: Result<TransactWriteItemsOutput, Error>)
    decreases input, output

  method TransactWriteItems(config: InternalConfig, input: TransactWriteItemsInput) returns (output: Result<TransactWriteItemsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures TransactWriteItemsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UntagResourceEnsuresPublicly(input: UntagResourceInput, output: Result<(), Error>)
    decreases input, output

  method UntagResource(config: InternalConfig, input: UntagResourceInput) returns (output: Result<(), Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UntagResourceEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateContinuousBackupsEnsuresPublicly(input: UpdateContinuousBackupsInput, output: Result<UpdateContinuousBackupsOutput, Error>)
    decreases input, output

  method UpdateContinuousBackups(config: InternalConfig, input: UpdateContinuousBackupsInput) returns (output: Result<UpdateContinuousBackupsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateContinuousBackupsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateContributorInsightsEnsuresPublicly(input: UpdateContributorInsightsInput, output: Result<UpdateContributorInsightsOutput, Error>)
    decreases input, output

  method UpdateContributorInsights(config: InternalConfig, input: UpdateContributorInsightsInput) returns (output: Result<UpdateContributorInsightsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateContributorInsightsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateGlobalTableEnsuresPublicly(input: UpdateGlobalTableInput, output: Result<UpdateGlobalTableOutput, Error>)
    decreases input, output

  method UpdateGlobalTable(config: InternalConfig, input: UpdateGlobalTableInput) returns (output: Result<UpdateGlobalTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateGlobalTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateGlobalTableSettingsEnsuresPublicly(input: UpdateGlobalTableSettingsInput, output: Result<UpdateGlobalTableSettingsOutput, Error>)
    decreases input, output

  method UpdateGlobalTableSettings(config: InternalConfig, input: UpdateGlobalTableSettingsInput) returns (output: Result<UpdateGlobalTableSettingsOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateGlobalTableSettingsEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateItemEnsuresPublicly(input: UpdateItemInput, output: Result<UpdateItemOutput, Error>)
    decreases input, output

  method UpdateItem(config: InternalConfig, input: UpdateItemInput) returns (output: Result<UpdateItemOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateItemEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateKinesisStreamingDestinationEnsuresPublicly(input: UpdateKinesisStreamingDestinationInput, output: Result<UpdateKinesisStreamingDestinationOutput, Error>)
    decreases input, output

  method UpdateKinesisStreamingDestination(config: InternalConfig, input: UpdateKinesisStreamingDestinationInput) returns (output: Result<UpdateKinesisStreamingDestinationOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateKinesisStreamingDestinationEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateTableEnsuresPublicly(input: UpdateTableInput, output: Result<UpdateTableOutput, Error>)
    decreases input, output

  method UpdateTable(config: InternalConfig, input: UpdateTableInput) returns (output: Result<UpdateTableOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateTableEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateTableReplicaAutoScalingEnsuresPublicly(input: UpdateTableReplicaAutoScalingInput, output: Result<UpdateTableReplicaAutoScalingOutput, Error>)
    decreases input, output

  method UpdateTableReplicaAutoScaling(config: InternalConfig, input: UpdateTableReplicaAutoScalingInput) returns (output: Result<UpdateTableReplicaAutoScalingOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateTableReplicaAutoScalingEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate UpdateTimeToLiveEnsuresPublicly(input: UpdateTimeToLiveInput, output: Result<UpdateTimeToLiveOutput, Error>)
    decreases input, output

  method UpdateTimeToLive(config: InternalConfig, input: UpdateTimeToLiveInput) returns (output: Result<UpdateTimeToLiveOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures UpdateTimeToLiveEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = ComAmazonawsDynamodbTypes

  type InternalConfig
}

module {:extern "software.amazon.cryptography.keystore.internaldafny"} KeyStore refines AbstractAwsCryptographyKeyStoreService {
  function method DefaultKeyStoreConfig(): KeyStoreConfig
  {
    KeyStoreConfig(ddbTableName := "None", kmsConfiguration := KMSConfiguration.kmsKeyArn("arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab"), logicalKeyStoreName := "None", id := None, grantTokens := None, kmsClient := None, ddbClient := None)
  }

  method KeyStore(config: KeyStoreConfig := DefaultKeyStoreConfig()) returns (res: Result<KeyStoreClient, Error>)
    requires config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    requires config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    modifies if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}, if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}) - if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    ensures config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    ensures res.Success? ==> res.value is KeyStoreClient && var rconfig: Operations.InternalConfig := (res.value as KeyStoreClient).config; (rconfig.kmsConfiguration.kmsKeyArn? ==> KmsArn.ValidKmsArn?(rconfig.kmsConfiguration.kmsKeyArn)) && (rconfig.kmsConfiguration.kmsMRKeyArn? ==> KmsArn.ValidKmsArn?(rconfig.kmsConfiguration.kmsMRKeyArn)) && DDB.IsValid_TableName(config.ddbTableName) && GetValidGrantTokens(config.grantTokens).Success? && (config.kmsClient.Some? ==> rconfig.kmsClient == config.kmsClient.value) && (config.ddbClient.Some? ==> rconfig.ddbClient == config.ddbClient.value && rconfig.kmsClient.ValidState() && rconfig.ddbClient.ValidState())
    ensures !DDB.IsValid_TableName(config.ddbTableName) && !KMS.IsValid_KeyIdType(config.kmsConfiguration.kmsKeyArn) ==> res.Failure?
    decreases config
  {
    var kmsClient: KMS.IKMSClient;
    var ddbClient: DDB.IDynamoDBClient;
    var inferredRegion: Option<string> := None;
    if KMSKeystoreOperations.HasKeyId(config.kmsConfiguration) {
      var parsedArn :- KmsArn.IsValidKeyArn(KMSKeystoreOperations.GetKeyId(config.kmsConfiguration));
      inferredRegion := Some(parsedArn.region);
    } else if config.kmsConfiguration.mrDiscovery? {
      inferredRegion := Some(config.kmsConfiguration.mrDiscovery.region);
    }
    var grantTokens := GetValidGrantTokens(config.grantTokens);
    :- Need(true && grantTokens.Success?, Types.KeyStoreException(message := "Grant Tokens passed to Key Store configuration are invalid."));
    var keyStoreId;
    if config.id.Some? {
      keyStoreId := config.id.value;
    } else {
      var maybeUuid := UUID.GenerateUUID();
      var uuid :- maybeUuid.MapFailure((e: string) => Types.KeyStoreException(message := e));
      keyStoreId := uuid;
    }
    if config.kmsClient.Some? {
      kmsClient := config.kmsClient.value;
    } else if config.kmsClient.None? && inferredRegion.Some? {
      var maybeKmsClient := KMSOperations.KMSClientForRegion(inferredRegion.value);
      kmsClient :- maybeKmsClient.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    } else {
      var maybeKmsClient := KMSOperations.KMSClient();
      kmsClient :- maybeKmsClient.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    }
    if config.ddbClient.Some? {
      ddbClient := config.ddbClient.value;
    } else if config.ddbClient.None? && inferredRegion.Some? {
      var maybeDdbClient := DDBOperations.DDBClientForRegion(inferredRegion.value);
      ddbClient :- maybeDdbClient.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    } else {
      var maybeDdbClient := DDBOperations.DynamoDBClient();
      ddbClient :- maybeDdbClient.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    }
    assume {:axiom} ddbClient.Modifies !! kmsClient.Modifies;
    :- Need(DDB.IsValid_TableName(config.ddbTableName), Types.KeyStoreException(message := "Invalid Amazon DynamoDB Table Name"));
    var client := new KeyStoreClient(Operations.Config(id := keyStoreId, ddbTableName := config.ddbTableName, logicalKeyStoreName := config.logicalKeyStoreName, kmsConfiguration := config.kmsConfiguration, grantTokens := grantTokens.value, kmsClient := kmsClient, ddbClient := ddbClient));
    return Success(client);
  }

  function method CreateSuccessOfClient(client: IKeyStoreClient): Result<IKeyStoreClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IKeyStoreClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened AwsKmsUtils

  import Operations = AwsCryptographyKeyStoreOperations

  import KMSOperations = Com.Amazonaws.Kms

  import DDBOperations = Com.Amazonaws.Dynamodb

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UUID

  import ErrorMessages = KeyStoreErrorMessages

  import KmsArn

  import KMSKeystoreOperations

  class KeyStoreClient ... {
    predicate {:vcs_split_on_every_assert} {:rlimit 3000} ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}
    {
      Operations.ValidInternalConfig?(config) &&
      History !in Operations.ModifiesInternalConfig(config) &&
      Modifies == Operations.ModifiesInternalConfig(config) + {History}
    }

    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config
      decreases config
    {
      this.config := config;
      History := new IKeyStoreClientCallHistory();
      Modifies := Operations.ModifiesInternalConfig(config) + {History};
    }

    const config: Operations.InternalConfig

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output
    {
      Operations.GetKeyStoreInfoEnsuresPublicly(output)
    }

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}
    {
      output := Operations.GetKeyStoreInfo(config);
      History.GetKeyStoreInfo := History.GetKeyStoreInfo + [DafnyCallEvent((), output)];
    }

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyStoreEnsuresPublicly(input, output)
    }

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKeyStore(config, input);
      History.CreateKeyStore := History.CreateKeyStore + [DafnyCallEvent(input, output)];
    }

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyEnsuresPublicly(input, output)
    }

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKey(config, input);
      History.CreateKey := History.CreateKey + [DafnyCallEvent(input, output)];
    }

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output
    {
      Operations.VersionKeyEnsuresPublicly(input, output)
    }

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.VersionKey(config, input);
      History.VersionKey := History.VersionKey + [DafnyCallEvent(input, output)];
    }

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetActiveBranchKeyEnsuresPublicly(input, output)
    }

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetActiveBranchKey(config, input);
      History.GetActiveBranchKey := History.GetActiveBranchKey + [DafnyCallEvent(input, output)];
    }

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output
    {
      Operations.GetBranchKeyVersionEnsuresPublicly(input, output)
    }

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBranchKeyVersion(config, input);
      History.GetBranchKeyVersion := History.GetBranchKeyVersion + [DafnyCallEvent(input, output)];
    }

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetBeaconKeyEnsuresPublicly(input, output)
    }

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBeaconKey(config, input);
      History.GetBeaconKey := History.GetBeaconKey + [DafnyCallEvent(input, output)];
    }
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes
}

module {:options "/functionSyntax:4"} KmsArn {
  predicate method ValidKmsArn?(input: string)
    decreases input
  {
    KMS.IsValid_KeyIdType(input) &&
    var maybeParsed: Result<AwsKmsArn, string> := AwsArnParsing.ParseAwsKmsArn(input); maybeParsed.Success? && maybeParsed.value.resource.resourceType == "key"
  }

  function method IsValidKeyArn(input: string): (res: Result<AwsArnParsing.AwsKmsArn, Types.Error>)
    ensures res.Success? ==> ValidKmsArn?(input)
    decreases input
  {
    :- Need(KMS.IsValid_KeyIdType(input), Types.KeyStoreException(message := ErrorMessages.KMS_CONFIG_KMS_ARN_INVALID)); var arn: AwsKmsArn :- AwsArnParsing.ParseAwsKmsArn(input).MapFailure((error: string) => Types.KeyStoreException(message := ErrorMessages.KMS_CONFIG_KMS_ARN_INVALID + ". " + error)); if arn.resource.resourceType != "key" then Failure(Types.KeyStoreException(message := ErrorMessages.ALIAS_NOT_ALLOWED)) else Success(arn)
  }

  import opened Wrappers

  import AwsArnParsing

  import ErrorMessages = KeyStoreErrorMessages

  import KMS = ComAmazonawsKmsTypes

  import Types = AwsCryptographyKeyStoreTypes
}

module {:options "/functionSyntax:4"} KeyStoreErrorMessages {
  const KMS_CONFIG_KMS_ARN_INVALID := "KMSConfiguration's KMS Key ARN is invalid."
  const CUSTOM_BRANCH_KEY_ID_NEED_EC := "Custom branch key identifier requires custom encryption context."
  const GET_KEY_ARN_DISAGREEMENT := "Branch key's KMS Key ARN read from Dynamodb does not match Key Store's configured KMS Key ARN."
  const DISCOVERY_CREATE_KEY_NOT_SUPPORTED := "Key Store's kmsConfiguration MUST BE kmsKeyArn or kmsMRKeyArn to Create Branch Keys."
  const DISCOVERY_VERSION_KEY_NOT_SUPPORTED := "Key Store's kmsConfiguration MUST BE kmsKeyArn or kmsMRKeyArn to Version Branch Keys."
  const UTF8_ENCODING_ENCRYPTION_CONTEXT_ERROR := "Unable to UTF8 Encode element of Encryption Context."
  const VERSION_KEY_KMS_KEY_ARN_DISAGREEMENT := GET_KEY_ARN_DISAGREEMENT
  const ALIAS_NOT_ALLOWED := "Key Store encountered a KMS Alias ARN instead of a KMS Key ARN, which is not allowed."
  const NO_CORRESPONDING_BRANCH_KEY := "No item found for corresponding branch key identifier."
  const BRANCH_KEY_ID_NEEDED := "Empty string not supported for branch key identifier."
  const RETRIEVED_KEYSTORE_ITEM_INVALID_KMS_ARN := "The `kms-arn` field for the requested branch key identifier is corrupted."
}

module AwsArnParsing {
  const MAX_AWS_KMS_IDENTIFIER_LENGTH := 2048 as uint64

  predicate method ValidAwsKmsResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    (resource.resourceType == "key" || resource.resourceType == "alias")
  }

  predicate method ValidAwsKmsArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == "kms" &&
    ValidAwsKmsResource(arn.resource)
  }

  function method ParseAwsKmsRawResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    :- Need(info[0 as uint32] != "key", "Malformed raw key id: " + identifier); SequenceIsSafeBecauseItIsInMemory(info); if |info| as uint64 == 1 then ParseAwsKmsResources("key/" + identifier) else ParseAwsKmsResources(identifier)
  }

  function method ParseAwsKmsResources(identifier: string): (result: Result<AwsKmsResource, string>)
    decreases identifier
  {
    var info: seq<seq<char>> := Split(identifier, '/');
    SequenceIsSafeBecauseItIsInMemory(info);
    :- Need(|info| as uint64 > 1, "Malformed resource: " + identifier); var resourceType: seq<char> := info[0 as uint32]; var value: seq<char> := Join(info[1 as uint32..], "/"); var resource: AwsResource := AwsResource(resourceType, value); :- Need(ValidAwsKmsResource(resource), "Malformed resource: " + identifier); Success(resource)
  }

  predicate method ValidAmazonDynamodbResource(resource: AwsResource)
    decreases resource
  {
    resource.Valid() &&
    resource.resourceType == "table"
  }

  predicate method ValidAmazonDynamodbArn(arn: AwsArn)
    decreases arn
  {
    arn.Valid() &&
    arn.service == "dynamodb" &&
    ValidAmazonDynamodbResource(arn.resource)
  }

  function method ParseAmazonDynamodbResources(identifier: string): (result: Result<AmazonDynamodbResource, string>)
    decreases identifier
  {
    var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/');
    :- Need(info.Some?, "Malformed resource: " + identifier); var resourceType: seq<char> := info.value.0; var value: seq<char> := info.value.1; :- Need(DDB.IsValid_TableName(value), "Table Name invalid: " + identifier); var resource: AwsResource := AwsResource(resourceType, value); :- Need(ValidAmazonDynamodbResource(resource), "Malformed resource: " + identifier); Success(resource)
  }

  lemma /*{:_inductionTrigger Split(identifier, '/')}*/ /*{:_inductionTrigger ParseAwsKmsResources(identifier)}*/ /*{:_induction identifier}*/ ParseAwsKmsResourcesCorrect(identifier: string)
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); ghost var r: Result<AwsKmsResource, string> := ParseAwsKmsResources(identifier); |info| > 1 && Join([r.value.resourceType, r.value.value], "/") == identifier
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var resourceType: seq<char> := Split(identifier, '/')[0]; "key" == resourceType || "alias" == resourceType
    ensures ParseAwsKmsResources(identifier).Success? ==> ghost var info: seq<seq<char>> := Split(identifier, '/'); |Join(info[1..], "/")| > 0
    decreases identifier
  {
  }

  lemma ParseAmazonDynamodbResourcesCorrect(identifier: string)
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/'); ghost var r: Result<AmazonDynamodbResource, string> := ParseAmazonDynamodbResources(identifier); info.Some? && Join([r.value.resourceType, r.value.value], "/") == identifier
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var resourceType: seq<char> := SplitOnce?(identifier, '/').value.0; resourceType == "table"
    ensures ParseAmazonDynamodbResources(identifier).Success? ==> ghost var info: Option<(seq<char>, seq<char>)> := SplitOnce?(identifier, '/'); DDB.IsValid_TableName(info.value.1)
    decreases identifier
  {
  }

  function method ParseAwsKmsArn(identifier: string): (result: Result<AwsKmsArn, string>)
    ensures result.Success? ==> "arn" <= identifier && |Split(identifier, ':')| == 6 && |Split(identifier, ':')[1]| > 0 && Split(identifier, ':')[2] == "kms" && |Split(identifier, ':')[3]| > 0 && |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    SequenceIsSafeBecauseItIsInMemory(components);
    :- Need(6 == |components| as uint64, "Malformed arn: " + identifier); var resource: AwsKmsResource :- ParseAwsKmsResources(components[5 as uint32]); var arn: AwsArn := AwsArn(components[0 as uint32], components[1 as uint32], components[2 as uint32], components[3 as uint32], components[4 as uint32], resource); :- Need(ValidAwsKmsArn(arn), "Malformed Arn:" + identifier); Success(arn)
  }

  function method ParseAmazonDynamodbTableArn(identifier: string): (result: Result<AmazonDynamodbTableArn, string>)
    ensures result.Success? ==> "arn" <= identifier && |Split(identifier, ':')| == 6 && |Split(identifier, ':')[1]| > 0 && Split(identifier, ':')[2] == "dynamodb" && |Split(identifier, ':')[3]| > 0 && |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
    var components: seq<seq<char>> := Split(identifier, ':');
    SequenceIsSafeBecauseItIsInMemory(components);
    :- Need(6 == |components| as uint64, "Malformed arn: " + identifier); var resource: AmazonDynamodbResource :- ParseAmazonDynamodbResources(components[5 as uint32]); var arn: AwsArn := AwsArn(components[0 as uint32], components[1 as uint32], components[2 as uint32], components[3 as uint32], components[4 as uint32], resource); :- Need(ValidAmazonDynamodbArn(arn), "Malformed Arn:" + identifier); Success(arn)
  }

  lemma /*{:_inductionTrigger Split(identifier, ':')}*/ /*{:_inductionTrigger ParseAwsKmsArn(identifier)}*/ /*{:_induction identifier}*/ ParseAwsKmsArnCorrect(identifier: string)
    ensures ParseAwsKmsArn(identifier).Success? ==> "arn" <= identifier
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> Split(identifier, ':')[2] == "kms"
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAwsKmsArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  lemma /*{:_inductionTrigger Split(identifier, ':')}*/ /*{:_inductionTrigger ParseAmazonDynamodbTableArn(identifier)}*/ /*{:_induction identifier}*/ ParseAmazonDynamodbTableArnCorrect(identifier: string)
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> "arn" <= identifier
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')| == 6
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[1]| > 0
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> Split(identifier, ':')[2] == "dynamodb"
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[3]| > 0
    ensures ParseAmazonDynamodbTableArn(identifier).Success? ==> |Split(identifier, ':')[4]| > 0
    decreases identifier
  {
  }

  function method ParseAwsKmsIdentifier(identifier: string): (result: Result<AwsKmsIdentifier, string>)
    decreases identifier
  {
    if "arn:" <= identifier then
      var arn: AwsKmsArn :- ParseAwsKmsArn(identifier); Success(AwsKmsArnIdentifier(arn))
    else
      var r: AwsKmsResource :- ParseAwsKmsRawResources(identifier); Success(AwsKmsRawResourceIdentifier(r))
  }

  function method ParseAmazonDynamodbTableName(identifier: string): (result: Result<DDB.TableName, string>)
    decreases identifier
  {
    var arn: AmazonDynamodbTableArn :- ParseAmazonDynamodbTableArn(identifier); var tableArn: AmazonDynamodbTableName := AmazonDynamodbTableArn(arn); var tableName: string := tableArn.GetTableName(); Success(tableName)
  }

  predicate method IsMultiRegionAwsKmsArn(arn: AwsKmsArn)
    decreases arn
  {
    IsMultiRegionAwsKmsResource(arn.resource)
  }

  lemma IsMultiRegionAwsKmsArnCorrectness(arn: AwsKmsArn)
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == "alias"
    ensures !IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == "key" && !("mrk-" <= arn.resource.value)
    ensures IsMultiRegionAwsKmsArn(arn) <== arn.resource.resourceType == "key" && "mrk-" <= arn.resource.value
    decreases arn
  {
  }

  predicate method IsMultiRegionAwsKmsIdentifier(identifier: AwsKmsIdentifier)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(arn) =>
        IsMultiRegionAwsKmsArn(arn)
      case AwsKmsRawResourceIdentifier(r) =>
        IsMultiRegionAwsKmsResource(r)
    }
  }

  lemma IsMultiRegionAwsKmsIdentifierCorrect(s: string)
    ensures "arn:" <= s && ParseAwsKmsArn(s).Success? ==> ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(s); ghost var arnIdentifier: AwsKmsIdentifier := AwsKmsArnIdentifier(arn.value); IsMultiRegionAwsKmsIdentifier(arnIdentifier) == IsMultiRegionAwsKmsArn(arn.value)
    ensures "alias/" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, string> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures "mrk-" <= s && ParseAwsKmsResources(s).Success? ==> ghost var resource: Result<AwsKmsResource, string> := ParseAwsKmsResources(s); ghost var resourceIdentifier: AwsKmsIdentifier := AwsKmsRawResourceIdentifier(resource.value); IsMultiRegionAwsKmsIdentifier(resourceIdentifier)
    ensures !("arn:" <= s) && !("alias/" <= s) && !("mrk-" <= s) && ParseAwsKmsIdentifier(s).Success? ==> ghost var resourceIdentifier: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(s); !IsMultiRegionAwsKmsIdentifier(resourceIdentifier.value)
    decreases s
  {
  }

  predicate method IsMultiRegionAwsKmsResource(resource: AwsKmsResource)
    decreases resource
  {
    resource.resourceType == "key" &&
    "mrk-" <= resource.value
  }

  function method GetRegion(identifier: AwsKmsIdentifier): (res: Option<string>)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        Some(a.region)
      case AwsKmsRawResourceIdentifier(_ /* _v0 */) =>
        None()
    }
  }

  function method IsAwsKmsIdentifierString(s: string): (res: Result<AwsKmsIdentifier, string>)
    decreases s
  {
    :- Need(UTF8.IsASCIIString(s), "Not a valid ASCII string."); SequenceIsSafeBecauseItIsInMemory(s); :- Need(0 < |s| as uint64 <= MAX_AWS_KMS_IDENTIFIER_LENGTH, "Identifier exceeds maximum length."); ParseAwsKmsIdentifier(s)
  }

  function method Error(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  function method ValidateDdbTableArn(tableArn: string): (res: Result<(), Types.Error>)
    ensures res.Success? ==> ParseAmazonDynamodbTableArn(tableArn).Success? && UTF8.IsASCIIString(tableArn) && DDB.IsValid_TableName(ParseAmazonDynamodbTableName(tableArn).value)
    decreases tableArn
  {
    var _ /* _v1 */: DDB.TableName :- ParseAmazonDynamodbTableName(tableArn).MapFailure(Error); :- Need(UTF8.IsASCIIString(tableArn), Types.AwsCryptographicMaterialProvidersException(message := "Table Arn is not ASCII")); :- Need(DDB.IsValid_TableName(ParseAmazonDynamodbTableName(tableArn).value), Types.AwsCryptographicMaterialProvidersException(message := "Table Name is too long")); Success(())
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyMaterialProvidersTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UTF8

  datatype AwsResource = AwsResource(resourceType: string, value: string) {
    predicate method Valid()
      decreases this
    {
      SequenceIsSafeBecauseItIsInMemory(value);
      true &&
      0 < |value| as uint64
    }

    function method ToString(): string
      decreases this
    {
      resourceType + "/" + value
    }
  }

  datatype AwsArn = AwsArn(arnLiteral: string, partition: string, service: string, region: string, account: string, resource: AwsResource) {
    predicate method Valid()
      decreases this
    {
      SequenceIsSafeBecauseItIsInMemory(partition);
      SequenceIsSafeBecauseItIsInMemory(service);
      SequenceIsSafeBecauseItIsInMemory(region);
      SequenceIsSafeBecauseItIsInMemory(account);
      arnLiteral == "arn" &&
      0 < |partition| as uint64 &&
      0 < |service| as uint64 &&
      0 < |region| as uint64 &&
      0 < |account| as uint64 &&
      resource.Valid()
    }

    function method ToString(): string
      requires this.Valid()
      decreases this
    {
      ToArnString(None)
    }

    function method ToArnString(customRegion: Option<string>): string
      requires this.Valid()
      decreases if customRegion.None? then 1 else 0
    {
      match customRegion {
        case None() =>
          ToArnString(Some(region))
        case Some(customRegion) =>
          Join([arnLiteral, partition, service, customRegion, account, resource.ToString()], ":")
      }
    }
  }

  type AwsKmsArn = a: AwsArn
    | ValidAwsKmsArn(a)
    witness *

  type AwsKmsResource = r: AwsResource
    | ValidAwsKmsResource(r)
    witness *

  datatype AwsKmsIdentifier = AwsKmsArnIdentifier(a: AwsKmsArn) | AwsKmsRawResourceIdentifier(r: AwsKmsResource) {
    function method ToString(): string
      decreases this
    {
      match this {
        case AwsKmsArnIdentifier(a: AwsKmsArn) =>
          a.ToString()
        case AwsKmsRawResourceIdentifier(r: AwsKmsResource) =>
          r.ToString()
      }
    }
  }

  type AmazonDynamodbTableArn = a: AwsArn
    | ValidAmazonDynamodbArn(a)
    witness *

  type AmazonDynamodbResource = r: AwsResource
    | ValidAmazonDynamodbResource(r)
    witness *

  datatype AmazonDynamodbTableName = AmazonDynamodbTableArn(a: AmazonDynamodbTableArn) {
    function method GetTableName(): string
      decreases this
    {
      match this {
        case AmazonDynamodbTableArn(a: AmazonDynamodbTableArn) =>
          a.resource.value
      }
    }
  }

  type AwsKmsIdentifierString = s: string
    | IsAwsKmsIdentifierString(s).Success?
    witness *
}

module {:extern "software.amazon.cryptography.keystore.internaldafny.types"} AwsCryptographyKeyStoreTypes {
  predicate method IsDummySubsetType(x: int)
    decreases x
  {
    0 < x
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import ComAmazonawsDynamodbTypes

  import ComAmazonawsKmsTypes

  datatype DafnyCallEvent<I, O> = DafnyCallEvent(input: I, output: O)

  datatype BeaconKeyMaterials = BeaconKeyMaterials(nameonly beaconKeyIdentifier: string, nameonly encryptionContext: EncryptionContext, nameonly beaconKey: Option<Secret> := Option.None, nameonly hmacKeys: Option<HmacKeyMap> := Option.None)

  datatype BranchKeyMaterials = BranchKeyMaterials(nameonly branchKeyIdentifier: string, nameonly branchKeyVersion: Utf8Bytes, nameonly encryptionContext: EncryptionContext, nameonly branchKey: Secret)

  datatype CreateKeyInput = CreateKeyInput(nameonly branchKeyIdentifier: Option<string> := Option.None, nameonly encryptionContext: Option<EncryptionContext> := Option.None)

  datatype CreateKeyOutput = CreateKeyOutput(nameonly branchKeyIdentifier: string)

  datatype CreateKeyStoreInput = CreateKeyStoreInput

  datatype CreateKeyStoreOutput = CreateKeyStoreOutput(nameonly tableArn: ComAmazonawsDynamodbTypes.TableArn)

  datatype Discovery = Discovery

  type EncryptionContext = map<Utf8Bytes, Utf8Bytes>

  datatype GetActiveBranchKeyInput = GetActiveBranchKeyInput(nameonly branchKeyIdentifier: string)

  datatype GetActiveBranchKeyOutput = GetActiveBranchKeyOutput(nameonly branchKeyMaterials: BranchKeyMaterials)

  datatype GetBeaconKeyInput = GetBeaconKeyInput(nameonly branchKeyIdentifier: string)

  datatype GetBeaconKeyOutput = GetBeaconKeyOutput(nameonly beaconKeyMaterials: BeaconKeyMaterials)

  datatype GetBranchKeyVersionInput = GetBranchKeyVersionInput(nameonly branchKeyIdentifier: string, nameonly branchKeyVersion: string)

  datatype GetBranchKeyVersionOutput = GetBranchKeyVersionOutput(nameonly branchKeyMaterials: BranchKeyMaterials)

  datatype GetKeyStoreInfoOutput = GetKeyStoreInfoOutput(nameonly keyStoreId: string, nameonly keyStoreName: ComAmazonawsDynamodbTypes.TableName, nameonly logicalKeyStoreName: string, nameonly grantTokens: GrantTokenList, nameonly kmsConfiguration: KMSConfiguration)

  type GrantTokenList = seq<string>

  type HmacKeyMap = map<string, Secret>

  class IKeyStoreClientCallHistory {
    ghost constructor ()
    {
      GetKeyStoreInfo := [];
      CreateKeyStore := [];
      CreateKey := [];
      VersionKey := [];
      GetActiveBranchKey := [];
      GetBranchKeyVersion := [];
      GetBeaconKey := [];
    }

    ghost var GetKeyStoreInfo: seq<DafnyCallEvent<(), Result<GetKeyStoreInfoOutput, Error>>>
    ghost var CreateKeyStore: seq<DafnyCallEvent<CreateKeyStoreInput, Result<CreateKeyStoreOutput, Error>>>
    ghost var CreateKey: seq<DafnyCallEvent<CreateKeyInput, Result<CreateKeyOutput, Error>>>
    ghost var VersionKey: seq<DafnyCallEvent<VersionKeyInput, Result<VersionKeyOutput, Error>>>
    ghost var GetActiveBranchKey: seq<DafnyCallEvent<GetActiveBranchKeyInput, Result<GetActiveBranchKeyOutput, Error>>>
    ghost var GetBranchKeyVersion: seq<DafnyCallEvent<GetBranchKeyVersionInput, Result<GetBranchKeyVersionOutput, Error>>>
    ghost var GetBeaconKey: seq<DafnyCallEvent<GetBeaconKeyInput, Result<GetBeaconKeyOutput, Error>>>
  }

  trait {:termination false} IKeyStoreClient {
    ghost const Modifies: set<object>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies

    ghost const History: IKeyStoreClientCallHistory

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
  }

  datatype KeyStoreConfig = KeyStoreConfig(nameonly ddbTableName: ComAmazonawsDynamodbTypes.TableName, nameonly kmsConfiguration: KMSConfiguration, nameonly logicalKeyStoreName: string, nameonly id: Option<string> := Option.None, nameonly grantTokens: Option<GrantTokenList> := Option.None, nameonly ddbClient: Option<ComAmazonawsDynamodbTypes.IDynamoDBClient> := Option.None, nameonly kmsClient: Option<ComAmazonawsKmsTypes.IKMSClient> := Option.None)

  datatype KMSConfiguration = kmsKeyArn(kmsKeyArn: ComAmazonawsKmsTypes.KeyIdType) | kmsMRKeyArn(kmsMRKeyArn: ComAmazonawsKmsTypes.KeyIdType) | discovery(discovery: Discovery) | mrDiscovery(mrDiscovery: MRDiscovery)

  datatype MRDiscovery = MRDiscovery(nameonly region: ComAmazonawsKmsTypes.RegionType)

  type Secret = seq<uint8>

  type Utf8Bytes = ValidUTF8Bytes

  datatype VersionKeyInput = VersionKeyInput(nameonly branchKeyIdentifier: string)

  datatype VersionKeyOutput = VersionKeyOutput

  datatype Error = KeyStoreException(nameonly message: string) | ComAmazonawsDynamodb(ComAmazonawsDynamodb: ComAmazonawsDynamodbTypes.Error) | ComAmazonawsKms(ComAmazonawsKms: ComAmazonawsKmsTypes.Error) | CollectionOfErrors(list: seq<Error>, nameonly message: string) | Opaque(obj: object) | OpaqueWithText(obj: object, objMessage: string)

  type OpaqueError = e: Error
    | e.Opaque? || e.OpaqueWithText?
    witness *

  type DummySubsetType = x: int
    | IsDummySubsetType(x)
    witness 1
}

abstract module AbstractAwsCryptographyKeyStoreService {
  function method DefaultKeyStoreConfig(): KeyStoreConfig

  method KeyStore(config: KeyStoreConfig := DefaultKeyStoreConfig()) returns (res: Result<KeyStoreClient, Error>)
    requires config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    requires config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    modifies if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}, if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}
    ensures res.Success? ==> fresh(res.value) && fresh(res.value.Modifies - (if config.ddbClient.Some? then config.ddbClient.value.Modifies else {}) - if config.kmsClient.Some? then config.kmsClient.value.Modifies else {}) && fresh(res.value.History) && res.value.ValidState()
    ensures config.ddbClient.Some? ==> config.ddbClient.value.ValidState()
    ensures config.kmsClient.Some? ==> config.kmsClient.value.ValidState()
    decreases config

  function method CreateSuccessOfClient(client: IKeyStoreClient): Result<IKeyStoreClient, Error>
    decreases client
  {
    Success(client)
  }

  function method CreateFailureOfError(error: Error): Result<IKeyStoreClient, Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes

  import Operations : AbstractAwsCryptographyKeyStoreOperations

  class KeyStoreClient extends IKeyStoreClient {
    constructor (config: Operations.InternalConfig)
      requires Operations.ValidInternalConfig?(config)
      ensures ValidState() && fresh(History) && this.config == config

    const config: Operations.InternalConfig

    predicate ValidState()
      ensures ValidState() ==> Operations.ValidInternalConfig?(config) && History !in Operations.ModifiesInternalConfig(config) && Modifies == Operations.ModifiesInternalConfig(config) + {History}

    predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
      decreases output
    {
      Operations.GetKeyStoreInfoEnsuresPublicly(output)
    }

    method GetKeyStoreInfo() returns (output: Result<GetKeyStoreInfoOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetKeyStoreInfo
      ensures true && ValidState()
      ensures GetKeyStoreInfoEnsuresPublicly(output)
      ensures History.GetKeyStoreInfo == old(History.GetKeyStoreInfo) + [DafnyCallEvent((), output)]
      decreases Modifies - {History}
    {
      output := Operations.GetKeyStoreInfo(config);
      History.GetKeyStoreInfo := History.GetKeyStoreInfo + [DafnyCallEvent((), output)];
    }

    predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyStoreEnsuresPublicly(input, output)
    }

    method CreateKeyStore(input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKeyStore
      ensures true && ValidState()
      ensures CreateKeyStoreEnsuresPublicly(input, output)
      ensures History.CreateKeyStore == old(History.CreateKeyStore) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKeyStore(config, input);
      History.CreateKeyStore := History.CreateKeyStore + [DafnyCallEvent(input, output)];
    }

    predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
      decreases input, output
    {
      Operations.CreateKeyEnsuresPublicly(input, output)
    }

    method CreateKey(input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`CreateKey
      ensures true && ValidState()
      ensures CreateKeyEnsuresPublicly(input, output)
      ensures History.CreateKey == old(History.CreateKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.CreateKey(config, input);
      History.CreateKey := History.CreateKey + [DafnyCallEvent(input, output)];
    }

    predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
      decreases input, output
    {
      Operations.VersionKeyEnsuresPublicly(input, output)
    }

    method VersionKey(input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`VersionKey
      ensures true && ValidState()
      ensures VersionKeyEnsuresPublicly(input, output)
      ensures History.VersionKey == old(History.VersionKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.VersionKey(config, input);
      History.VersionKey := History.VersionKey + [DafnyCallEvent(input, output)];
    }

    predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetActiveBranchKeyEnsuresPublicly(input, output)
    }

    method GetActiveBranchKey(input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetActiveBranchKey
      ensures true && ValidState()
      ensures GetActiveBranchKeyEnsuresPublicly(input, output)
      ensures History.GetActiveBranchKey == old(History.GetActiveBranchKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetActiveBranchKey(config, input);
      History.GetActiveBranchKey := History.GetActiveBranchKey + [DafnyCallEvent(input, output)];
    }

    predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
      decreases input, output
    {
      Operations.GetBranchKeyVersionEnsuresPublicly(input, output)
    }

    method GetBranchKeyVersion(input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBranchKeyVersion
      ensures true && ValidState()
      ensures GetBranchKeyVersionEnsuresPublicly(input, output)
      ensures History.GetBranchKeyVersion == old(History.GetBranchKeyVersion) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBranchKeyVersion(config, input);
      History.GetBranchKeyVersion := History.GetBranchKeyVersion + [DafnyCallEvent(input, output)];
    }

    predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
      decreases input, output
    {
      Operations.GetBeaconKeyEnsuresPublicly(input, output)
    }

    method GetBeaconKey(input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
      requires true && ValidState()
      modifies Modifies - {History}, History`GetBeaconKey
      ensures true && ValidState()
      ensures GetBeaconKeyEnsuresPublicly(input, output)
      ensures History.GetBeaconKey == old(History.GetBeaconKey) + [DafnyCallEvent(input, output)]
      decreases Modifies - {History}
    {
      output := Operations.GetBeaconKey(config, input);
      History.GetBeaconKey := History.GetBeaconKey + [DafnyCallEvent(input, output)];
    }
  }
}

abstract module AbstractAwsCryptographyKeyStoreOperations {
  predicate ValidInternalConfig?(config: InternalConfig)

  function ModifiesInternalConfig(config: InternalConfig): set<object>

  predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
    decreases output

  method GetKeyStoreInfo(config: InternalConfig) returns (output: Result<GetKeyStoreInfoOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyStoreInfoEnsuresPublicly(output)
    decreases ModifiesInternalConfig(config)

  predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
    decreases input, output

  method CreateKeyStore(config: InternalConfig, input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyStoreEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
    decreases input, output

  method CreateKey(config: InternalConfig, input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
    decreases input, output

  method VersionKey(config: InternalConfig, input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VersionKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
    decreases input, output

  method GetActiveBranchKey(config: InternalConfig, input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetActiveBranchKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
    decreases input, output

  method GetBranchKeyVersion(config: InternalConfig, input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBranchKeyVersionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
    decreases input, output

  method GetBeaconKey(config: InternalConfig, input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBeaconKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes

  type InternalConfig
}

module AwsCryptographyKeyStoreOperations refines AbstractAwsCryptographyKeyStoreOperations {
  predicate ValidInternalConfig?(config: InternalConfig)
    decreases config
  {
    DDB.IsValid_TableName(config.ddbTableName) &&
    (config.kmsConfiguration.kmsKeyArn? ==>
      KmsArn.ValidKmsArn?(config.kmsConfiguration.kmsKeyArn)) &&
    (config.kmsConfiguration.kmsMRKeyArn? ==>
      KmsArn.ValidKmsArn?(config.kmsConfiguration.kmsMRKeyArn)) &&
    config.kmsClient.ValidState() &&
    config.ddbClient.ValidState() &&
    config.ddbClient.Modifies !! config.kmsClient.Modifies
  }

  function ModifiesInternalConfig(config: InternalConfig): set<object>
    decreases config
  {
    config.kmsClient.Modifies + config.ddbClient.Modifies
  }

  predicate GetKeyStoreInfoEnsuresPublicly(output: Result<GetKeyStoreInfoOutput, Error>)
    decreases output
  {
    true
  }

  method GetKeyStoreInfo(config: InternalConfig) returns (output: Result<GetKeyStoreInfoOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetKeyStoreInfoEnsuresPublicly(output)
    ensures output.Success? ==> output.value.keyStoreId == config.id && output.value.keyStoreName == config.ddbTableName && output.value.logicalKeyStoreName == config.logicalKeyStoreName && output.value.grantTokens == config.grantTokens && output.value.kmsConfiguration == config.kmsConfiguration
    decreases ModifiesInternalConfig(config)
  {
    output := Success(Types.GetKeyStoreInfoOutput(keyStoreId := config.id, keyStoreName := config.ddbTableName, logicalKeyStoreName := config.logicalKeyStoreName, grantTokens := config.grantTokens, kmsConfiguration := config.kmsConfiguration));
  }

  predicate CreateKeyStoreEnsuresPublicly(input: CreateKeyStoreInput, output: Result<CreateKeyStoreOutput, Error>)
    decreases input, output
  {
    true
  }

  method CreateKeyStore(config: InternalConfig, input: CreateKeyStoreInput) returns (output: Result<CreateKeyStoreOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyStoreEnsuresPublicly(input, output)
    ensures output.Success? ==> AwsArnParsing.ParseAmazonDynamodbTableName(output.value.tableArn).Success? && AwsArnParsing.ParseAmazonDynamodbTableName(output.value.tableArn).value == config.ddbTableName
    decreases ModifiesInternalConfig(config)
  {
    var ddbTableArn :- CreateKeyStoreTable.CreateKeyStoreTable(config.ddbTableName, config.ddbClient);
    var tableName := AwsArnParsing.ParseAmazonDynamodbTableName(ddbTableArn);
    :- Need(tableName.Success? && tableName.value == config.ddbTableName, Types.KeyStoreException(message := "Configured DDB Table Name does not match parsed Table Name from DDB Table Arn."));
    output := Success(Types.CreateKeyStoreOutput(tableArn := ddbTableArn));
  }

  predicate CreateKeyEnsuresPublicly(input: CreateKeyInput, output: Result<CreateKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method CreateKey(config: InternalConfig, input: CreateKeyInput) returns (output: Result<CreateKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures CreateKeyEnsuresPublicly(input, output)
    ensures input.branchKeyIdentifier.Some? && input.encryptionContext.None? ==> output.Failure?
    ensures true && !KO.HasKeyId(config.kmsConfiguration) ==> output.Failure?
    decreases ModifiesInternalConfig(config)
  {
    OptionalMapIsSafeBecauseItIsInMemory(input.encryptionContext);
    :- Need(input.branchKeyIdentifier.Some? ==> input.encryptionContext.Some? && 0 < |input.encryptionContext.value| as uint64, Types.KeyStoreException(message := ErrorMessages.CUSTOM_BRANCH_KEY_ID_NEED_EC));
    :- Need(KO.HasKeyId(config.kmsConfiguration), Types.KeyStoreException(message := ErrorMessages.DISCOVERY_CREATE_KEY_NOT_SUPPORTED));
    var branchKeyIdentifier: string;
    if input.branchKeyIdentifier.None? {
      var maybeBranchKeyId := UUID.GenerateUUID();
      branchKeyIdentifier :- maybeBranchKeyId.MapFailure((e: string) => Types.KeyStoreException(message := e));
    } else {
      SequenceIsSafeBecauseItIsInMemory(input.branchKeyIdentifier.value);
      :- Need(0 < |input.branchKeyIdentifier.value| as uint64, Types.KeyStoreException(message := "Custom branch key id can not be an empty string."));
      branchKeyIdentifier := input.branchKeyIdentifier.value;
    }
    var timestamp? := Time.GetCurrentTimeStamp();
    var timestamp :- timestamp?.MapFailure((e: string) => Types.KeyStoreException(message := e));
    var maybeBranchKeyVersion := UUID.GenerateUUID();
    var branchKeyVersion :- maybeBranchKeyVersion.MapFailure((e: string) => Types.KeyStoreException(message := e));
    var unwrapEncryptionContext := input.encryptionContext.UnwrapOr(map[]);
    var encodedEncryptionContext := set k: ValidUTF8Bytes {:trigger unwrapEncryptionContext[k]} {:trigger k in unwrapEncryptionContext} | k in unwrapEncryptionContext :: (UTF8.Decode(k), UTF8.Decode(unwrapEncryptionContext[k]), k);
    :- Need(forall i: (Result<string, string>, Result<string, string>, ValidUTF8Bytes) {:trigger i.2} {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.Success? && i.1.Success? && _default.IsValid_AttributeName(Structure.ENCRYPTION_CONTEXT_PREFIX + i.0.value) && var encoded: Result<ValidUTF8Bytes, string> := UTF8.Encode(i.0.value); encoded.Success? && i.2 == encoded.value, Types.KeyStoreException(message := ErrorMessages.UTF8_ENCODING_ENCRYPTION_CONTEXT_ERROR));
    output := CreateKeys.CreateBranchAndBeaconKeys(branchKeyIdentifier, map i: (Result<string, string>, Result<string, string>, ValidUTF8Bytes) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.value := i.1.value, timestamp, branchKeyVersion, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate VersionKeyEnsuresPublicly(input: VersionKeyInput, output: Result<VersionKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method VersionKey(config: InternalConfig, input: VersionKeyInput) returns (output: Result<VersionKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures VersionKeyEnsuresPublicly(input, output)
    ensures true && !KO.HasKeyId(config.kmsConfiguration) ==> output.Failure?
    decreases ModifiesInternalConfig(config)
  {
    :- Need(KO.HasKeyId(config.kmsConfiguration), Types.KeyStoreException(message := ErrorMessages.DISCOVERY_VERSION_KEY_NOT_SUPPORTED));
    SequenceIsSafeBecauseItIsInMemory(input.branchKeyIdentifier);
    :- Need(0 < |input.branchKeyIdentifier| as uint64, Types.KeyStoreException(message := ErrorMessages.BRANCH_KEY_ID_NEEDED));
    var timestamp? := Time.GetCurrentTimeStamp();
    var timestamp :- timestamp?.MapFailure((e: string) => Types.KeyStoreException(message := e));
    var maybeBranchKeyVersion := UUID.GenerateUUID();
    var branchKeyVersion :- maybeBranchKeyVersion.MapFailure((e: string) => Types.KeyStoreException(message := e));
    output := CreateKeys.VersionActiveBranchKey(input, timestamp, branchKeyVersion, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetActiveBranchKeyEnsuresPublicly(input: GetActiveBranchKeyInput, output: Result<GetActiveBranchKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetActiveBranchKey(config: InternalConfig, input: GetActiveBranchKeyInput) returns (output: Result<GetActiveBranchKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetActiveBranchKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetActiveKeyAndUnwrap(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetBranchKeyVersionEnsuresPublicly(input: GetBranchKeyVersionInput, output: Result<GetBranchKeyVersionOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetBranchKeyVersion(config: InternalConfig, input: GetBranchKeyVersionInput) returns (output: Result<GetBranchKeyVersionOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBranchKeyVersionEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetBranchKeyVersion(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  predicate GetBeaconKeyEnsuresPublicly(input: GetBeaconKeyInput, output: Result<GetBeaconKeyOutput, Error>)
    decreases input, output
  {
    true
  }

  method GetBeaconKey(config: InternalConfig, input: GetBeaconKeyInput) returns (output: Result<GetBeaconKeyOutput, Error>)
    requires true && ValidInternalConfig?(config)
    modifies ModifiesInternalConfig(config)
    ensures true && ValidInternalConfig?(config)
    ensures GetBeaconKeyEnsuresPublicly(input, output)
    decreases ModifiesInternalConfig(config)
  {
    output := GetKeys.GetBeaconKeyAndUnwrap(input, config.ddbTableName, config.logicalKeyStoreName, config.kmsConfiguration, config.grantTokens, config.kmsClient, config.ddbClient);
  }

  import opened AwsKmsUtils

  import opened MemoryMath = StandardLibrary.MemoryMath

  import KO = KMSKeystoreOperations

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import MPL = AwsCryptographyMaterialProvidersTypes

  import CreateKeys

  import CreateKeyStoreTable

  import GetKeys

  import UUID

  import Time

  import Structure

  import ErrorMessages = KeyStoreErrorMessages

  import KmsArn

  datatype Config = Config(nameonly id: string, nameonly ddbTableName: DDB.TableName, nameonly logicalKeyStoreName: string, nameonly kmsConfiguration: KMSConfiguration, nameonly grantTokens: KMS.GrantTokenList, nameonly kmsClient: ComAmazonawsKmsTypes.IKMSClient, nameonly ddbClient: ComAmazonawsDynamodbTypes.IDynamoDBClient)

  type InternalConfig = Config

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened UTF8

  import opened Types = AwsCryptographyKeyStoreTypes
}

module {:options "/functionSyntax:4"} Structure {
  const BRANCH_KEY_IDENTIFIER_FIELD := "branch-key-id"
  const TYPE_FIELD := "type"
  const KEY_CREATE_TIME := "create-time"
  const HIERARCHY_VERSION := "hierarchy-version"
  const TABLE_FIELD := "tablename"
  const KMS_FIELD := "kms-arn"
  const BRANCH_KEY_FIELD := "enc"
  const BRANCH_KEY_ACTIVE_VERSION_FIELD := "version"
  const BRANCH_KEY_TYPE_PREFIX := "branch:version:"
  const BRANCH_KEY_ACTIVE_TYPE := "branch:ACTIVE"
  const BEACON_KEY_TYPE_VALUE := "beacon:ACTIVE"
  const ENCRYPTION_CONTEXT_PREFIX := "aws-crypto-ec:"

  predicate method BranchKeyContext?(m: map<string, string>)
    decreases m
  {
    BRANCH_KEY_IDENTIFIER_FIELD in m &&
    TYPE_FIELD in m &&
    KEY_CREATE_TIME in m &&
    HIERARCHY_VERSION in m &&
    TABLE_FIELD in m &&
    KMS_FIELD in m &&
    KMS.IsValid_KeyIdType(m[KMS_FIELD]) &&
    BRANCH_KEY_FIELD !in m.Keys &&
    (SequenceIsSafeBecauseItIsInMemory(m[BRANCH_KEY_IDENTIFIER_FIELD]); 0 < |m[BRANCH_KEY_IDENTIFIER_FIELD]| as uint64) &&
    (SequenceIsSafeBecauseItIsInMemory(m[TYPE_FIELD]); 0 < |m[TYPE_FIELD]| as uint64) &&
    (forall k: string {:trigger _default.IsValid_AttributeName(k)} {:trigger k in m.Keys} | k in m.Keys :: 
      _default.IsValid_AttributeName(k)) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m <==> true && m[TYPE_FIELD] == BRANCH_KEY_ACTIVE_TYPE) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m ==>
      true &&
      BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD]) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD !in m <==> m[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE || BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD])
  }

  function method ToAttributeMap(encryptionContext: BranchKeyContext, encryptedKey: seq<uint8>): (output: DDB.AttributeMap)
    requires KMS.IsValid_CiphertextType(encryptedKey)
    requires KMS.IsValid_KeyIdType(encryptionContext[KMS_FIELD])
    requires KmsArn.ValidKmsArn?(encryptionContext[KMS_FIELD])
    ensures BranchKeyItem?(output)
    ensures ToBranchKeyContext(output, encryptionContext[TABLE_FIELD]) == encryptionContext
    decreases encryptionContext, encryptedKey
  {
    map k: AttributeName {:trigger encryptionContext[k]} {:trigger k in encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD}} | k in encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD} :: k := if k == HIERARCHY_VERSION then DDB.AttributeValue.N(encryptionContext[HIERARCHY_VERSION]) else if k == BRANCH_KEY_FIELD then DDB.AttributeValue.B(encryptedKey) else DDB.AttributeValue.S(encryptionContext[k])
  }

  function method ToBranchKeyContext(item: DDB.AttributeMap, logicalKeyStoreName: string): (output: BranchKeyContext)
    requires BranchKeyItem?(item)
    decreases item, logicalKeyStoreName
  {
    map k: seq<char> {:trigger item[k]} {:trigger k in item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD}} | k in item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD} :: k := if k == HIERARCHY_VERSION then item[k].N else if k == TABLE_FIELD then logicalKeyStoreName else item[k].S
  }

  function method ToBranchKeyMaterials(encryptionContext: BranchKeyContext, plaintextKey: seq<uint8>): (output: Result<Types.BranchKeyMaterials, Types.Error>)
    requires encryptionContext[TYPE_FIELD] == BRANCH_KEY_ACTIVE_TYPE || BRANCH_KEY_TYPE_PREFIX < encryptionContext[TYPE_FIELD]
    ensures output.Success? ==> output.value.branchKey == plaintextKey && output.value.branchKeyIdentifier == encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD] && var versionInformation: seq<char> := if BRANCH_KEY_ACTIVE_VERSION_FIELD in encryptionContext then encryptionContext[BRANCH_KEY_ACTIVE_VERSION_FIELD] else encryptionContext[TYPE_FIELD]; BRANCH_KEY_TYPE_PREFIX < versionInformation && UTF8.Encode(versionInformation[|BRANCH_KEY_TYPE_PREFIX|..]).Success? && output.value.branchKeyVersion == UTF8.Encode(versionInformation[|BRANCH_KEY_TYPE_PREFIX|..]).value && ExtractCustomEncryptionContext(encryptionContext).Success? && output.value.encryptionContext == ExtractCustomEncryptionContext(encryptionContext).value && (forall k: seq<BoundedInts.uint8> {:trigger UTF8.Decode(k)} {:trigger k in output.value.encryptionContext} | k in output.value.encryptionContext :: UTF8.Decode(k).Success? && ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value in encryptionContext) && (forall k: seq<BoundedInts.uint8> {:trigger output.value.encryptionContext[k]} {:trigger k in output.value.encryptionContext} | k in output.value.encryptionContext :: UTF8.Decode(output.value.encryptionContext[k]).Success?) && forall k: seq<BoundedInts.uint8> {:trigger output.value.encryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value} {:trigger k in output.value.encryptionContext} | k in output.value.encryptionContext :: encryptionContext[ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value] == UTF8.Decode(output.value.encryptionContext[k]).value
    decreases encryptionContext, plaintextKey
  {
    var versionInformation: seq<char> := if BRANCH_KEY_ACTIVE_VERSION_FIELD in encryptionContext then encryptionContext[BRANCH_KEY_ACTIVE_VERSION_FIELD] else encryptionContext[TYPE_FIELD];
    var branchKeyVersion: seq<char> := versionInformation[|BRANCH_KEY_TYPE_PREFIX| as uint32..];
    var branchKeyVersionUtf8: ValidUTF8Bytes :- UTF8.Encode(branchKeyVersion).MapFailure((e: seq<char>) => Types.KeyStoreException(message := e)); var customEncryptionContext: Types.EncryptionContext :- ExtractCustomEncryptionContext(encryptionContext); Success(Types.BranchKeyMaterials(branchKeyIdentifier := encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD], branchKeyVersion := branchKeyVersionUtf8, branchKey := plaintextKey, encryptionContext := customEncryptionContext))
  }

  function method ToBeaconKeyMaterials(encryptionContext: BranchKeyContext, plaintextKey: seq<uint8>): (output: Result<Types.BeaconKeyMaterials, Types.Error>)
    requires encryptionContext[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE
    decreases encryptionContext, plaintextKey
  {
    var customEncryptionContext: Types.EncryptionContext :- ExtractCustomEncryptionContext(encryptionContext); Success(Types.BeaconKeyMaterials(beaconKeyIdentifier := encryptionContext[BRANCH_KEY_IDENTIFIER_FIELD], beaconKey := Some(plaintextKey), hmacKeys := None, encryptionContext := customEncryptionContext))
  }

  function method ExtractCustomEncryptionContext(encryptionContext: BranchKeyContext): (output: Result<Types.EncryptionContext, Types.Error>)
    ensures output.Success? ==> (forall k: seq<BoundedInts.uint8> {:trigger UTF8.Decode(k)} {:trigger k in output.value} | k in output.value :: UTF8.Decode(k).Success? && ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value in encryptionContext) && (forall k: seq<BoundedInts.uint8> {:trigger output.value[k]} {:trigger k in output.value} | k in output.value :: UTF8.Decode(output.value[k]).Success?) && forall k: seq<BoundedInts.uint8> {:trigger output.value[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value} {:trigger k in output.value} | k in output.value :: encryptionContext[ENCRYPTION_CONTEXT_PREFIX + UTF8.Decode(k).value] == UTF8.Decode(output.value[k]).value
    decreases encryptionContext
  {
    var prefixKeys: set<seq<char>> := set k: seq<char> {:trigger k in encryptionContext.Keys} | k in encryptionContext.Keys && ENCRYPTION_CONTEXT_PREFIX <= k;
    assert forall k: seq<char> {:trigger k[|ENCRYPTION_CONTEXT_PREFIX|..]} {:trigger k in prefixKeys} | k in prefixKeys :: k == ENCRYPTION_CONTEXT_PREFIX + k[|ENCRYPTION_CONTEXT_PREFIX|..];
    var encodedEncryptionContext: set<(Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>)> := set k: seq<char> {:trigger encryptionContext[k]} {:trigger k in prefixKeys} | k in prefixKeys :: (UTF8.Encode(k[|ENCRYPTION_CONTEXT_PREFIX| as uint32..]), UTF8.Encode(encryptionContext[k]));
    :- Need(forall i: (Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.Success? && i.1.Success?, Types.KeyStoreException(message := "Unable to encode string")); Success(map i: (Result<ValidUTF8Bytes, seq<char>>, Result<ValidUTF8Bytes, seq<char>>) {:trigger i.1} {:trigger i.0} {:trigger i in encodedEncryptionContext} | i in encodedEncryptionContext :: i.0.value := i.1.value)
  }

  opaque function method DecryptOnlyBranchKeyEncryptionContext(branchKeyId: string, branchKeyVersion: string, timestamp: string, logicalKeyStoreName: string, kmsKeyArn: string, customEncryptionContext: map<string, string>): (output: map<string, string>)
    requires 0 < |branchKeyId|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: _default.IsValid_AttributeName(ENCRYPTION_CONTEXT_PREFIX + k)
    requires KMS.IsValid_KeyIdType(kmsKeyArn)
    requires AwsArnParsing.ParseAwsKmsArn(kmsKeyArn).Success?
    requires KmsArn.ValidKmsArn?(kmsKeyArn)
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_TYPE_PREFIX < output[TYPE_FIELD]
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD !in output
    ensures output[KMS_FIELD] == kmsKeyArn
    ensures output[TABLE_FIELD] == logicalKeyStoreName
    ensures forall k: seq<char> {:trigger customEncryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k in output && output[ENCRYPTION_CONTEXT_PREFIX + k] == customEncryptionContext[k]
    decreases branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, customEncryptionContext
  {
    assert forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext.Keys} | k in customEncryptionContext.Keys :: k == (ENCRYPTION_CONTEXT_PREFIX + k)[|ENCRYPTION_CONTEXT_PREFIX|..];
    map[BRANCH_KEY_IDENTIFIER_FIELD := branchKeyId, TYPE_FIELD := BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, KEY_CREATE_TIME := timestamp, TABLE_FIELD := logicalKeyStoreName, KMS_FIELD := kmsKeyArn, HIERARCHY_VERSION := "1"] + map k: seq<char> {:trigger customEncryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k := customEncryptionContext[k]
  }

  function method ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext: map<string, string>): (output: map<string, string>)
    requires BranchKeyContext?(decryptOnlyEncryptionContext)
    requires BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[TYPE_FIELD] && BRANCH_KEY_ACTIVE_VERSION_FIELD !in decryptOnlyEncryptionContext
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD in output
    decreases decryptOnlyEncryptionContext
  {
    decryptOnlyEncryptionContext + map[BRANCH_KEY_ACTIVE_VERSION_FIELD := decryptOnlyEncryptionContext[TYPE_FIELD], TYPE_FIELD := BRANCH_KEY_ACTIVE_TYPE]
  }

  function method BeaconKeyEncryptionContext(decryptOnlyEncryptionContext: map<string, string>): (output: map<string, string>)
    requires BranchKeyContext?(decryptOnlyEncryptionContext)
    requires BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[TYPE_FIELD] && BRANCH_KEY_ACTIVE_VERSION_FIELD !in decryptOnlyEncryptionContext
    ensures BranchKeyContext?(output)
    ensures output[TYPE_FIELD] == BEACON_KEY_TYPE_VALUE
    decreases decryptOnlyEncryptionContext
  {
    decryptOnlyEncryptionContext + map[TYPE_FIELD := BEACON_KEY_TYPE_VALUE]
  }

  function method NewVersionFromActiveBranchKeyEncryptionContext(activeBranchKeyEncryptionContext: map<string, string>, branchKeyVersion: string, timestamp: string): (output: map<string, string>)
    requires BranchKeyContext?(activeBranchKeyEncryptionContext)
    requires BRANCH_KEY_ACTIVE_VERSION_FIELD in activeBranchKeyEncryptionContext
    requires 0 < |branchKeyVersion|
    ensures BranchKeyContext?(output)
    ensures BRANCH_KEY_TYPE_PREFIX < output[TYPE_FIELD]
    ensures BRANCH_KEY_ACTIVE_VERSION_FIELD !in output
    decreases activeBranchKeyEncryptionContext, branchKeyVersion, timestamp
  {
    activeBranchKeyEncryptionContext + map[TYPE_FIELD := BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, KEY_CREATE_TIME := timestamp] - {BRANCH_KEY_ACTIVE_VERSION_FIELD}
  }

  predicate method BranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BRANCH_KEY_IDENTIFIER_FIELD in m &&
    m[BRANCH_KEY_IDENTIFIER_FIELD].S? &&
    TYPE_FIELD in m &&
    m[TYPE_FIELD].S? &&
    KEY_CREATE_TIME in m &&
    m[KEY_CREATE_TIME].S? &&
    HIERARCHY_VERSION in m &&
    m[HIERARCHY_VERSION].N? &&
    TABLE_FIELD !in m &&
    KMS_FIELD in m &&
    m[KMS_FIELD].S? &&
    KMS.IsValid_KeyIdType(m[KMS_FIELD].S) &&
    BRANCH_KEY_FIELD in m &&
    m[BRANCH_KEY_FIELD].B? &&
    (SequenceIsSafeBecauseItIsInMemory(m[BRANCH_KEY_IDENTIFIER_FIELD].S); 0 < |m[BRANCH_KEY_IDENTIFIER_FIELD].S| as uint64) &&
    (SequenceIsSafeBecauseItIsInMemory(m[TYPE_FIELD].S); 0 < |m[TYPE_FIELD].S| as uint64) &&
    (forall k: seq<char> {:trigger m[k]} {:trigger k in m.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION}} | k in m.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION} :: 
      m[k].S?) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m <==> true && m[TYPE_FIELD].S == BRANCH_KEY_ACTIVE_TYPE) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD in m ==>
      true &&
      BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S) &&
    (BRANCH_KEY_ACTIVE_VERSION_FIELD !in m <==> m[TYPE_FIELD].S == BEACON_KEY_TYPE_VALUE || BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD].S) &&
    KMS.IsValid_CiphertextType(m[BRANCH_KEY_FIELD].B)
  }

  predicate method ActiveBranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    m[TYPE_FIELD].S == BRANCH_KEY_ACTIVE_TYPE &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD in m &&
    m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S? &&
    BRANCH_KEY_TYPE_PREFIX < m[BRANCH_KEY_ACTIVE_VERSION_FIELD].S
  }

  predicate method VersionBranchKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD !in m &&
    BRANCH_KEY_TYPE_PREFIX < m[TYPE_FIELD].S
  }

  predicate method BeaconKeyItem?(m: DDB.AttributeMap)
    decreases m
  {
    BranchKeyItem?(m) &&
    BRANCH_KEY_ACTIVE_VERSION_FIELD !in m &&
    m[TYPE_FIELD].S == BEACON_KEY_TYPE_VALUE
  }

  lemma BranchKeyItemsDoNotCollide(a: ActiveBranchKeyItem, b: VersionBranchKeyItem, c: BeaconKeyItem)
    requires a[BRANCH_KEY_IDENTIFIER_FIELD] == b[BRANCH_KEY_IDENTIFIER_FIELD] == c[BRANCH_KEY_IDENTIFIER_FIELD]
    ensures a[TYPE_FIELD] != b[TYPE_FIELD]
    ensures a[TYPE_FIELD] != c[TYPE_FIELD]
    ensures c[TYPE_FIELD] != b[TYPE_FIELD]
    decreases a, b, c
  {
  }

  lemma ToAttributeMapIsCorrect(encryptionContext: BranchKeyContext, encryptedKey: seq<uint8>, item: DDB.AttributeMap)
    requires KMS.IsValid_CiphertextType(encryptedKey)
    requires KMS.IsValid_KeyIdType(encryptionContext[KMS_FIELD])
    requires KmsArn.ValidKmsArn?(encryptionContext[KMS_FIELD])
    requires item == ToAttributeMap(encryptionContext, encryptedKey)
    ensures item.Keys == encryptionContext.Keys + {BRANCH_KEY_FIELD} - {TABLE_FIELD}
    ensures item[BRANCH_KEY_FIELD].B == encryptedKey
    ensures (forall k: seq<char> {:trigger encryptionContext[k]} {:trigger item[k]} {:trigger k in item.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION}} | k in item.Keys - {BRANCH_KEY_FIELD, HIERARCHY_VERSION} :: item[k].S? && encryptionContext[k] == item[k].S) && encryptionContext[HIERARCHY_VERSION] == item[HIERARCHY_VERSION].N
    decreases encryptionContext, encryptedKey, item
  {
  }

  lemma ToBranchKeyContextIsCorrect(encryptionContext: map<string, string>, logicalKeyStoreName: string, item: DDB.AttributeMap)
    requires BranchKeyItem?(item)
    requires encryptionContext == ToBranchKeyContext(item, logicalKeyStoreName)
    ensures encryptionContext.Keys == item.Keys - {BRANCH_KEY_FIELD} + {TABLE_FIELD}
    ensures encryptionContext[TABLE_FIELD] == logicalKeyStoreName
    ensures forall k: seq<char> {:trigger item[k]} {:trigger encryptionContext[k]} {:trigger k in encryptionContext.Keys - {BRANCH_KEY_FIELD, TABLE_FIELD}} | k in encryptionContext.Keys - {BRANCH_KEY_FIELD, TABLE_FIELD} :: if k == HIERARCHY_VERSION then encryptionContext[k] == item[k].N else encryptionContext[k] == item[k].S
    ensures BRANCH_KEY_FIELD !in encryptionContext
    decreases encryptionContext, logicalKeyStoreName, item
  {
  }

  lemma EncryptionContextConstructorsAreCorrect(branchKeyId: string, branchKeyVersion: string, timestamp: string, logicalKeyStoreName: string, kmsKeyArn: string, encryptionContext: map<string, string>)
    requires 0 < |branchKeyId|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in encryptionContext} | k in encryptionContext :: _default.IsValid_AttributeName(ENCRYPTION_CONTEXT_PREFIX + k)
    requires KMS.IsValid_KeyIdType(kmsKeyArn) && AwsArnParsing.ParseAwsKmsArn(kmsKeyArn).Success?
    requires KmsArn.ValidKmsArn?(kmsKeyArn)
    ensures ghost var decryptOnly: map<string, string> := DecryptOnlyBranchKeyEncryptionContext(branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, encryptionContext); ghost var active: map<string, string> := ActiveBranchKeyEncryptionContext(decryptOnly); ghost var beacon: map<string, string> := BeaconKeyEncryptionContext(decryptOnly); decryptOnly[TYPE_FIELD] != active[TYPE_FIELD] && decryptOnly[TYPE_FIELD] != beacon[TYPE_FIELD] && active[TYPE_FIELD] != beacon[TYPE_FIELD] && (forall k: seq<char> {:trigger beacon[k]} {:trigger active[k]} {:trigger decryptOnly[k]} {:trigger k in decryptOnly.Keys - {TYPE_FIELD}} | k in decryptOnly.Keys - {TYPE_FIELD} :: decryptOnly[k] == active[k] && active[k] == beacon[k]) && active[BRANCH_KEY_ACTIVE_VERSION_FIELD] == decryptOnly[TYPE_FIELD] && forall k: seq<char> {:trigger encryptionContext[k]} {:trigger ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in encryptionContext} | k in encryptionContext :: ENCRYPTION_CONTEXT_PREFIX + k in decryptOnly && ENCRYPTION_CONTEXT_PREFIX + k in active && ENCRYPTION_CONTEXT_PREFIX + k in beacon && encryptionContext[k] == decryptOnly[ENCRYPTION_CONTEXT_PREFIX + k] && decryptOnly[ENCRYPTION_CONTEXT_PREFIX + k] == active[ENCRYPTION_CONTEXT_PREFIX + k] && active[ENCRYPTION_CONTEXT_PREFIX + k] == beacon[ENCRYPTION_CONTEXT_PREFIX + k]
    decreases branchKeyId, branchKeyVersion, timestamp, logicalKeyStoreName, kmsKeyArn, encryptionContext
  {
    reveal DecryptOnlyBranchKeyEncryptionContext();
  }

  lemma ToAttributeMapAndToBranchKeyContextAreInverse(encryptionContext: map<string, string>, item: DDB.AttributeMap)
    requires BranchKeyItem?(item) && BranchKeyContext?(encryptionContext)
    requires KmsArn.ValidKmsArn?(encryptionContext[KMS_FIELD])
    ensures item == ToAttributeMap(encryptionContext, item[BRANCH_KEY_FIELD].B) <==> ToBranchKeyContext(item, encryptionContext[TABLE_FIELD]) == encryptionContext
    decreases encryptionContext, item
  {
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import AwsArnParsing

  import KmsArn

  type BranchKeyContext = m: map<string, string>
    | BranchKeyContext?(m)
    witness *

  type BranchKeyItem = m: DDB.AttributeMap
    | BranchKeyItem?(m)
    witness *

  type ActiveBranchKeyItem = m: DDB.AttributeMap
    | ActiveBranchKeyItem?(m)
    witness *

  type VersionBranchKeyItem = m: DDB.AttributeMap
    | VersionBranchKeyItem?(m)
    witness *

  type BeaconKeyItem = m: DDB.AttributeMap
    | BeaconKeyItem?(m)
    witness *
}

module {:options "/functionSyntax:4"} CreateKeys {
  method {:vcs_split_on_every_assert} CreateBranchAndBeaconKeys(branchKeyIdentifier: string, customEncryptionContext: map<string, string>, timestamp: string, branchKeyVersion: string, ddbTableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.CreateKeyOutput, Types.Error>)
    requires 0 < |branchKeyIdentifier|
    requires 0 < |branchKeyVersion|
    requires forall k: seq<char> {:trigger Structure.ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: _default.IsValid_AttributeName(Structure.ENCRYPTION_CONTEXT_PREFIX + k)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires KMSKeystoreOperations.HasKeyId(kmsConfiguration) && KmsArn.ValidKmsArn?(KMSKeystoreOperations.GetKeyId(kmsConfiguration))
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures output.Success? ==> |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 2 && |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && var decryptOnlyEncryptionContext: map<string, string> := Structure.DecryptOnlyBranchKeyEncryptionContext(branchKeyIdentifier, branchKeyVersion, timestamp, logicalKeyStoreName, KMSKeystoreOperations.GetKeyId(kmsConfiguration), customEncryptionContext); decryptOnlyEncryptionContext[Structure.TABLE_FIELD] == logicalKeyStoreName && WrappedBranchKeyCreation?(Seq.Last(Seq.DropLast(kmsClient.History.GenerateDataKeyWithoutPlaintext)), Seq.Last(kmsClient.History.ReEncrypt), kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext) && var beaconKmsInput: GenerateDataKeyWithoutPlaintextRequest := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).input; KMSKeystoreOperations.Compatible?(kmsConfiguration, beaconKmsInput.KeyId) && beaconKmsInput.NumberOfBytes == Some(32) && beaconKmsInput.EncryptionContext == Some(Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext)) && beaconKmsInput.GrantTokens == Some(grantTokens) && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Success? && var beaconKmsOutput: GenerateDataKeyWithoutPlaintextResponse := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.value; beaconKmsOutput.CiphertextBlob.Some? && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && var writeNewKey: TransactWriteItemsInput := Seq.Last(ddbClient.History.TransactWriteItems).input; 3 == |writeNewKey.TransactItems| && (forall k: seq<char> {:trigger customEncryptionContext[k]} {:trigger Structure.ENCRYPTION_CONTEXT_PREFIX + k} {:trigger k in customEncryptionContext} | k in customEncryptionContext :: Structure.ENCRYPTION_CONTEXT_PREFIX + k in decryptOnlyEncryptionContext && decryptOnlyEncryptionContext[Structure.ENCRYPTION_CONTEXT_PREFIX + k] == customEncryptionContext[k]) && writeNewKey.TransactItems[0].Put.Some? && writeNewKey.TransactItems[0].Put.value.Item == Structure.ToAttributeMap(decryptOnlyEncryptionContext, Seq.Last(Seq.DropLast(kmsClient.History.GenerateDataKeyWithoutPlaintext)).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[1].Put.Some? && writeNewKey.TransactItems[1].Put.value.Item == Structure.ToAttributeMap(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext), Seq.Last(kmsClient.History.ReEncrypt).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[2].Put.Some? && writeNewKey.TransactItems[2].Put.value.Item == Structure.ToAttributeMap(Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext), beaconKmsOutput.CiphertextBlob.value) && Seq.Last(ddbClient.History.TransactWriteItems).output.Success? && output.value.branchKeyIdentifier == branchKeyIdentifier
    ensures (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 2 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?)
    decreases branchKeyIdentifier, customEncryptionContext, timestamp, branchKeyVersion, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var decryptOnlyEncryptionContext := Structure.DecryptOnlyBranchKeyEncryptionContext(branchKeyIdentifier, branchKeyVersion, timestamp, logicalKeyStoreName, KMSKeystoreOperations.GetKeyId(kmsConfiguration), customEncryptionContext);
    var activeEncryptionContext := Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext);
    var beaconEncryptionContext := Structure.BeaconKeyEncryptionContext(decryptOnlyEncryptionContext);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, decryptOnlyEncryptionContext), Types.KeyStoreException(message := "Invalid KMS Key ARN configured for GenerateDataKeyWithoutPlaintext in CreateBranchAndBeaconKeys."));
    var wrappedDecryptOnlyBranchKey :- KMSKeystoreOperations.GenerateKey(decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, activeEncryptionContext), Types.KeyStoreException(message := "Invalid KMS Key ARN configured for ReEncrypt in CreateBranchAndBeaconKeys."));
    var wrappedActiveBranchKey :- KMSKeystoreOperations.ReEncryptKey(wrappedDecryptOnlyBranchKey.CiphertextBlob.value, decryptOnlyEncryptionContext, activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, beaconEncryptionContext), Types.KeyStoreException(message := "Invalid KMS Key ARN configured for GenerateDataKeyWithoutPlaintext(beacon key) in CreateBranchAndBeaconKeys."));
    var wrappedBeaconKey :- KMSKeystoreOperations.GenerateKey(beaconEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyBranchKeyItem := Structure.ToAttributeMap(decryptOnlyEncryptionContext, wrappedDecryptOnlyBranchKey.CiphertextBlob.value);
    var activeBranchKeyItem := Structure.ToAttributeMap(activeEncryptionContext, wrappedActiveBranchKey.CiphertextBlob.value);
    var beaconKeyItem := Structure.ToAttributeMap(beaconEncryptionContext, wrappedBeaconKey.CiphertextBlob.value);
    var _ /* _v0 */ :- DDBKeystoreOperations.WriteNewKeyToStore(decryptOnlyBranchKeyItem, activeBranchKeyItem, beaconKeyItem, ddbTableName, ddbClient);
    output := Success(Types.CreateKeyOutput(branchKeyIdentifier := branchKeyIdentifier));
  }

  method VersionActiveBranchKey(input: Types.VersionKeyInput, timestamp: string, branchKeyVersion: string, ddbTableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.VersionKeyOutput, Types.Error>)
    requires 0 < |input.branchKeyIdentifier| && 0 < |branchKeyVersion|
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires KMSKeystoreOperations.HasKeyId(kmsConfiguration) && KmsArn.ValidKmsArn?(KMSKeystoreOperations.GetKeyId(kmsConfiguration))
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures output.Success? ==> |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)] && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var oldActiveItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(oldActiveItem) && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD in oldActiveItem && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && Structure.KMS_FIELD in oldActiveItem && KMSKeystoreOperations.Compatible?(kmsConfiguration, oldActiveItem[Structure.KMS_FIELD].S) && |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 2 && var reEncryptInput: ReEncryptRequest := Seq.Last(Seq.DropLast(kmsClient.History.ReEncrypt)).input; reEncryptInput.SourceEncryptionContext == Some(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && KMSKeystoreOperations.OptCompatible?(kmsConfiguration, reEncryptInput.SourceKeyId) && reEncryptInput.CiphertextBlob == oldActiveItem[Structure.BRANCH_KEY_FIELD].B && reEncryptInput.GrantTokens == Some(grantTokens) && KMSKeystoreOperations.Compatible?(kmsConfiguration, reEncryptInput.DestinationKeyId) && reEncryptInput.DestinationEncryptionContext == Some(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName)) && |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && var decryptOnlyEncryptionContext: map<string, string> := Structure.NewVersionFromActiveBranchKeyEncryptionContext(Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName), branchKeyVersion, timestamp); WrappedBranchKeyCreation?(Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext), Seq.Last(kmsClient.History.ReEncrypt), kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext) && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && var writeNewKey: TransactWriteItemsInput := Seq.Last(ddbClient.History.TransactWriteItems).input; 2 == |writeNewKey.TransactItems| && writeNewKey.TransactItems[0].Put.Some? && writeNewKey.TransactItems[0].Put.value.Item == Structure.ToAttributeMap(decryptOnlyEncryptionContext, Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.value.CiphertextBlob.value) && writeNewKey.TransactItems[1].Put.Some? && writeNewKey.TransactItems[1].Put.value.Item == Structure.ToAttributeMap(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext), Seq.Last(kmsClient.History.ReEncrypt).output.value.CiphertextBlob.value) && Seq.Last(ddbClient.History.TransactWriteItems).output.Success? && output == Success(Types.VersionKeyOutput)
    ensures (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output.Failure? ==> output.Failure?) || (|kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 2 && Seq.Last(kmsClient.History.ReEncrypt).output.Failure? ==> output.Failure?) || (|ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?)
    decreases input, timestamp, branchKeyVersion, ddbTableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var oldActiveItem :- DDBKeystoreOperations.GetActiveBranchKeyItem(input.branchKeyIdentifier, ddbTableName, ddbClient);
    var oldActiveEncryptionContext := Structure.ToBranchKeyContext(oldActiveItem, logicalKeyStoreName);
    :- Need(true && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, oldActiveEncryptionContext), Types.KeyStoreException(message := ErrorMessages.VERSION_KEY_KMS_KEY_ARN_DISAGREEMENT));
    var _ /* _v1 */ :- KMSKeystoreOperations.ReEncryptKey(oldActiveItem[Structure.BRANCH_KEY_FIELD].B, oldActiveEncryptionContext, oldActiveEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyEncryptionContext := Structure.NewVersionFromActiveBranchKeyEncryptionContext(oldActiveEncryptionContext, branchKeyVersion, timestamp);
    var activeEncryptionContext := Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext);
    assert KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, decryptOnlyEncryptionContext);
    var wrappedDecryptOnlyBranchKey :- KMSKeystoreOperations.GenerateKey(decryptOnlyEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var wrappedActiveBranchKey :- KMSKeystoreOperations.ReEncryptKey(wrappedDecryptOnlyBranchKey.CiphertextBlob.value, decryptOnlyEncryptionContext, activeEncryptionContext, kmsConfiguration, grantTokens, kmsClient);
    var decryptOnlyBranchKeyItem: Structure.VersionBranchKeyItem := Structure.ToAttributeMap(decryptOnlyEncryptionContext, wrappedDecryptOnlyBranchKey.CiphertextBlob.value);
    var activeBranchKeyItem: Structure.ActiveBranchKeyItem := Structure.ToAttributeMap(activeEncryptionContext, wrappedActiveBranchKey.CiphertextBlob.value);
    var _ /* _v2 */ :- DDBKeystoreOperations.WriteNewBranchKeyVersionToKeystore(decryptOnlyBranchKeyItem, activeBranchKeyItem, ddbTableName, ddbClient);
    assert true && |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1;
    output := Success(Types.VersionKeyOutput());
  }

  predicate WrappedBranchKeyCreation?(generateHistory: KMS.DafnyCallEvent<KMS.GenerateDataKeyWithoutPlaintextRequest, Result<KMS.GenerateDataKeyWithoutPlaintextResponse, KMS.Error>>, reEncryptHistory: KMS.DafnyCallEvent<KMS.ReEncryptRequest, Result<KMS.ReEncryptResponse, KMS.Error>>, kmsClient: KMS.IKMSClient, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, decryptOnlyEncryptionContext: map<string, string>)
    requires KMSKeystoreOperations.HasKeyId(kmsConfiguration) && KmsArn.ValidKmsArn?(KMSKeystoreOperations.GetKeyId(kmsConfiguration))
    requires Structure.BranchKeyContext?(decryptOnlyEncryptionContext)
    requires Structure.BRANCH_KEY_TYPE_PREFIX < decryptOnlyEncryptionContext[Structure.TYPE_FIELD]
    requires generateHistory in kmsClient.History.GenerateDataKeyWithoutPlaintext
    requires reEncryptHistory in kmsClient.History.ReEncrypt
    reads kmsClient.History
    decreases {kmsClient.History}, generateHistory, reEncryptHistory, kmsClient, kmsConfiguration, grantTokens, decryptOnlyEncryptionContext
  {
    true &&
    ghost var decryptOnlyKmsInput: KMS.GenerateDataKeyWithoutPlaintextRequest := generateHistory.input; KMSKeystoreOperations.Compatible?(kmsConfiguration, decryptOnlyKmsInput.KeyId) && decryptOnlyKmsInput.NumberOfBytes == Some(32) && decryptOnlyKmsInput.EncryptionContext == Some(decryptOnlyEncryptionContext) && decryptOnlyKmsInput.GrantTokens == Some(grantTokens) && generateHistory.output.Success? && generateHistory.output.value.CiphertextBlob.Some? && ghost var activeInput: KMS.ReEncryptRequest := reEncryptHistory.input; KMSKeystoreOperations.OptCompatible?(kmsConfiguration, activeInput.SourceKeyId) && KMSKeystoreOperations.Compatible?(kmsConfiguration, activeInput.DestinationKeyId) && activeInput.GrantTokens == Some(grantTokens) && activeInput.CiphertextBlob == generateHistory.output.value.CiphertextBlob.value && activeInput.SourceEncryptionContext == Some(decryptOnlyEncryptionContext) && activeInput.DestinationEncryptionContext == Some(Structure.ActiveBranchKeyEncryptionContext(decryptOnlyEncryptionContext)) && reEncryptHistory.output.Success? && reEncryptHistory.output.value.CiphertextBlob.Some?
  }

  import opened StandardLibrary

  import opened Wrappers

  import Structure

  import KMSKeystoreOperations

  import DDBKeystoreOperations

  import ErrorMessages = KeyStoreErrorMessages

  import opened Seq

  import opened UInt = StandardLibrary.UInt

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import AwsArnParsing

  import KmsArn
}

module {:options "/functionSyntax:4"} KMSKeystoreOperations {
  function method replaceRegion(arn: KMS.KeyIdType, region: KMS.RegionType): KMS.KeyIdType
    decreases arn, region
  {
    var parsed: Result<AwsKmsArn, string> := ParseAwsKmsArn(arn);
    if parsed.Failure? then
      arn
    else if !IsMultiRegionAwsKmsArn(parsed.value) then
      arn
    else
      var newArn: string := parsed.value.ToArnString(Some(region)); if KMS.IsValid_KeyIdType(newArn) then newArn else arn
  }

  function method GetArn(kmsConfiguration: Types.KMSConfiguration, discoverdArn: KMS.KeyIdType): KMS.KeyIdType
    decreases kmsConfiguration, discoverdArn
  {
    match kmsConfiguration {
      case kmsKeyArn(arn) =>
        arn
      case kmsMRKeyArn(arn) =>
        arn
      case discovery(obj) =>
        discoverdArn
      case mrDiscovery(region) =>
        replaceRegion(discoverdArn, region.region)
    }
  }

  predicate method AttemptKmsOperation?(kmsConfiguration: Types.KMSConfiguration, encryptionContext: Structure.BranchKeyContext)
    ensures AttemptKmsOperation?(kmsConfiguration, encryptionContext) && HasKeyId(kmsConfiguration) ==> Compatible?(kmsConfiguration, encryptionContext[Structure.KMS_FIELD])
    decreases kmsConfiguration, encryptionContext
  {
    match kmsConfiguration
    case kmsKeyArn(arn) =>
      arn == encryptionContext[Structure.KMS_FIELD] &&
      KmsArn.ValidKmsArn?(arn)
    case kmsMRKeyArn(arn) =>
      MrkMatch(arn, encryptionContext[Structure.KMS_FIELD]) &&
      KmsArn.ValidKmsArn?(arn)
    case discovery(obj) =>
      KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD])
    case mrDiscovery(obj) =>
      KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD])
  }

  predicate method Compatible?(kmsConfiguration: Types.KMSConfiguration, keyId: string)
    requires HasKeyId(kmsConfiguration)
    decreases kmsConfiguration, keyId
  {
    match kmsConfiguration
    case kmsKeyArn(arn) =>
      arn == keyId
    case kmsMRKeyArn(arn) =>
      MrkMatch(arn, keyId)
  }

  predicate method OptCompatible?(kmsConfiguration: Types.KMSConfiguration, keyId: Option<string>)
    requires HasKeyId(kmsConfiguration)
    decreases kmsConfiguration, keyId
  {
    keyId.Some? &&
    Compatible?(kmsConfiguration, keyId.value)
  }

  predicate method MrkMatch(x: string, y: string)
    decreases x, y
  {
    var xArn: Result<AwsKmsArn, string> := ParseAwsKmsArn(x);
    var yArn: Result<AwsKmsArn, string> := ParseAwsKmsArn(y);
    if xArn.Failure? || yArn.Failure? then
      false
    else
      AwsKmsMrkMatchForDecrypt.AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(xArn.value), AwsKmsArnIdentifier(yArn.value))
  }

  predicate method HasKeyId(kmsConfiguration: Types.KMSConfiguration)
    decreases kmsConfiguration
  {
    kmsConfiguration.kmsKeyArn? || kmsConfiguration.kmsMRKeyArn?
  }

  function method GetKeyId(kmsConfiguration: Types.KMSConfiguration): KMS.KeyIdType
    requires HasKeyId(kmsConfiguration)
    decreases kmsConfiguration
  {
    match kmsConfiguration
    case kmsKeyArn(arn) =>
      arn
    case kmsMRKeyArn(arn) =>
      arn
  }

  method GenerateKey(encryptionContext: Structure.BranchKeyContext, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (res: Result<KMS.GenerateDataKeyWithoutPlaintextResponse, Types.Error>)
    requires kmsClient.ValidState()
    requires HasKeyId(kmsConfiguration) && KmsArn.ValidKmsArn?(GetKeyId(kmsConfiguration))
    requires AttemptKmsOperation?(kmsConfiguration, encryptionContext)
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.GenerateDataKeyWithoutPlaintext| == |old(kmsClient.History.GenerateDataKeyWithoutPlaintext)| + 1 && var kmsKeyArn: KMS.KeyIdType := GetKeyId(kmsConfiguration); KMS.GenerateDataKeyWithoutPlaintextRequest(KeyId := kmsKeyArn, EncryptionContext := Some(encryptionContext), KeySpec := None, NumberOfBytes := Some(32), GrantTokens := Some(grantTokens)) == Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).input && old(kmsClient.History.GenerateDataKeyWithoutPlaintext) < kmsClient.History.GenerateDataKeyWithoutPlaintext && old(kmsClient.History.ReEncrypt) == kmsClient.History.ReEncrypt
    ensures res.Success? ==> res.value.KeyId.Some? && res.value.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(res.value.CiphertextBlob.value) && var kmsOperationOutput: Result<GenerateDataKeyWithoutPlaintextResponse, Error> := Seq.Last(kmsClient.History.GenerateDataKeyWithoutPlaintext).output; kmsOperationOutput.Success? && kmsOperationOutput.value == res.value
    decreases encryptionContext, kmsConfiguration, grantTokens, kmsClient
  {
    var kmsKeyArn := GetKeyId(kmsConfiguration);
    var generatorRequest := KMS.GenerateDataKeyWithoutPlaintextRequest(KeyId := kmsKeyArn, EncryptionContext := Some(encryptionContext), KeySpec := None, NumberOfBytes := Some(32), GrantTokens := Some(grantTokens));
    var maybeGenerateResponse := kmsClient.GenerateDataKeyWithoutPlaintext(generatorRequest);
    var generateResponse :- maybeGenerateResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(true && generateResponse.KeyId.Some?, Types.KeyStoreException(message := "Invalid response from KMS GenerateDataKey:: Invalid Key Id"));
    :- Need(generateResponse.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(generateResponse.CiphertextBlob.value), Types.KeyStoreException(message := "Invalid response from AWS KMS GenerateDataKey: Invalid ciphertext"));
    return Success(generateResponse);
  }

  method ReEncryptKey(ciphertext: seq<uint8>, sourceEncryptionContext: Structure.BranchKeyContext, destinationEncryptionContext: Structure.BranchKeyContext, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (res: Result<KMS.ReEncryptResponse, Types.Error>)
    requires KMS.IsValid_CiphertextType(ciphertext)
    requires destinationEncryptionContext == sourceEncryptionContext || (Structure.BRANCH_KEY_TYPE_PREFIX < sourceEncryptionContext[Structure.TYPE_FIELD] && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in sourceEncryptionContext && destinationEncryptionContext == Structure.ActiveBranchKeyEncryptionContext(sourceEncryptionContext))
    requires AttemptKmsOperation?(kmsConfiguration, destinationEncryptionContext)
    requires HasKeyId(kmsConfiguration) && KmsArn.ValidKmsArn?(GetKeyId(kmsConfiguration))
    requires kmsClient.ValidState()
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.ReEncrypt| == |old(kmsClient.History.ReEncrypt)| + 1 && var kmsKeyArn: KMS.KeyIdType := GetKeyId(kmsConfiguration); KMS.ReEncryptRequest(CiphertextBlob := ciphertext, SourceEncryptionContext := Some(sourceEncryptionContext), SourceKeyId := Some(kmsKeyArn), DestinationKeyId := kmsKeyArn, DestinationEncryptionContext := Some(destinationEncryptionContext), SourceEncryptionAlgorithm := None, DestinationEncryptionAlgorithm := None, GrantTokens := Some(grantTokens)) == Seq.Last(kmsClient.History.ReEncrypt).input && old(kmsClient.History.ReEncrypt) < kmsClient.History.ReEncrypt && old(kmsClient.History.GenerateDataKeyWithoutPlaintext) == kmsClient.History.GenerateDataKeyWithoutPlaintext
    ensures res.Success? ==> true && var kmsKeyArn: KMS.KeyIdType := GetKeyId(kmsConfiguration); res.value.CiphertextBlob.Some? && res.value.SourceKeyId.Some? && res.value.KeyId.Some? && res.value.SourceKeyId.value == kmsKeyArn && res.value.KeyId.value == kmsKeyArn && KMS.IsValid_CiphertextType(res.value.CiphertextBlob.value) && var kmsOperationOutput: Result<ReEncryptResponse, Error> := Seq.Last(kmsClient.History.ReEncrypt).output; kmsOperationOutput.Success? && kmsOperationOutput.value == res.value
    decreases ciphertext, sourceEncryptionContext, destinationEncryptionContext, kmsConfiguration, grantTokens, kmsClient
  {
    var kmsKeyArn := GetKeyId(kmsConfiguration);
    var reEncryptRequest := KMS.ReEncryptRequest(CiphertextBlob := ciphertext, SourceEncryptionContext := Some(sourceEncryptionContext), SourceKeyId := Some(kmsKeyArn), DestinationKeyId := kmsKeyArn, DestinationEncryptionContext := Some(destinationEncryptionContext), SourceEncryptionAlgorithm := None, DestinationEncryptionAlgorithm := None, GrantTokens := Some(grantTokens));
    var maybeReEncryptResponse := kmsClient.ReEncrypt(reEncryptRequest);
    var reEncryptResponse :- maybeReEncryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(reEncryptResponse.SourceKeyId.Some? && reEncryptResponse.KeyId.Some? && reEncryptResponse.SourceKeyId.value == kmsKeyArn && reEncryptResponse.KeyId.value == kmsKeyArn, Types.KeyStoreException(message := "Invalid response from KMS ReEncrypt:: Invalid Key Id"));
    :- Need(reEncryptResponse.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(reEncryptResponse.CiphertextBlob.value), Types.KeyStoreException(message := "Invalid response from AWS KMS ReEncrypt: Invalid ciphertext."));
    return Success(reEncryptResponse);
  }

  method DecryptKey(encryptionContext: Structure.BranchKeyContext, item: Structure.BranchKeyItem, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient)
      returns (output: Result<KMS.DecryptResponse, Types.Error>)
    requires KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD])
    requires item == Structure.ToAttributeMap(encryptionContext, item[Structure.BRANCH_KEY_FIELD].B)
    requires AttemptKmsOperation?(kmsConfiguration, encryptionContext)
    requires kmsClient.ValidState()
    modifies kmsClient.Modifies
    ensures kmsClient.ValidState()
    ensures |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && var kmsKeyArn: KMS.KeyIdType := GetArn(kmsConfiguration, encryptionContext[Structure.KMS_FIELD]); true && KMS.DecryptRequest(CiphertextBlob := item[Structure.BRANCH_KEY_FIELD].B, EncryptionContext := Some(encryptionContext), GrantTokens := Some(grantTokens), KeyId := Some(kmsKeyArn), EncryptionAlgorithm := None) == Seq.Last(kmsClient.History.Decrypt).input
    ensures output.Success? ==> Seq.Last(kmsClient.History.Decrypt).output.Success? && output.value == Seq.Last(kmsClient.History.Decrypt).output.value && output.value.Plaintext.Some? && 32 == |output.value.Plaintext.value|
    decreases encryptionContext, item, kmsConfiguration, grantTokens, kmsClient
  {
    var kmsKeyArn := GetArn(kmsConfiguration, encryptionContext[Structure.KMS_FIELD]);
    var maybeDecryptResponse := kmsClient.Decrypt(KMS.DecryptRequest(CiphertextBlob := item[Structure.BRANCH_KEY_FIELD].B, EncryptionContext := Some(encryptionContext), GrantTokens := Some(grantTokens), KeyId := Some(kmsKeyArn), EncryptionAlgorithm := None));
    var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(e));
    OptionalSequenceIsSafeBecauseItIsInMemory(decryptResponse.Plaintext);
    :- Need(decryptResponse.Plaintext.Some? && 32 == |decryptResponse.Plaintext.value| as uint64, Types.KeyStoreException(message := "Invalid response from AWS KMS Decrypt: Key is not 32 bytes."));
    output := Success(decryptResponse);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import Structure

  import opened AwsArnParsing

  import AwsKmsMrkMatchForDecrypt

  import KmsArn
}

module AwsKmsMrkMatchForDecrypt {
  predicate method AwsKmsMrkMatchForDecrypt(configuredAwsKmsIdentifier: AwsKmsIdentifier, messageAwsKmsIdentifer: AwsKmsIdentifier)
    decreases configuredAwsKmsIdentifier, messageAwsKmsIdentifer
  {
    if configuredAwsKmsIdentifier == messageAwsKmsIdentifer then
      true
    else
      match (messageAwsKmsIdentifer, configuredAwsKmsIdentifier) { case (AwsKmsArnIdentifier(configuredAwsKmsArn), AwsKmsArnIdentifier(messageAwsKmsArn)) => (if !IsMultiRegionAwsKmsArn(configuredAwsKmsArn) || !IsMultiRegionAwsKmsArn(messageAwsKmsArn) then false else messageAwsKmsArn.partition == configuredAwsKmsArn.partition && messageAwsKmsArn.service == configuredAwsKmsArn.service && messageAwsKmsArn.account == configuredAwsKmsArn.account && messageAwsKmsArn.resource == configuredAwsKmsArn.resource) case (_ /* _v0 */, _ /* _v1 */) => false }
  }

  lemma AwsKmsMrkMatchForDecryptCorrect(config: string, message: string)
    ensures ghost var c: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(config); ghost var m: Result<AwsKmsIdentifier, string> := ParseAwsKmsIdentifier(message); config == message && c.Success? && m.Success? ==> AwsKmsMrkMatchForDecrypt(c.value, m.value)
    ensures ghost var c: Result<AwsKmsArn, string> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, string> := ParseAwsKmsArn(message); config != message && c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) != IsMultiRegionAwsKmsArn(m.value) ==> !AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value))
    ensures ghost var c: Result<AwsKmsArn, string> := ParseAwsKmsArn(config); ghost var m: Result<AwsKmsArn, string> := ParseAwsKmsArn(message); c.Success? && m.Success? && IsMultiRegionAwsKmsArn(c.value) && IsMultiRegionAwsKmsArn(m.value) ==> AwsKmsMrkMatchForDecrypt(AwsKmsArnIdentifier(c.value), AwsKmsArnIdentifier(m.value)) == (m.value.partition == c.value.partition && m.value.service == c.value.service && m.value.account == c.value.account && m.value.resource == c.value.resource)
    decreases config, message
  {
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened AwsArnParsing
}

module DDBKeystoreOperations {
  const BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME := "#BranchKeyIdentifierField"
  const BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAMES := map[BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME := Structure.BRANCH_KEY_IDENTIFIER_FIELD]
  const BRANCH_KEY_NOT_EXIST_CONDITION := "attribute_not_exists(" + BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME + ")"
  const BRANCH_KEY_EXISTS_CONDITION := "attribute_exists(" + BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAME + ")"

  method WriteNewKeyToStore(versionBranchKeyItem: Structure.VersionBranchKeyItem, activeBranchKeyItem: Structure.ActiveBranchKeyItem, beaconKeyItem: Structure.BeaconKeyItem, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<DDB.TransactWriteItemsOutput, Types.Error>)
    requires activeBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == versionBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == beaconKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] && activeBranchKeyItem[Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD] == versionBranchKeyItem[Structure.TYPE_FIELD]
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && DDB.TransactWriteItemsInput(TransactItems := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(beaconKeyItem, tableName, BRANCH_KEY_NOT_EXIST)], ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None) == Seq.Last(ddbClient.History.TransactWriteItems).input && old(ddbClient.History.TransactWriteItems) < ddbClient.History.TransactWriteItems
    ensures output.Success? ==> Seq.Last(ddbClient.History.TransactWriteItems).output.Success?
    ensures Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?
    decreases versionBranchKeyItem, activeBranchKeyItem, beaconKeyItem, tableName, ddbClient
  {
    var items: DDB.TransactWriteItemList := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(beaconKeyItem, tableName, BRANCH_KEY_NOT_EXIST)];
    var transactRequest := DDB.TransactWriteItemsInput(TransactItems := items, ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None);
    var maybeTransactWriteResponse := ddbClient.TransactWriteItems(transactRequest);
    var transactWriteItemsResponse :- maybeTransactWriteResponse.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    output := Success(transactWriteItemsResponse);
  }

  method WriteNewBranchKeyVersionToKeystore(versionBranchKeyItem: Structure.VersionBranchKeyItem, activeBranchKeyItem: Structure.ActiveBranchKeyItem, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<DDB.TransactWriteItemsOutput, Types.Error>)
    requires activeBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] == versionBranchKeyItem[Structure.BRANCH_KEY_IDENTIFIER_FIELD] && activeBranchKeyItem[Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD] == versionBranchKeyItem[Structure.TYPE_FIELD]
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.TransactWriteItems| == |old(ddbClient.History.TransactWriteItems)| + 1 && DDB.TransactWriteItemsInput(TransactItems := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_EXISTS)], ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None) == Seq.Last(ddbClient.History.TransactWriteItems).input
    ensures output.Success? ==> Seq.Last(ddbClient.History.TransactWriteItems).output.Success?
    ensures Seq.Last(ddbClient.History.TransactWriteItems).output.Failure? ==> output.Failure?
    ensures old(ddbClient.History.TransactWriteItems) < ddbClient.History.TransactWriteItems && old(ddbClient.History.GetItem) == ddbClient.History.GetItem
    decreases versionBranchKeyItem, activeBranchKeyItem, tableName, ddbClient
  {
    var items: DDB.TransactWriteItemList := [CreateTransactWritePutItem(versionBranchKeyItem, tableName, BRANCH_KEY_NOT_EXIST), CreateTransactWritePutItem(activeBranchKeyItem, tableName, BRANCH_KEY_EXISTS)];
    var transactRequest := DDB.TransactWriteItemsInput(TransactItems := items, ReturnConsumedCapacity := None, ReturnItemCollectionMetrics := None, ClientRequestToken := None);
    var maybeTransactWriteResponse := ddbClient.TransactWriteItems(transactRequest);
    var transactWriteItemsResponse :- maybeTransactWriteResponse.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    output := Success(transactWriteItemsResponse);
  }

  method GetActiveBranchKeyItem(branchKeyIdentifier: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.ActiveBranchKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures old(ddbClient.History.GetItem) < ddbClient.History.GetItem && old(ddbClient.History.TransactWriteItems) == ddbClient.History.TransactWriteItems
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.ActiveBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    OptionalMapIsSafeBecauseItIsInMemory(getItemResponse.Item);
    :- Need(getItemResponse.Item.Some? && |getItemResponse.Item.value| as uint64 >= 1, Types.KeyStoreException(message := ErrorMessages.NO_CORRESPONDING_BRANCH_KEY));
    :- Need(Structure.ActiveBranchKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier, Types.KeyStoreException(message := "Item found is not a valid active branch key."));
    output := Success(getItemResponse.Item.value);
  }

  method GetVersionBranchKeyItem(branchKeyIdentifier: string, branchKeyVersion: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.VersionBranchKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && output.value[Structure.TYPE_FIELD].S == Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.VersionBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, branchKeyVersion, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    OptionalMapIsSafeBecauseItIsInMemory(getItemResponse.Item);
    :- Need(getItemResponse.Item.Some? && |getItemResponse.Item.value| as uint64 >= 1, Types.KeyStoreException(message := ErrorMessages.NO_CORRESPONDING_BRANCH_KEY));
    :- Need(Structure.VersionBranchKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && getItemResponse.Item.value[Structure.TYPE_FIELD].S == Structure.BRANCH_KEY_TYPE_PREFIX + branchKeyVersion, Types.KeyStoreException(message := "Item found is not a valid branch key version."));
    output := Success(getItemResponse.Item.value);
  }

  method GetBeaconKeyItem(branchKeyIdentifier: string, tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Structure.BeaconKeyItem, Types.Error>)
    requires DDB.IsValid_TableName(tableName)
    requires ddbClient.ValidState()
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)]
    ensures output.Success? ==> output.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier && output.value[Structure.TYPE_FIELD].S == Structure.BEACON_KEY_TYPE_VALUE && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && output == Success(Seq.Last(ddbClient.History.GetItem).output.value.Item.value)
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.BeaconKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?
    decreases branchKeyIdentifier, tableName, ddbClient
  {
    var dynamoDbKey: DDB.Key := map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)];
    var ItemRequest := DDB.GetItemInput(Key := dynamoDbKey, TableName := tableName, AttributesToGet := None, ConsistentRead := None, ReturnConsumedCapacity := None, ProjectionExpression := None, ExpressionAttributeNames := None);
    var maybeGetItem := ddbClient.GetItem(ItemRequest);
    var getItemResponse :- maybeGetItem.MapFailure((e: Error) => Types.ComAmazonawsDynamodb(ComAmazonawsDynamodb := e));
    OptionalMapIsSafeBecauseItIsInMemory(getItemResponse.Item);
    :- Need(getItemResponse.Item.Some? && |getItemResponse.Item.value| as uint64 >= 1, Types.KeyStoreException(message := ErrorMessages.NO_CORRESPONDING_BRANCH_KEY));
    :- Need(Structure.BeaconKeyItem?(getItemResponse.Item.value) && getItemResponse.Item.value[Structure.BRANCH_KEY_IDENTIFIER_FIELD].S == branchKeyIdentifier, Types.KeyStoreException(message := "Item found is not a valid beacon key."));
    output := Success(getItemResponse.Item.value);
  }

  function method CreateTransactWritePutItem(item: DDB.AttributeMap, tableName: DDB.TableName, conditionExpression: ConditionExpression): (output: DDB.TransactWriteItem)
    decreases item, tableName, conditionExpression
  {
    DDB.TransactWriteItem(ConditionCheck := None, Put := Some(DDB.Put(Item := item, TableName := tableName, ConditionExpression := Some(match conditionExpression case BRANCH_KEY_NOT_EXIST() => BRANCH_KEY_NOT_EXIST_CONDITION case BRANCH_KEY_EXISTS() => BRANCH_KEY_EXISTS_CONDITION), ExpressionAttributeNames := Some(BRANCH_KEY_EXISTS_EXPRESSION_ATTRIBUTE_NAMES), ExpressionAttributeValues := None, ReturnValuesOnConditionCheckFailure := None)), Delete := None, Update := None)
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import UTF8

  import Structure

  import ErrorMessages = KeyStoreErrorMessages

  datatype ConditionExpression = BRANCH_KEY_NOT_EXIST | BRANCH_KEY_EXISTS
}

module CreateKeyStoreTable {
  const ATTRIBUTE_DEFINITIONS: DDB.AttributeDefinitions := [DDB.AttributeDefinition(AttributeName := Structure.BRANCH_KEY_IDENTIFIER_FIELD, AttributeType := DDB.ScalarAttributeType.S), DDB.AttributeDefinition(AttributeName := Structure.TYPE_FIELD, AttributeType := DDB.ScalarAttributeType.S)]
  const KEY_SCHEMA: DDB.KeySchema := [DDB.KeySchemaElement(AttributeName := Structure.BRANCH_KEY_IDENTIFIER_FIELD, KeyType := DDB.KeyType.HASH), DDB.KeySchemaElement(AttributeName := Structure.TYPE_FIELD, KeyType := DDB.KeyType.RANGE)]

  predicate method keyStoreHasExpectedConstruction?(t: DDB.TableDescription)
    decreases t
  {
    t.AttributeDefinitions.Some? &&
    t.KeySchema.Some? &&
    t.TableName.Some? &&
    t.TableArn.Some? &&
    ToSet(t.AttributeDefinitions.value) >= ToSet(ATTRIBUTE_DEFINITIONS) &&
    ToSet(t.KeySchema.value) >= ToSet(KEY_SCHEMA)
  }

  method CreateKeyStoreTable(tableName: DDB.TableName, ddbClient: DDB.IDynamoDBClient) returns (res: Result<string, Types.Error>)
    requires ddbClient.ValidState()
    requires DDB.IsValid_TableName(tableName)
    modifies ddbClient.Modifies
    ensures ddbClient.ValidState()
    ensures res.Success? ==> DDB.IsValid_TableArn(res.Extract())
    ensures |ddbClient.History.DescribeTable| == |old(ddbClient.History.DescribeTable)| + 1 && Seq.Last(ddbClient.History.DescribeTable).input.TableName == tableName && (Seq.Last(ddbClient.History.DescribeTable).output.Success? ==> |ddbClient.History.CreateTable| == |old(ddbClient.History.CreateTable)|)
    ensures Seq.Last(ddbClient.History.DescribeTable).output.Failure? && Seq.Last(ddbClient.History.DescribeTable).output.error.ResourceNotFoundException? ==> |ddbClient.History.CreateTable| == |old(ddbClient.History.CreateTable)| + 1 && var CreateTableInput: CreateTableInput := Seq.Last(ddbClient.History.CreateTable).input; CreateTableInput.TableName == tableName && CreateTableInput.KeySchema == KEY_SCHEMA && (Seq.Last(ddbClient.History.CreateTable).output.Failure? ==> res.Failure?) && (Seq.Last(ddbClient.History.CreateTable).output.Success? && Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.Some? && keyStoreHasExpectedConstruction?(Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.value) && DDB.IsValid_TableArn(Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.value.TableArn.value) ==> res.Success? && res.value == Seq.Last(ddbClient.History.CreateTable).output.value.TableDescription.value.TableArn.value)
    ensures true && Seq.Last(ddbClient.History.DescribeTable).output.Success? ==> var DescribeTableResult: DescribeTableOutput := Seq.Last(ddbClient.History.DescribeTable).output.value; if DescribeTableResult.Table.Some? && keyStoreHasExpectedConstruction?(DescribeTableResult.Table.value) then true && (DescribeTableResult.Table.value.GlobalSecondaryIndexes.Some? || DescribeTableResult.Table.value.GlobalSecondaryIndexes.None?) else true && res.Failure?
    decreases tableName, ddbClient
  {
    var maybeDescribeTableResponse := ddbClient.DescribeTable(DDB.DescribeTableInput(TableName := tableName));
    if maybeDescribeTableResponse.Failure? {
      var error := maybeDescribeTableResponse.error;
      if error.ResourceNotFoundException? {
        var maybeCreateTableResponse := ddbClient.CreateTable(DDB.CreateTableInput(AttributeDefinitions := ATTRIBUTE_DEFINITIONS, TableName := tableName, KeySchema := KEY_SCHEMA, LocalSecondaryIndexes := None, GlobalSecondaryIndexes := None, BillingMode := Some(DDB.BillingMode.PAY_PER_REQUEST), ProvisionedThroughput := None, StreamSpecification := None, SSESpecification := None, Tags := None, TableClass := None));
        if maybeCreateTableResponse.Failure? {
          res := Failure(Types.ComAmazonawsDynamodb(maybeCreateTableResponse.error));
        } else {
          :- Need(maybeCreateTableResponse.value.TableDescription.Some? && keyStoreHasExpectedConstruction?(maybeCreateTableResponse.value.TableDescription.value) && DDB.IsValid_TableArn(maybeCreateTableResponse.value.TableDescription.value.TableArn.value), E("Configured table name does not conform to expected Key Store construction."));
          res := Success(maybeCreateTableResponse.value.TableDescription.value.TableArn.value);
        }
      } else {
        res := Failure(Types.ComAmazonawsDynamodb(error));
      }
    } else {
      :- Need(maybeDescribeTableResponse.value.Table.Some? && keyStoreHasExpectedConstruction?(maybeDescribeTableResponse.value.Table.value) && DDB.IsValid_TableArn(maybeDescribeTableResponse.value.Table.value.TableArn.value), E("Configured table name does not conform to expected Key Store construction."));
      res := Success(maybeDescribeTableResponse.value.Table.value.TableArn.value);
    }
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.KeyStoreException(message := s)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import Structure

  type keyStoreDescription = t: DDB.TableDescription
    | keyStoreHasExpectedConstruction?(t)
    witness *
}

module GetKeys {
  method GetActiveKeyAndUnwrap(input: Types.GetActiveBranchKeyInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetActiveBranchKeyOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_ACTIVE_TYPE)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var activeItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(activeItem) && activeItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD in activeItem && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(activeItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(activeItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var branchKeyMaterials: Types.BranchKeyMaterials := Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.branchKeyMaterials == branchKeyMaterials && output.value.branchKeyMaterials.branchKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.ActiveBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetActiveBranchKeyItem(input.branchKeyIdentifier, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD]), Types.KeyStoreException(message := ErrorMessages.RETRIEVED_KEYSTORE_ITEM_INVALID_KMS_ARN));
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := ErrorMessages.GET_KEY_ARN_DISAGREEMENT));
    var branchKey: KMS.DecryptResponse :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBranchKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetActiveBranchKeyOutput(branchKeyMaterials := branchKeyMaterials));
  }

  method GetBranchKeyVersion(input: Types.GetBranchKeyVersionInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetBranchKeyVersionOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BRANCH_KEY_TYPE_PREFIX + input.branchKeyVersion)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var versionItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(versionItem) && versionItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in versionItem && Structure.BRANCH_KEY_TYPE_PREFIX < versionItem[Structure.TYPE_FIELD].S && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var branchKeyMaterials: Types.BranchKeyMaterials := Structure.ToBranchKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.branchKeyMaterials == branchKeyMaterials && output.value.branchKeyMaterials.branchKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.VersionBranchKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetVersionBranchKeyItem(input.branchKeyIdentifier, input.branchKeyVersion, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD]), Types.KeyStoreException(message := ErrorMessages.RETRIEVED_KEYSTORE_ITEM_INVALID_KMS_ARN));
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := "AWS KMS Key ARN does not match configured value"));
    var branchKey: KMS.DecryptResponse :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBranchKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetBranchKeyVersionOutput(branchKeyMaterials := branchKeyMaterials));
  }

  method {:vcs_split_on_every_assert} GetBeaconKeyAndUnwrap(input: Types.GetBeaconKeyInput, tableName: DDB.TableName, logicalKeyStoreName: string, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient)
      returns (output: Result<Types.GetBeaconKeyOutput, Types.Error>)
    requires ddbClient.Modifies !! kmsClient.Modifies
    requires kmsClient.ValidState() && ddbClient.ValidState()
    modifies ddbClient.Modifies, kmsClient.Modifies
    ensures ddbClient.ValidState() && kmsClient.ValidState()
    ensures |ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).input.Key == map[Structure.BRANCH_KEY_IDENTIFIER_FIELD := DDB.AttributeValue.S(input.branchKeyIdentifier), Structure.TYPE_FIELD := DDB.AttributeValue.S(Structure.BEACON_KEY_TYPE_VALUE)]
    ensures output.Success? ==> Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && var versionItem: AttributeMap := Seq.Last(ddbClient.History.GetItem).output.value.Item.value; Structure.BranchKeyItem?(versionItem) && versionItem[Structure.HIERARCHY_VERSION].N? && Structure.BRANCH_KEY_ACTIVE_VERSION_FIELD !in versionItem && versionItem[Structure.TYPE_FIELD].S == Structure.BEACON_KEY_TYPE_VALUE && KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName)) && |kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && AwsKmsBranchKeyDecryption?(Seq.Last(ddbClient.History.GetItem), Seq.Last(kmsClient.History.Decrypt), kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName) && var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName); true && var decryptResponse: DecryptResponse := Seq.Last(kmsClient.History.Decrypt).output.value; Structure.ToBeaconKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).Success? && var beaconKeyMaterials: Types.BeaconKeyMaterials := Structure.ToBeaconKeyMaterials(versionEncryptionContext, decryptResponse.Plaintext.value).value; output.value.beaconKeyMaterials == beaconKeyMaterials && output.value.beaconKeyMaterials.beaconKeyIdentifier == input.branchKeyIdentifier
    ensures (|ddbClient.History.GetItem| == |old(ddbClient.History.GetItem)| + 1 && Seq.Last(ddbClient.History.GetItem).output.Success? && Seq.Last(ddbClient.History.GetItem).output.value.Item.Some? && !Structure.BeaconKeyItem?(Seq.Last(ddbClient.History.GetItem).output.value.Item.value) ==> output.Failure?) || (|kmsClient.History.Decrypt| == |old(kmsClient.History.Decrypt)| + 1 && Seq.Last(kmsClient.History.Decrypt).output.Failure? ==> output.Failure?)
    decreases input, tableName, logicalKeyStoreName, kmsConfiguration, grantTokens, kmsClient, ddbClient
  {
    var branchKeyItem :- DDBKeystoreOperations.GetBeaconKeyItem(input.branchKeyIdentifier, tableName, ddbClient);
    var encryptionContext := Structure.ToBranchKeyContext(branchKeyItem, logicalKeyStoreName);
    :- Need(KmsArn.ValidKmsArn?(encryptionContext[Structure.KMS_FIELD]), Types.KeyStoreException(message := ErrorMessages.RETRIEVED_KEYSTORE_ITEM_INVALID_KMS_ARN));
    :- Need(KMSKeystoreOperations.AttemptKmsOperation?(kmsConfiguration, encryptionContext), Types.KeyStoreException(message := "AWS KMS Key ARN does not match configured value"));
    var branchKey: KMS.DecryptResponse :- KMSKeystoreOperations.DecryptKey(encryptionContext, branchKeyItem, kmsConfiguration, grantTokens, kmsClient);
    var branchKeyMaterials :- Structure.ToBeaconKeyMaterials(encryptionContext, branchKey.Plaintext.value);
    return Success(Types.GetBeaconKeyOutput(beaconKeyMaterials := branchKeyMaterials));
  }

  predicate AwsKmsBranchKeyDecryption?(getItemHistory: DDB.DafnyCallEvent<DDB.GetItemInput, Result<DDB.GetItemOutput, DDB.Error>>, decryptHistory: KMS.DafnyCallEvent<KMS.DecryptRequest, Result<KMS.DecryptResponse, KMS.Error>>, kmsClient: KMS.IKMSClient, ddbClient: DDB.IDynamoDBClient, kmsConfiguration: Types.KMSConfiguration, grantTokens: KMS.GrantTokenList, logicalKeyStoreName: string)
    requires getItemHistory.output.Success? && getItemHistory.output.value.Item.Some? && Structure.BranchKeyItem?(getItemHistory.output.value.Item.value) && getItemHistory.output.Success? && getItemHistory.output.value.Item.Some?
    requires decryptHistory in kmsClient.History.Decrypt
    requires getItemHistory in ddbClient.History.GetItem
    reads kmsClient.History, ddbClient.History
    decreases {kmsClient.History, ddbClient.History}, getItemHistory, decryptHistory, kmsClient, ddbClient, kmsConfiguration, grantTokens, logicalKeyStoreName
  {
    ghost var versionItem: AttributeMap := getItemHistory.output.value.Item.value;
    ghost var versionEncryptionContext: BranchKeyContext := Structure.ToBranchKeyContext(versionItem, logicalKeyStoreName);
    versionEncryptionContext.Keys - {Structure.TABLE_FIELD} < versionItem.Keys &&
    (forall k: seq<char> {:trigger versionItem[k]} {:trigger versionEncryptionContext[k]} {:trigger k in versionEncryptionContext.Keys - {Structure.TABLE_FIELD}} | k in versionEncryptionContext.Keys - {Structure.TABLE_FIELD} :: 
      if k == Structure.HIERARCHY_VERSION then versionEncryptionContext[Structure.HIERARCHY_VERSION] == versionItem[Structure.HIERARCHY_VERSION].N else versionEncryptionContext[k] == versionItem[k].S) &&
    Structure.BRANCH_KEY_FIELD !in versionEncryptionContext &&
    (kmsConfiguration.kmsKeyArn? ==>
      versionItem[Structure.KMS_FIELD].S == kmsConfiguration.kmsKeyArn) &&
    (kmsConfiguration.kmsMRKeyArn? ==>
      KMSKeystoreOperations.MrkMatch(versionItem[Structure.KMS_FIELD].S, kmsConfiguration.kmsMRKeyArn)) &&
    (kmsConfiguration.discovery? ==>
      KmsArn.ValidKmsArn?(versionItem[Structure.KMS_FIELD].S)) &&
    ghost var decryptRequest: KMS.DecryptRequest := decryptHistory.input; decryptRequest.KeyId.Some? && (kmsConfiguration.discovery? ==> decryptRequest.KeyId == Some(versionItem[Structure.KMS_FIELD].S)) && (kmsConfiguration.mrDiscovery? ==> decryptRequest.KeyId == Some(KMSKeystoreOperations.replaceRegion(versionItem[Structure.KMS_FIELD].S, kmsConfiguration.mrDiscovery.region))) && (kmsConfiguration.kmsKeyArn? ==> decryptRequest.KeyId == Some(kmsConfiguration.kmsKeyArn)) && (kmsConfiguration.kmsMRKeyArn? ==> KMSKeystoreOperations.MrkMatch(decryptRequest.KeyId.value, kmsConfiguration.kmsMRKeyArn)) && decryptRequest.CiphertextBlob == versionItem[Structure.BRANCH_KEY_FIELD].B && decryptRequest.EncryptionContext == Some(versionEncryptionContext) && decryptRequest.GrantTokens == Some(grantTokens) && decryptHistory.output.Success? && decryptHistory.output.value.Plaintext.Some?
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import Structure

  import KMSKeystoreOperations

  import DDBKeystoreOperations

  import ErrorMessages = KeyStoreErrorMessages

  import Types = AwsCryptographyKeyStoreTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import KmsArn
}

module AwsKmsUtils {
  function method OkForDecrypt(id: AwsKmsIdentifier, arn: string): Outcome<Types.Error>
    decreases id, arn
  {
    if !id.AwsKmsArnIdentifier? then
      Fail(Types.AwsCryptographicMaterialProvidersException(message := "KeyID cannot be used for Decrypt : " + arn))
    else if id.a.resource.resourceType != "key" then
      Fail(Types.AwsCryptographicMaterialProvidersException(message := "Alias cannot be used for Decrypt : " + arn))
    else
      Pass
  }

  function method StringifyEncryptionContext(utf8EncCtx: Types.EncryptionContext): (res: Result<KMS.EncryptionContextType, Types.Error>)
    decreases utf8EncCtx
  {
    MapIsSafeBecauseItIsInMemory(utf8EncCtx);
    if |utf8EncCtx| as uint64 == 0 then
      Success(map[])
    else
      var stringifyResults: map<UTF8.ValidUTF8Bytes, Result<(string, string), Types.Error>> := map utf8Key: UTF8.ValidUTF8Bytes {:trigger utf8EncCtx[utf8Key]} {:trigger utf8Key in utf8EncCtx.Keys} | utf8Key in utf8EncCtx.Keys :: utf8Key := StringifyEncryptionContextPair(utf8Key, utf8EncCtx[utf8Key]); if exists r: Result<(string, string), Types.Error> {:trigger r.Failure?} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.Failure? then Failure(Types.AwsCryptographicMaterialProvidersException(message := "Encryption context contains invalid UTF8")) else assert forall r: Result<(string, string), Types.Error> {:trigger r.Success?} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.Success?; var stringKeysUnique: bool := forall k: seq<uint8>, k': seq<uint8> {:trigger stringifyResults[k'], stringifyResults[k]} {:trigger stringifyResults[k'], k in stringifyResults} {:trigger stringifyResults[k], k' in stringifyResults} {:trigger k' in stringifyResults, k in stringifyResults} | k in stringifyResults && k' in stringifyResults :: k != k' ==> stringifyResults[k].value.0 != stringifyResults[k'].value.0; if !stringKeysUnique then Failure(Types.AwsCryptographicMaterialProvidersException(message := "Encryption context keys are not unique")) else Success(map r: Result<(string, string), Types.Error> {:trigger r.value} {:trigger r in stringifyResults.Values} | r in stringifyResults.Values :: r.value.0 := r.value.1)
  }

  function method StringifyEncryptionContextPair(utf8Key: UTF8.ValidUTF8Bytes, utf8Value: UTF8.ValidUTF8Bytes): (res: Result<(string, string), Types.Error>)
    ensures UTF8.Decode(utf8Key).Success? && UTF8.Decode(utf8Value).Success? <==> res.Success?
    decreases utf8Key, utf8Value
  {
    var key: string :- UTF8.Decode(utf8Key).MapFailure(WrapStringToError); var value: string :- UTF8.Decode(utf8Value).MapFailure(WrapStringToError); Success((key, value))
  }

  function method WrapStringToError(e: string): (ret: Types.Error)
    decreases e
  {
    Types.AwsCryptographicMaterialProvidersException(message := e)
  }

  function method ValidateKmsKeyId(keyId: string): (res: Result<(), Types.Error>)
    ensures res.Success? ==> AwsArnParsing.ParseAwsKmsIdentifier(keyId).Success? && UTF8.IsASCIIString(keyId) && 0 < |keyId| <= AwsArnParsing.MAX_AWS_KMS_IDENTIFIER_LENGTH as nat
    decreases keyId
  {
    var _ /* _v0 */: AwsKmsIdentifier :- AwsArnParsing.ParseAwsKmsIdentifier(keyId).MapFailure(WrapStringToError); :- Need(UTF8.IsASCIIString(keyId), Types.AwsCryptographicMaterialProvidersException(message := "Key identifier is not ASCII")); SequenceIsSafeBecauseItIsInMemory(keyId); :- Need(0 < |keyId| as uint64 <= AwsArnParsing.MAX_AWS_KMS_IDENTIFIER_LENGTH, Types.AwsCryptographicMaterialProvidersException(message := "Key identifier is too long")); Success(())
  }

  function method GetValidGrantTokens(grantTokens: Option<Types.GrantTokenList>): (res: Result<Types.GrantTokenList, Types.Error>)
    ensures res.Success? ==> var tokens: Types.GrantTokenList := res.value; 0 <= |tokens| <= 10 && forall token: seq<char> {:trigger |token|} {:trigger token in tokens} | token in tokens :: 1 <= |token| && |token| <= 8192
    ensures res.Success? && grantTokens.Some? ==> res.value == grantTokens.value
    decreases grantTokens
  {
    var tokens: Types.GrantTokenList := grantTokens.UnwrapOr([]);
    SequenceIsSafeBecauseItIsInMemory(tokens);
    :- Need(0 <= |tokens| as uint64 <= 10, Types.AwsCryptographicMaterialProvidersException(message := "Grant token list can have no more than 10 tokens")); assume {:axiom} forall token: seq<char> {:trigger HasUint64Len<char>(token)} {:trigger token in tokens} | token in tokens :: HasUint64Len(token); :- Need(forall token: seq<char> {:trigger |token|} {:trigger token in tokens} | token in tokens :: 1 <= |token| as uint64 && |token| as uint64 <= 8192, Types.AwsCryptographicMaterialProvidersException(message := "Grant token list contains a grant token with invalid length")); Success(tokens)
  }

  method GetEcdhPublicKey(client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString) returns (res: Result<KMS.PublicKeyType, Types.Error>)
    requires client.ValidState()
    modifies client.Modifies
    ensures client.ValidState()
    ensures res.Success? ==> 0 < |client.History.GetPublicKey| && Last(client.History.GetPublicKey).input == KMS.GetPublicKeyRequest(KeyId := awsKmsKey, GrantTokens := None) && Last(client.History.GetPublicKey).output.Success? && var getPublicKeyResponse: GetPublicKeyResponse := Last(client.History.GetPublicKey).output.value; getPublicKeyResponse.KeyId.Some? && getPublicKeyResponse.KeyId.value == awsKmsKey && getPublicKeyResponse.KeyUsage.Some? && getPublicKeyResponse.KeyUsage.value == KMS.KeyUsageType.KEY_AGREEMENT && getPublicKeyResponse.PublicKey.Some? && var publicKey: PublicKeyType := getPublicKeyResponse.PublicKey.value; true && KMS.IsValid_PublicKeyType(publicKey)
    decreases client, awsKmsKey
  {
    var getPublicKeyRequest := KMS.GetPublicKeyRequest(KeyId := awsKmsKey, GrantTokens := None);
    var maybePublicKeyResponse := client.GetPublicKey(getPublicKeyRequest);
    var getPublicKeyResponse :- maybePublicKeyResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(getPublicKeyResponse.KeyId.Some? && getPublicKeyResponse.KeyId.value == awsKmsKey && getPublicKeyResponse.KeyUsage.Some? && getPublicKeyResponse.KeyUsage.value == KMS.KeyUsageType.KEY_AGREEMENT && getPublicKeyResponse.PublicKey.Some?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from KMS GetPublicKey"));
    return Success(getPublicKeyResponse.PublicKey.value);
  }

  function method ParseKeyNamespaceAndName(keyNamespace: string, keyName: string): (res: Result<(UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes), Types.Error>)
    ensures res.Success? ==> var (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes) := res.value; |namespace| < UINT16_LIMIT && |name| < UINT16_LIMIT
    decreases keyNamespace, keyName
  {
    var namespace: ValidUTF8Bytes :- UTF8.Encode(keyNamespace).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := "Key namespace could not be UTF8-encoded" + e)); SequenceIsSafeBecauseItIsInMemory(namespace); :- Need(|namespace| as uint64 < UINT16_LIMIT as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Key namespace too long")); var name: ValidUTF8Bytes :- UTF8.Encode(keyName).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := "Key name could not be UTF8-encoded" + e)); SequenceIsSafeBecauseItIsInMemory(name); :- Need(|name| as uint64 < UINT16_LIMIT as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Key name too long")); Success((namespace, name))
  }

  function method ValidateDiscoveryFilter(filter: Types.DiscoveryFilter): (res: Result<(), Types.Error>)
    ensures res.Success? ==> |filter.accountIds| > 0 && (forall accountId: seq<char> {:trigger |accountId|} {:trigger accountId in filter.accountIds} | accountId in filter.accountIds :: |accountId| > 0) && |filter.partition| > 0
    decreases filter
  {
    SequenceIsSafeBecauseItIsInMemory(filter.accountIds);
    :- Need(|filter.accountIds| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "Discovery filter must have at least one account ID")); assume {:axiom} forall accountId: seq<char> {:trigger HasUint64Len<char>(accountId)} {:trigger accountId in filter.accountIds} | accountId in filter.accountIds :: HasUint64Len(accountId); :- Need(forall accountId: seq<char> {:trigger |accountId|} {:trigger accountId in filter.accountIds} | accountId in filter.accountIds :: |accountId| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "Discovery filter account IDs cannot be blank")); SequenceIsSafeBecauseItIsInMemory(filter.partition); :- Need(|filter.partition| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "Discovery filter partition cannot be blank")); Success(())
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import opened A = AwsKmsMrkMatchForDecrypt

  import opened AwsArnParsing

  import opened Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import UTF8

  class OnDecryptMrkAwareEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifier
    const providerId: UTF8.ValidUTF8Bytes

    function Modifies(): set<object>
    {
      {}
    }

    constructor (awsKmsKey: AwsArnParsing.AwsKmsIdentifier, providerId: UTF8.ValidUTF8Bytes)
      ensures this.awsKmsKey == awsKmsKey && this.providerId == providerId
      decreases awsKmsKey, providerId
    {
      this.awsKmsKey := awsKmsKey;
      this.providerId := providerId;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == providerId)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != providerId {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.keyProviderInfo) {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := "Invalid AWS KMS encoding, provider info is not UTF8."));
      }
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- AwsArnParsing.ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success(AwsKmsMrkMatchForDecrypt(awsKmsKey, AwsArnParsing.AwsKmsArnIdentifier(arn)));
    }
  }
}

module RequiredEncryptionContextCMM {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import Materials

  import CMM

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import Seq

  import SortedSets

  import DefaultCMM
  class RequiredEncryptionContextCMM extends CMM.VerifiableInterface {
    const underlyingCMM: Types.ICryptographicMaterialsManager
    const requiredEncryptionContextKeys: seq<UTF8.ValidUTF8Bytes>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      underlyingCMM.ValidState() &&
      underlyingCMM.Modifies <= Modifies &&
      History !in underlyingCMM.Modifies
    }

    constructor (inputCMM: Types.ICryptographicMaterialsManager, inputKeys: set<UTF8.ValidUTF8Bytes>)
      requires inputCMM.ValidState()
      requires 0 < |inputKeys|
      ensures |inputKeys| == |requiredEncryptionContextKeys| && forall k: UTF8.ValidUTF8Bytes {:trigger k in inputKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in inputKeys
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - underlyingCMM.Modifies) && underlyingCMM == inputCMM
      ensures Modifies == {History} + underlyingCMM.Modifies
      decreases inputCMM, inputKeys
    {
      var keySet := inputKeys;
      var keySeq := SortedSets.ComputeSetToSequence(keySet);
      assert |keySeq| == |keySet| == |inputKeys|;
      assert forall k: UTF8.ValidUTF8Bytes {:trigger k in inputKeys} {:trigger k in keySeq} | k in keySeq :: k in inputKeys;
      underlyingCMM := inputCMM;
      requiredEncryptionContextKeys := keySeq;
      History := new Types.ICryptographicMaterialsManagerCallHistory();
      Modifies := {History} + inputCMM.Modifies;
    }

    predicate GetEncryptionMaterialsEnsuresPublicly(input: Types.GetEncryptionMaterialsInput, output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials) && CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials) &&
        CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
    }

    method GetEncryptionMaterials'(input: Types.GetEncryptionMaterialsInput) returns (output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials)
      ensures output.Success? ==> true && CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      ensures !(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.encryptionContext) ==> output.Failure?
      ensures true && output.Success? ==> |underlyingCMM.History.GetEncryptionMaterials| == |old(underlyingCMM.History.GetEncryptionMaterials)| + 1 && Seq.Last(underlyingCMM.History.GetEncryptionMaterials).output.Success? && output == Seq.Last(underlyingCMM.History.GetEncryptionMaterials).output
      ensures true && output.Success? ==> Seq.Last(underlyingCMM.History.GetEncryptionMaterials).input.requiredEncryptionContextKeys.Some? && var keys: EncryptionContextKeys := Seq.Last(underlyingCMM.History.GetEncryptionMaterials).input.requiredEncryptionContextKeys.value; true && forall k: UTF8.ValidUTF8Bytes {:trigger k in keys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in keys
      ensures true && output.Success? ==> true && forall k: UTF8.ValidUTF8Bytes {:trigger k in output.value.encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in output.value.encryptionMaterials.requiredEncryptionContextKeys
      decreases Modifies - {History}
    {
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Encryption context does not contain required keys."));
      var result :- underlyingCMM.GetEncryptionMaterials(input.(requiredEncryptionContextKeys := Some(input.requiredEncryptionContextKeys.UnwrapOr([]) + requiredEncryptionContextKeys)));
      if !(underlyingCMM is DefaultCMM.DefaultCMM || underlyingCMM is RequiredEncryptionContextCMM) {
        :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in result.encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in result.encryptionMaterials.requiredEncryptionContextKeys, Types.AwsCryptographicMaterialProvidersException(message := "Expected encryption context keys do not exist in keys to only authenticate."));
        :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(result.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Could not retrieve materials required for encryption"));
        :- Need(CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, result.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring returned an invalid response"));
      }
      output := Success(result);
    }

    predicate DecryptMaterialsEnsuresPublicly(input: Types.DecryptMaterialsInput, output: Result<Types.DecryptMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> (output.Success? ==> Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)) && (output.Success? ==> CMM.ReproducedEncryptionContext?(input)) && (!CMM.ReproducedEncryptionContext?(input) ==> output.Failure?) && (output.Success? ==> CMM.EncryptionContextComplete(input, output.value.decryptionMaterials))
      decreases input, output
    {
      (output.Success? ==>
        CMM.ReproducedEncryptionContext?(input)) &&
      (!CMM.ReproducedEncryptionContext?(input) ==>
        output.Failure?) &&
      (output.Success? ==>
        true &&
        Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)) &&
      (output.Success? ==>
        CMM.EncryptionContextComplete(input, output.value.decryptionMaterials))
    }

    method DecryptMaterials'(input: Types.DecryptMaterialsInput) returns (output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures true && (output.Success? ==> input.reproducedEncryptionContext.Some? && forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value)
      ensures input.reproducedEncryptionContext.None? ==> output.Failure?
      ensures input.reproducedEncryptionContext.Some? && !(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value) ==> output.Failure?
      ensures output.Success? ==> |underlyingCMM.History.DecryptMaterials| == |old(underlyingCMM.History.DecryptMaterials)| + 1 && Seq.Last(underlyingCMM.History.DecryptMaterials).output == output && Seq.Last(underlyingCMM.History.DecryptMaterials).input == input
      ensures |underlyingCMM.History.DecryptMaterials| == |old(underlyingCMM.History.DecryptMaterials)| + 1 && Seq.Last(underlyingCMM.History.DecryptMaterials).output.Success? && !(forall k: UTF8.ValidUTF8Bytes {:trigger k in Seq.Last(underlyingCMM.History.DecryptMaterials).output.value.decryptionMaterials.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in Seq.Last(underlyingCMM.History.DecryptMaterials).output.value.decryptionMaterials.encryptionContext) ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(input.reproducedEncryptionContext.Some?, Types.AwsCryptographicMaterialProvidersException(message := "No reproduced encryption context on decrypt."));
      :- Need(CMM.ReproducedEncryptionContext?(input), Types.AwsCryptographicMaterialProvidersException(message := "Encryption context does not match reproduced encryption context."));
      :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in input.reproducedEncryptionContext.value} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in input.reproducedEncryptionContext.value, Types.AwsCryptographicMaterialProvidersException(message := "Reproduced encryption context missing required keys."));
      var result :- underlyingCMM.DecryptMaterials(input);
      if !(underlyingCMM is DefaultCMM.DefaultCMM || underlyingCMM is RequiredEncryptionContextCMM) {
        :- Need(forall k: UTF8.ValidUTF8Bytes {:trigger k in result.decryptionMaterials.encryptionContext} {:trigger k in requiredEncryptionContextKeys} | k in requiredEncryptionContextKeys :: k in result.decryptionMaterials.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Final encryption context missing required keys."));
        :- Need(CMM.EncryptionContextComplete(input, result.decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Reproduced encryption context missing from encryption context."));
        :- Need(Materials.DecryptionMaterialsWithPlaintextDataKey(result.decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring.OnDecrypt failed to decrypt the plaintext data key."));
      }
      return Success(result);
    }
  }
}

module DefaultCMM {

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import AlgorithmSuites

  import Materials

  import CMM

  import Signature

  import Base64

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import Primitives = AtomicPrimitives

  import Defaults

  import Commitment

  import Seq

  import SortedSets

  import Keyring

  import MultiKeyring
  class DefaultCMM extends CMM.VerifiableInterface {
    const cryptoPrimitives: Primitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      keyring.ValidState() &&
      cryptoPrimitives.ValidState() &&
      keyring.Modifies <= Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in keyring.Modifies &&
      History !in cryptoPrimitives.Modifies
    }

    const keyring: Types.IKeyring

    constructor OfKeyring(k: Types.IKeyring, c: Primitives.AtomicPrimitivesClient)
      requires k.ValidState() && c.ValidState()
      ensures keyring == k && cryptoPrimitives == c
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies - keyring.Modifies)
      ensures Modifies == {History} + keyring.Modifies + cryptoPrimitives.Modifies
      decreases k, c
    {
      keyring := k;
      cryptoPrimitives := c;
      History := new Types.ICryptographicMaterialsManagerCallHistory();
      Modifies := {History} + c.Modifies + k.Modifies;
    }

    predicate GetEncryptionMaterialsEnsuresPublicly(input: Types.GetEncryptionMaterialsInput, output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials) && CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials) &&
        CMM.RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
    }

    method GetEncryptionMaterials'(input: Types.GetEncryptionMaterialsInput) returns (output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures GetEncryptionMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && (output.value.encryptionMaterials.algorithmSuite.signature.ECDSA? <==> Materials.EC_PUBLIC_KEY_FIELD in output.value.encryptionMaterials.encryptionContext && output.value.encryptionMaterials.signingKey.Some?)
      ensures Materials.EC_PUBLIC_KEY_FIELD in input.encryptionContext ==> output.Failure?
      ensures true && output.Success? ==> if input.algorithmSuiteId.Some? then output.value.encryptionMaterials.algorithmSuite.id == input.algorithmSuiteId.value else input.algorithmSuiteId.None? && output.value.encryptionMaterials.algorithmSuite.id == Defaults.GetAlgorithmSuiteForCommitmentPolicy(input.commitmentPolicy)
      ensures true && output.Success? ==> |keyring.History.OnEncrypt| == |old(keyring.History.OnEncrypt)| + 1 && Seq.Last(keyring.History.OnEncrypt).output.Success? && Seq.Last(keyring.History.OnEncrypt).output.value.materials.plaintextDataKey == output.value.encryptionMaterials.plaintextDataKey && Seq.Last(keyring.History.OnEncrypt).output.value.materials.encryptedDataKeys == output.value.encryptionMaterials.encryptedDataKeys
      ensures input.algorithmSuiteId.Some? && Commitment.ValidateCommitmentPolicyOnEncrypt(input.algorithmSuiteId.value, input.commitmentPolicy).Fail? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(Materials.EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Reserved Field found in EncryptionContext keys."));
      var algorithmId := if input.algorithmSuiteId.Some? then input.algorithmSuiteId.value else Defaults.GetAlgorithmSuiteForCommitmentPolicy(input.commitmentPolicy);
      :- Commitment.ValidateCommitmentPolicyOnEncrypt(algorithmId, input.commitmentPolicy);
      var suite := AlgorithmSuites.GetSuite(algorithmId);
      var signingKey: Option<seq<uint8>>;
      var verificationKey: Option<seq<uint8>>;
      if suite.signature.ECDSA? {
        var maybeECDSAPair := cryptoPrimitives.GenerateECDSASignatureKey(Crypto.GenerateECDSASignatureKeyInput(signatureAlgorithm := suite.signature.ECDSA.curve));
        var pair :- maybeECDSAPair.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
        signingKey := Some(pair.signingKey);
        verificationKey := Some(pair.verificationKey);
      } else {
        assert suite.signature.None?;
        signingKey := None;
        verificationKey := None;
      }
      var materials :- Materials.InitializeEncryptionMaterials(Types.InitializeEncryptionMaterialsInput(algorithmSuiteId := algorithmId, encryptionContext := input.encryptionContext, signingKey := signingKey, verificationKey := verificationKey, requiredEncryptionContextKeys := input.requiredEncryptionContextKeys.UnwrapOr([])));
      var result :- keyring.OnEncrypt(Types.OnEncryptInput(materials := materials));
      var encryptionMaterialsOutput := Types.GetEncryptionMaterialsOutput(encryptionMaterials := result.materials);
      if !(MultiKeyring.Verified?(keyring) || keyring is MultiKeyring.MultiKeyring) {
        :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(encryptionMaterialsOutput.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Could not retrieve materials required for encryption"));
        :- Need(Materials.ValidEncryptionMaterialsTransition(materials, encryptionMaterialsOutput.encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring returned an invalid response"));
      }
      output := Success(encryptionMaterialsOutput);
    }

    predicate DecryptMaterialsEnsuresPublicly(input: Types.DecryptMaterialsInput, output: Result<Types.DecryptMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> (output.Success? ==> Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)) && (output.Success? ==> CMM.ReproducedEncryptionContext?(input)) && (!CMM.ReproducedEncryptionContext?(input) ==> output.Failure?) && (output.Success? ==> CMM.EncryptionContextComplete(input, output.value.decryptionMaterials))
      decreases input, output
    {
      (output.Success? ==>
        CMM.ReproducedEncryptionContext?(input)) &&
      (!CMM.ReproducedEncryptionContext?(input) ==>
        output.Failure?) &&
      (output.Success? ==>
        true &&
        Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)) &&
      (output.Success? ==>
        CMM.EncryptionContextComplete(input, output.value.decryptionMaterials))
    }

    method {:vcs_split_on_every_assert} DecryptMaterials'(input: Types.DecryptMaterialsInput) returns (output: Result<Types.DecryptMaterialsOutput, Types.Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures true && ValidState()
      ensures DecryptMaterialsEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures (AlgorithmSuites.GetSuite(input.algorithmSuiteId).signature.None? <==> Materials.EC_PUBLIC_KEY_FIELD in input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])) ==> output.Failure?
      ensures Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithmSuiteId, input.commitmentPolicy).Fail? ==> output.Failure?
      ensures output.Success? && AlgorithmSuites.GetSuite(input.algorithmSuiteId).signature.ECDSA? ==> Materials.DecodeVerificationKey(input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])).Success? && output.value.decryptionMaterials.verificationKey.Some? && output.value.decryptionMaterials.verificationKey == Some(Materials.DecodeVerificationKey(input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[])).value.value)
      ensures output.Success? ==> input.algorithmSuiteId == output.value.decryptionMaterials.algorithmSuite.id && (output.value.decryptionMaterials.algorithmSuite.signature.ECDSA? ==> output.value.decryptionMaterials.verificationKey.Some?) && (0 < |output.value.decryptionMaterials.requiredEncryptionContextKeys| ==> input.reproducedEncryptionContext.Some?) && forall key: ValidUTF8Bytes {:trigger key in input.reproducedEncryptionContext.value} {:trigger key in input.encryptionContext} {:trigger key in output.value.decryptionMaterials.requiredEncryptionContextKeys} | key in output.value.decryptionMaterials.requiredEncryptionContextKeys :: key !in input.encryptionContext && key in input.reproducedEncryptionContext.value
      ensures true && output.Success? ==> |keyring.History.OnDecrypt| == |old(keyring.History.OnDecrypt)| + 1 && Seq.Last(keyring.History.OnDecrypt).output.Success? && Seq.Last(keyring.History.OnDecrypt).output.value.materials.plaintextDataKey == output.value.decryptionMaterials.plaintextDataKey
      decreases Modifies - {History}
    {
      :- Commitment.ValidateCommitmentPolicyOnDecrypt(input.algorithmSuiteId, input.commitmentPolicy);
      var requiredEncryptionContextKeys := [];
      if input.reproducedEncryptionContext.Some? {
        var keysSet := input.reproducedEncryptionContext.value.Keys;
        ghost var keysSet' := keysSet;
        var keysSeq := SortedSets.ComputeSetToSequence(keysSet);
        var i: uint64 := 0;
        SequenceIsSafeBecauseItIsInMemory(keysSeq);
        while i < |keysSeq| as uint64
          invariant Seq.HasNoDuplicates(keysSeq)
          invariant forall j: int {:trigger keysSeq[j]} | 0 <= j < i as nat && i as nat < |keysSeq| :: keysSeq[j] !in keysSet'
          invariant forall j: int {:trigger keysSeq[j]} | i as nat <= j < |keysSeq| :: keysSeq[j] in keysSet'
          invariant |keysSet'| == |keysSeq| - i as nat
          invariant forall key: seq<BoundedInts.uint8> {:trigger input.encryptionContext[key]} {:trigger input.reproducedEncryptionContext.value[key]} {:trigger key in keysSet'} {:trigger key in input.encryptionContext} {:trigger key in input.reproducedEncryptionContext.value} | key in input.reproducedEncryptionContext.value && key in input.encryptionContext && key !in keysSet' :: input.reproducedEncryptionContext.value[key] == input.encryptionContext[key]
          invariant forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in requiredEncryptionContextKeys} | key in requiredEncryptionContextKeys :: key !in input.encryptionContext
          decreases |keysSeq| as uint64 as int - i as int
        {
          var key := keysSeq[i];
          if key in input.encryptionContext {
            :- Need(input.reproducedEncryptionContext.value[key] == input.encryptionContext[key], Types.AwsCryptographicMaterialProvidersException(message := "Encryption context does not match reproduced encryption context."));
          } else {
            requiredEncryptionContextKeys := requiredEncryptionContextKeys + [key];
          }
          keysSet' := keysSet' - {key};
          i := i + 1;
          assert forall j: int {:trigger keysSeq[j]} | i as nat <= j < |keysSeq| :: keysSeq[j] in keysSet' by {
            reveal Seq.HasNoDuplicates();
          }
        }
      }
      var materials :- Materials.InitializeDecryptionMaterials(Types.InitializeDecryptionMaterialsInput(algorithmSuiteId := input.algorithmSuiteId, encryptionContext := input.encryptionContext + input.reproducedEncryptionContext.UnwrapOr(map[]), requiredEncryptionContextKeys := requiredEncryptionContextKeys));
      var result :- keyring.OnDecrypt(Types.OnDecryptInput(materials := materials, encryptedDataKeys := input.encryptedDataKeys));
      if !(MultiKeyring.Verified?(keyring) || keyring is MultiKeyring.MultiKeyring) {
        :- Need(Materials.DecryptionMaterialsTransitionIsValid(materials, result.materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring.OnDecrypt failed to decrypt the plaintext data key."));
      }
      return Success(Types.DecryptMaterialsOutput(decryptionMaterials := result.materials));
    }
  }
}

module {:options "-functionSyntax:4"} MultiKeyring {
  predicate method Verified?(keyring: Types.IKeyring): (outcome: bool)
    ensures outcome ==> keyring is Keyring.VerifiableInterface
    decreases keyring
  {
    keyring is RawAESKeyring.RawAESKeyring || keyring is RawECDHKeyring.RawEcdhKeyring || keyring is RawRSAKeyring.RawRSAKeyring || keyring is AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring || keyring is AwsKmsEcdhKeyring.AwsKmsEcdhKeyring || keyring is AwsKmsHierarchicalKeyring.AwsKmsHierarchicalKeyring || keyring is AwsKmsKeyring.AwsKmsKeyring || keyring is AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring || keyring is AwsKmsMrkKeyring.AwsKmsMrkKeyring || keyring is AwsKmsRsaKeyring.AwsKmsRsaKeyring
  }

  method AttemptDecryptDataKey(keyring: Types.IKeyring, input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
    requires keyring.ValidState()
    modifies keyring.Modifies
    ensures keyring.ValidState()
    ensures res.Success? ==> res.value.materials.plaintextDataKey.Some? && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
    decreases keyring, input
  {
    var output :- keyring.OnDecrypt(input);
    if !(Verified?(keyring) || keyring is MultiKeyring) {
      :- Need(Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring performed invalid material transition"));
    }
    return Success(output);
  }

  function GatherModifies(generatorKeyring: Option<Types.IKeyring>, childKeyrings: seq<Types.IKeyring>): (mod: set<object>)
    decreases generatorKeyring, childKeyrings
  {
    (set k: Types.IKeyring, m: object {:trigger m in k.Modifies} | k in childKeyrings && m in k.Modifies :: m) + if generatorKeyring.Some? then generatorKeyring.value.Modifies else {}
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyMaterialProvidersTypes

  import Keyring

  import Materials

  import UTF8

  import Seq

  import RawAESKeyring

  import RawECDHKeyring

  import RawRSAKeyring

  import AwsKmsDiscoveryKeyring

  import AwsKmsEcdhKeyring

  import AwsKmsHierarchicalKeyring

  import AwsKmsKeyring

  import AwsKmsMrkDiscoveryKeyring

  import AwsKmsMrkKeyring

  import AwsKmsRsaKeyring

  class MultiKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      (generatorKeyring.Some? ==>
        History !in generatorKeyring.value.Modifies &&
        generatorKeyring.value.ValidState() &&
        generatorKeyring.value.Modifies <= Modifies) &&
      (forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k.Modifies} {:trigger k in childKeyrings} | k in childKeyrings :: 
        History !in k.Modifies &&
        k.ValidState() &&
        k.Modifies <= Modifies) &&
      (generatorKeyring.None? ==>
        0 < |childKeyrings|)
    }

    const generatorKeyring: Option<Types.IKeyring>
    const childKeyrings: seq<Types.IKeyring>

    constructor (generatorKeyring: Option<Types.IKeyring>, childKeyrings: seq<Types.IKeyring>)
      requires generatorKeyring.Some? || |childKeyrings| > 0
      requires (generatorKeyring.Some? ==> generatorKeyring.value.ValidState()) && forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k in childKeyrings} | k in childKeyrings :: k.ValidState()
      requires |childKeyrings| == 0 ==> generatorKeyring.Some?
      requires generatorKeyring.None? ==> |childKeyrings| > 0
      ensures this.generatorKeyring == generatorKeyring
      ensures this.childKeyrings == childKeyrings
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - GatherModifies(generatorKeyring, childKeyrings))
      decreases generatorKeyring, childKeyrings
    {
      this.generatorKeyring := generatorKeyring;
      this.childKeyrings := childKeyrings;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + GatherModifies(generatorKeyring, childKeyrings);
      new;
      assert true && History in Modifies;
      assert true && (generatorKeyring.Some? ==> History !in generatorKeyring.value.Modifies && generatorKeyring.value.ValidState() && generatorKeyring.value.Modifies <= Modifies);
      assert true && forall k: Types.IKeyring {:trigger k.ValidState()} {:trigger k.Modifies} {:trigger k in childKeyrings} | k in childKeyrings :: History !in k.Modifies && k.ValidState() && k.Modifies <= Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      ensures res.Success? ==> true && res.value.materials.plaintextDataKey.Some?
      ensures this.generatorKeyring.None? && input.materials.plaintextDataKey.None? ==> res.Failure?
      ensures this.generatorKeyring.Some? && input.materials.plaintextDataKey.Some? ==> res.Failure?
      decreases Modifies - {History}
    {
      if this.generatorKeyring.None? && input.materials.plaintextDataKey.None? {
        var exception := "Need either a generator keyring or input encryption materials which contain a plaintext data key";
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := exception));
      }
      var returnMaterials := input.materials;
      if this.generatorKeyring.Some? {
        :- Need(input.materials.plaintextDataKey.None?, Types.AwsCryptographicMaterialProvidersException(message := "This multi keyring has a generator but provided Encryption Materials already contain plaintext data key"));
        var onEncryptOutput := this.generatorKeyring.value.OnEncrypt(input);
        :- Need(onEncryptOutput.Success?, if onEncryptOutput.Failure? then onEncryptOutput.error else Types.AwsCryptographicMaterialProvidersException(message := "Unexpected failure. Input to Need is !Success."));
        if !(Verified?(generatorKeyring.value) || generatorKeyring.value is MultiKeyring) {
          :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := "Could not retrieve materials required for encryption"));
          :- Need(Materials.ValidEncryptionMaterialsTransition(input.materials, onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := "Generator keyring returned invalid encryption materials"));
        }
        returnMaterials := onEncryptOutput.value.materials;
      }
      SequenceIsSafeBecauseItIsInMemory(this.childKeyrings);
      for i: uint64 := 0 to |this.childKeyrings| as uint64
        invariant 0 == i && this.generatorKeyring.None? ==> returnMaterials == input.materials
        invariant 0 < i || this.generatorKeyring.Some? ==> Materials.ValidEncryptionMaterialsTransition(input.materials, returnMaterials) && Materials.EncryptionMaterialsHasPlaintextDataKey(returnMaterials)
        invariant returnMaterials.plaintextDataKey.Some?
        invariant unchanged(History)
        invariant i as nat < |this.childKeyrings| ==> this.childKeyrings[i].Modifies <= Modifies
      {
        var onEncryptInput := Types.OnEncryptInput(materials := returnMaterials);
        var child: Types.IKeyring := this.childKeyrings[i];
        var onEncryptOutput := child.OnEncrypt(onEncryptInput);
        :- Need(onEncryptOutput.Success?, Types.AwsCryptographicMaterialProvidersException(message := "Child keyring failed to encrypt plaintext data key"));
        if !(Verified?(child) || child is MultiKeyring) {
          :- Need(Materials.EncryptionMaterialsHasPlaintextDataKey(onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := "Could not retrieve materials required for encryption"));
          :- Need(Materials.ValidEncryptionMaterialsTransition(returnMaterials, onEncryptOutput.value.materials), Types.AwsCryptographicMaterialProvidersException(message := "Child keyring performed invalid transition on encryption materials"));
        }
        returnMaterials := onEncryptOutput.value.materials;
      }
      return Success(Types.OnEncryptOutput(materials := returnMaterials));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures Materials.DecryptionMaterialsWithPlaintextDataKey(input.materials) ==> res.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(input.materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      var failures: seq<Types.Error> := [];
      if this.generatorKeyring.Some? {
        var result := AttemptDecryptDataKey(this.generatorKeyring.value, input);
        if result.Success? {
          if result.value.materials.plaintextDataKey.Some? {
            return Success(result.value);
          }
        } else {
          failures := failures + [result.error];
        }
      }
      SequenceIsSafeBecauseItIsInMemory(this.childKeyrings);
      for j: uint64 := 0 to |this.childKeyrings| as uint64
        invariant Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials)
        invariant unchanged(History)
      {
        var result := AttemptDecryptDataKey(this.childKeyrings[j], input);
        if result.Success? {
          return Success(result.value);
        } else {
          failures := failures + [result.error];
        }
      }
      var combinedResult := Types.CollectionOfErrors(list := failures, message := "No Configured Keyring was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.");
      return Failure(combinedResult);
    }
  }
}

module AwsKmsRsaKeyring {
  const MIN_KMS_RSA_KEY_LEN: Crypto.RSAModulusLengthBits := 2048

  method EncryptionContextDigest(cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient, encryptionContext: Types.EncryptionContext) returns (output: Result<seq<uint8>, Types.Error>)
    requires cryptoPrimitives.ValidState()
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    decreases cryptoPrimitives, encryptionContext
  {
    var canonicalEC :- CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var DigestInput := Crypto.DigestInput(digestAlgorithm := Crypto.SHA_384, message := canonicalEC);
    var maybeDigest := cryptoPrimitives.Digest(DigestInput);
    var digest :- maybeDigest.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    return Success(digest);
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import UTF8

  import UUID

  import AtomicPrimitives

  import Crypto = AwsCryptographyPrimitivesTypes

  import Keyring

  import Materials

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import CanonicalEncryptionContext

  import AwsArnParsing

  import opened Constants

  import AlgorithmSuites

  import Seq

  import MaterialWrapping

  import EdkWrapping

  import AwsKmsUtils

  import ErrorMessages

  class AwsKmsRsaKeyring extends Keyring.VerifiableInterface {
    const client: Option<KMS.IKMSClient>
    const grantTokens: KMS.GrantTokenList
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const awsKmsArn: AwsArnParsing.AwsKmsIdentifier
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const publicKey: Option<seq<uint8>>
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState() &&
      (client.Some? ==>
        client.value.ValidState() &&
        client.value.Modifies <= Modifies &&
        History !in client.value.Modifies) &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?) &&
      UTF8.Encode(awsKmsKey).Success? &&
      (publicKey.Some? ==>
        ValidRSAKeyLength(publicKey.value))
    }

    predicate ValidRSAKeyLength(publicKey: seq<uint8>)
      decreases publicKey
    {
      ghost var rsaKeyLengthRes: Result<GetRSAKeyModulusLengthOutput, Error> := cryptoPrimitives.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := publicKey));
      rsaKeyLengthRes.Success? &&
      rsaKeyLengthRes.value.length >= MIN_KMS_RSA_KEY_LEN
    }

    constructor (publicKey: Option<seq<uint8>>, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, client: Option<KMS.IKMSClient>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient, grantTokens: KMS.GrantTokenList)
      requires cryptoPrimitives.ValidState()
      requires client.Some? ==> client.value.ValidState()
      requires publicKey.Some? ==> true && var rsaKeyLengthRes: Result<GetRSAKeyModulusLengthOutput, Error> := cryptoPrimitives.GetRSAKeyModulusLength(Crypto.GetRSAKeyModulusLengthInput(publicKey := publicKey.value)); rsaKeyLengthRes.Success? && rsaKeyLengthRes.value.length >= MIN_KMS_RSA_KEY_LEN
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - (if client.Some? then client.value.Modifies else {}) - cryptoPrimitives.Modifies)
      decreases publicKey, awsKmsKey, paddingScheme, client, cryptoPrimitives, grantTokens
    {
      History := new Types.IKeyringCallHistory();
      Modifies := {History};
      if client.Some? {
        Modifies := Modifies + client.value.Modifies;
      }
      Modifies := Modifies + cryptoPrimitives.Modifies;
      var parsedAwsKmsId := AwsArnParsing.ParseAwsKmsIdentifier(awsKmsKey);
      this.publicKey := publicKey;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.paddingScheme := paddingScheme;
      this.client := client;
      this.cryptoPrimitives := cryptoPrimitives;
      this.grantTokens := grantTokens;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.ValidEncryptionMaterialsTransition(input.materials, res.value.materials)
      ensures publicKey.None? || |publicKey.Extract()| == 0 ==> res.Failure?
      ensures !input.materials.algorithmSuite.signature.None? ==> res.Failure?
      decreases Modifies - {History}
    {
      OptionalSequenceIsSafeBecauseItIsInMemory(this.publicKey);
      :- Need(this.publicKey.Some? && |this.publicKey.Extract()| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "A AwsKmsRsaKeyring without a public key cannot provide OnEncrypt"));
      :- Need(input.materials.algorithmSuite.signature.None?, Types.AwsCryptographicMaterialProvidersException(message := "AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing." + " Please specify an algorithm suite without asymmetric signing."));
      var wrap := new KmsRsaWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var generateAndWrap := new KmsRsaGenerateAndWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsRsaWrapInfo>(encryptionMaterials := input.materials, wrap := wrap, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := RSA_PROVIDER_ID, keyProviderInfo := UTF8.Encode(awsKmsKey).value, ciphertext := wrapOutput.wrappedMaterial);
      var returnMaterials;
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        returnMaterials :- Materials.EncryptionMaterialAddDataKey(input.materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        returnMaterials :- Materials.EncryptionMaterialAddEncryptedDataKeys(input.materials, [edk], symmetricSigningKeyList);
      }
      return Success(Types.OnEncryptOutput(materials := returnMaterials));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures client.None? ==> res.Failure?
      ensures !input.materials.algorithmSuite.signature.None? ==> res.Failure?
      decreases Modifies - {History}
    {
      :- Need(client.Some?, Types.AwsCryptographicMaterialProvidersException(message := "An AwsKmsRsaKeyring without an AWS KMS client cannot provide OnDecrypt"));
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      :- AwsKmsUtils.OkForDecrypt(awsKmsArn, awsKmsKey);
      :- Need(input.materials.algorithmSuite.signature.None?, Types.AwsCryptographicMaterialProvidersException(message := "AwsKmsRsaKeyring cannot be used with an Algorithm Suite with asymmetric signing." + " Please specify an algorithm suite without asymmetric signing."));
      var filter := new AwsKmsUtils.OnDecryptMrkAwareEncryptedDataKeyFilter(awsKmsArn, RSA_PROVIDER_ID);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      var encryptionContextDigest :- EncryptionContextDigest(cryptoPrimitives, materials.encryptionContext);
      var decryptClosure := new DecryptSingleAWSRSAEncryptedDataKey(materials, client.value, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      assert decryptClosure.Ensures(Seq.Last(attempts).input, Success(SealedDecryptionMaterials), Seq.DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class DecryptSingleAWSRSAEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const encryptionContextDigest: seq<uint8>
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, encryptionContextDigest: seq<uint8>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.paddingScheme == paddingScheme && this.encryptionContextDigest == encryptionContextDigest && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.paddingScheme := paddingScheme;
      this.encryptionContextDigest := encryptionContextDigest;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme)) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext.value == encryptionContextDigest + res.value.plaintextDataKey.value) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var unwrap := new KmsRsaUnwrapKeyMaterial(client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens);
      var unwrapOutput :- EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, unwrap);
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  datatype KmsRsaUnwrapInfo = KmsRsaUnwrapInfo

  datatype KmsRsaWrapInfo = KmsRsaWrapInfo

  class KmsRsaGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<KmsRsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: KMS.EncryptionAlgorithmSpec, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures this.publicKey == publicKey && this.cryptoPrimitives == cryptoPrimitives && this.paddingScheme == paddingScheme
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.cryptoPrimitives := cryptoPrimitives;
      this.paddingScheme := paddingScheme;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?)
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsRsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new KmsRsaWrapKeyMaterial(publicKey, paddingScheme, cryptoPrimitives);
      var wrapOutput: MaterialWrapping.WrapOutput<KmsRsaWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := KmsRsaWrapInfo());
      return Success(output);
    }
  }

  class KmsRsaWrapKeyMaterial extends MaterialWrapping.WrapMaterial<KmsRsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: KMS.EncryptionAlgorithmSpec, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?
      ensures this.publicKey == publicKey && this.cryptoPrimitives == cryptoPrimitives && this.paddingScheme == paddingScheme
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.cryptoPrimitives := cryptoPrimitives;
      this.paddingScheme := paddingScheme;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      (paddingScheme.RSAES_OAEP_SHA_1? || paddingScheme.RSAES_OAEP_SHA_256?)
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<KmsRsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var encryptionContextDigest :- EncryptionContextDigest(cryptoPrimitives, input.encryptionContext);
      var padding := match paddingScheme case RSAES_OAEP_SHA_1() => Crypto.OAEP_SHA1 case RSAES_OAEP_SHA_256() => Crypto.OAEP_SHA256;
      var RSAEncryptOutput := cryptoPrimitives.RSAEncrypt(Crypto.RSAEncryptInput(padding := padding, publicKey := publicKey, plaintext := encryptionContextDigest + input.plaintextMaterial));
      var ciphertext :- RSAEncryptOutput.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := ciphertext, wrapInfo := KmsRsaWrapInfo());
      return Success(output);
    }
  }

  class KmsRsaUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<KmsRsaUnwrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsArnParsing.AwsKmsIdentifierString
    const paddingScheme: KMS.EncryptionAlgorithmSpec
    const encryptionContextDigest: seq<uint8>
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsArnParsing.AwsKmsIdentifierString, paddingScheme: KMS.EncryptionAlgorithmSpec, encryptionContextDigest: seq<uint8>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.paddingScheme == paddingScheme && this.encryptionContextDigest == encryptionContextDigest && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, paddingScheme, encryptionContextDigest, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.paddingScheme := paddingScheme;
      this.encryptionContextDigest := encryptionContextDigest;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        KMS.IsValid_CiphertextType(input.wrappedMaterial) &&
        0 < |client.History.Decrypt| &&
        KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme)) == Seq.Last(client.History.Decrypt).input &&
        Seq.Last(client.History.Decrypt).output.Success? &&
        Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? &&
        Seq.Last(client.History.Decrypt).output.value.Plaintext.value == encryptionContextDigest + res.value.unwrappedMaterial &&
        Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<KmsRsaUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      :- Need(KMS.IsValid_CiphertextType(input.wrappedMaterial), Types.AwsCryptographicMaterialProvidersException(message := "Ciphertext length invalid"));
      var decryptRequest := KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := None, GrantTokens := Some(grantTokens), EncryptionAlgorithm := Some(paddingScheme));
      var maybeDecryptResponse := client.Decrypt(decryptRequest);
      var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(decryptResponse.KeyId.Some? && decryptResponse.KeyId.value == awsKmsKey && decryptResponse.Plaintext.Some?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from KMS Decrypt"));
      OptionalSequenceIsSafeBecauseItIsInMemory(decryptResponse.Plaintext);
      SequenceIsSafeBecauseItIsInMemory(encryptionContextDigest);
      :- Need(encryptionContextDigest <= decryptResponse.Plaintext.value && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as uint64 + |encryptionContextDigest| as uint64 == |decryptResponse.Plaintext.value| as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Encryption context digest does not match expected value."));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResponse.Plaintext.value[|encryptionContextDigest| as uint64..], unwrapInfo := KmsRsaUnwrapInfo());
      return Success(output);
    }
  }
}

module ErrorMessages {
  const SALT_LENGTH := 16 as uint64
  const IV_LENGTH := 12 as uint64
  const VERSION_LENGTH := 16 as uint64
  const KMS_ECDH_DISCOVERY_ENCRYPT_ERROR := "KmsPublicKeyDiscovery Key Agreement Scheme is forbidden on encrypt."
  const RAW_ECDH_DISCOVERY_ENCRYPT_ERROR := "PublicKeyDiscovery Key Agreement Scheme is forbidden on encrypt."
  const RAW_ECDH_EPHEMERAL_DECRYPT_ERROR := "EphemeralPrivateKeyToStaticPublicKey Key Agreement Scheme is forbidden on decrypt."

  function method IncorrectRawDataKeys(datakey: string, keyringName: string, keyProviderId: string): string
    decreases datakey, keyringName, keyProviderId
  {
    "EncryptedDataKey " + datakey + " did not match " + keyringName + ". " + "Expected: keyProviderId: " + keyProviderId + ".\n"
  }

  function method {:opaque} IncorrectDataKeys(encryptedDataKeys: Types.EncryptedDataKeyList, material: Types.AlgorithmSuiteInfo, errMsg: string := ""): Result<string, Types.Error>
    decreases encryptedDataKeys, material, errMsg
  {
    var expectedValue: string :- IncorrectDataKeysExpectedValues(encryptedDataKeys, material, errMsg); Success("Unable to decrypt data key: No Encrypted Data Keys found to match. \n Expected: \n" + expectedValue)
  }

  function method {:tailrecursion} {:opaque} IncorrectDataKeysExpectedValues(encryptedDataKeys: Types.EncryptedDataKeyList, material: Types.AlgorithmSuiteInfo, errMsg: string := ""): Result<string, Types.Error>
    decreases |encryptedDataKeys|
  {
    SequenceIsSafeBecauseItIsInMemory(encryptedDataKeys);
    if |encryptedDataKeys| as uint64 == 0 then
      Success(errMsg)
    else
      var encryptedDataKey: EncryptedDataKey := encryptedDataKeys[0 as uint32]; var extractedKeyProviderId: string :- UTF8.Decode(encryptedDataKey.keyProviderId).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); var extractedKeyProviderInfo: string :- UTF8.Decode(encryptedDataKey.keyProviderInfo).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); if extractedKeyProviderId != "aws-kms-hierarchy" then IncorrectDataKeysExpectedValues(encryptedDataKeys[1 as uint32..], material, errMsg + "KeyProviderId: " + extractedKeyProviderId + ", KeyProviderInfo: " + extractedKeyProviderInfo + "\n") else var providerWrappedMaterial: seq<uint8> :- EdkWrapping.GetProviderWrappedMaterial(encryptedDataKey.ciphertext, material); SequenceIsSafeBecauseItIsInMemory(providerWrappedMaterial); var EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX: BoundedInts.uint64 := SALT_LENGTH + IV_LENGTH; var EDK_CIPHERTEXT_VERSION_INDEX: BoundedInts.uint64 := EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX + VERSION_LENGTH; :- Need(EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX < EDK_CIPHERTEXT_VERSION_INDEX, Types.AwsCryptographicMaterialProvidersException(message := "Wrong branch key version index.")); :- Need(|providerWrappedMaterial| as uint64 >= EDK_CIPHERTEXT_VERSION_INDEX, Types.AwsCryptographicMaterialProvidersException(message := "Incorrect ciphertext structure.")); var branchKeyVersionUuid: seq<BoundedInts.uint8> := providerWrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX]; var branchVersion: string :- UUID.FromByteArray(branchKeyVersionUuid).MapFailure((e: seq<char>) => Types.AwsCryptographicMaterialProvidersException(message := e)); IncorrectDataKeysExpectedValues(encryptedDataKeys[1 as uint32..], material, errMsg + "KeyProviderId: " + extractedKeyProviderId + ", KeyProviderInfo: " + extractedKeyProviderInfo + ", BranchKeyVersion: " + branchVersion + "\n")
  }

  import Types = AwsCryptographyMaterialProvidersTypes

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import UTF8

  import UUID

  import opened Wrappers

  import EdkWrapping
}

module EdkWrapping {
  method WrapEdkMaterial<T>(nameonly encryptionMaterials: Types.EncryptionMaterials, nameonly wrap: MaterialWrapping.WrapMaterial<T>, nameonly generateAndWrap: MaterialWrapping.GenerateAndWrapMaterial<T>)
      returns (ret: Result<WrapEdkMaterialOutput<T>, Types.Error>)
    requires wrap.Invariant()
    requires generateAndWrap.Invariant()
    modifies wrap.Modifies + generateAndWrap.Modifies
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && encryptionMaterials.plaintextDataKey.Some? ==> ret.value.WrapOnlyEdkMaterialOutput? && var wrapRes: WrapOutput<T> := WrapOutput(wrappedMaterial := ret.value.wrappedMaterial, wrapInfo := ret.value.wrapInfo); true && wrap.Ensures(WrapInput(plaintextMaterial := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), Success(wrapRes), [])
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? && encryptionMaterials.plaintextDataKey.Some? ==> ret.value.WrapOnlyEdkMaterialOutput? && ret.value.intermediateMaterial.Some? && var encryptedPdkLen: nat := (AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(encryptionMaterials.algorithmSuite)) as nat; |ret.value.wrappedMaterial| >= encryptedPdkLen && generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.intermediateMaterial.value, wrappedMaterial := ret.value.wrappedMaterial[encryptedPdkLen..], wrapInfo := ret.value.wrapInfo)), [])
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && encryptionMaterials.plaintextDataKey.None? ==> ret.value.GenerateAndWrapEdkMaterialOutput? && var generateAndWrapRes: GenerateAndWrapOutput<T> := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.plaintextDataKey, wrappedMaterial := ret.value.wrappedMaterial, wrapInfo := ret.value.wrapInfo); generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), Success(generateAndWrapRes), []) && |ret.value.plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) as nat
    ensures ret.Success? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? && encryptionMaterials.plaintextDataKey.None? ==> ret.value.GenerateAndWrapEdkMaterialOutput? && ret.value.intermediateMaterial.Some? && var encryptedPdkLen: nat := (AlgorithmSuites.GetEncryptKeyLength(encryptionMaterials.algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(encryptionMaterials.algorithmSuite)) as nat; |ret.value.wrappedMaterial| >= encryptedPdkLen && generateAndWrap.Ensures(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := ret.value.intermediateMaterial.value, wrappedMaterial := ret.value.wrappedMaterial[encryptedPdkLen..], wrapInfo := ret.value.wrapInfo)), [])
    decreases encryptionMaterials, wrap, generateAndWrap
  {
    :- Need(Materials.ValidEncryptionMaterials(encryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Invalid materials for encryption."));
    if encryptionMaterials.plaintextDataKey.Some? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- wrap.Invoke(WrapInput(plaintextMaterial := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), []);
      return Success(WrapOnlyEdkMaterialOutput(wrappedMaterial := directOutput.wrappedMaterial, symmetricSigningKey := None, wrapInfo := directOutput.wrapInfo, intermediateMaterial := None));
    } else if encryptionMaterials.plaintextDataKey.Some? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      var intermediateOutput :- IntermediateWrap(generateAndWrap := generateAndWrap, plaintextDataKey := encryptionMaterials.plaintextDataKey.value, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext);
      return Success(WrapOnlyEdkMaterialOutput(wrappedMaterial := intermediateOutput.wrappedMaterial, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), wrapInfo := intermediateOutput.wrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else if encryptionMaterials.plaintextDataKey.None? && encryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- generateAndWrap.Invoke(MaterialWrapping.GenerateAndWrapInput(algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionMaterials.encryptionContext)), []);
      return Success(GenerateAndWrapEdkMaterialOutput(plaintextDataKey := directOutput.plaintextMaterial, wrappedMaterial := directOutput.wrappedMaterial, symmetricSigningKey := None, wrapInfo := directOutput.wrapInfo, intermediateMaterial := None));
    } else if encryptionMaterials.plaintextDataKey.None? && encryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      :- Need(encryptionMaterials.algorithmSuite.commitment.HKDF?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid algorithm suite: suites with intermediate key wrapping must use key commitment."));
      var intermediateOutput :- IntermediateGenerateAndWrap(generateAndWrap := generateAndWrap, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext);
      return Success(GenerateAndWrapEdkMaterialOutput(plaintextDataKey := intermediateOutput.plaintextDataKey, wrappedMaterial := intermediateOutput.wrappedMaterial, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), wrapInfo := intermediateOutput.wrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else {
      assert false;
    }
  }

  method UnwrapEdkMaterial<T>(wrappedMaterial: seq<uint8>, decryptionMaterials: Materials.DecryptionMaterialsPendingPlaintextDataKey, unwrap: UnwrapMaterial<T>)
      returns (ret: Result<UnwrapEdkMaterialOutput<T>, Types.Error>)
    requires unwrap.Invariant()
    modifies unwrap.Modifies
    ensures ret.Failure? && decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> unwrap.Ensures(UnwrapInput(wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(decryptionMaterials.encryptionContext)), Failure(ret.error), [])
    ensures ret.Success? ==> true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := GetProviderWrappedMaterial(wrappedMaterial, decryptionMaterials.algorithmSuite); maybeProviderWrappedMaterial.Success? && (decryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? ==> ret.value.intermediateMaterial.Some?) && var unwrapRes: UnwrapOutput<T> := UnwrapOutput(unwrappedMaterial := if decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? then ret.value.plaintextDataKey else ret.value.intermediateMaterial.value, unwrapInfo := ret.value.unwrapInfo); true && unwrap.Ensures(UnwrapInput(wrappedMaterial := maybeProviderWrappedMaterial.value, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(decryptionMaterials.encryptionContext)), Success(unwrapRes), [])
    decreases wrappedMaterial, decryptionMaterials, unwrap
  {
    :- Need(Materials.ValidDecryptionMaterials(decryptionMaterials), Types.AwsCryptographicMaterialProvidersException(message := "Invalid materials for decryption."));
    if decryptionMaterials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? {
      var directOutput :- unwrap.Invoke(UnwrapInput(wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(decryptionMaterials.encryptionContext)), []);
      return Success(UnwrapEdkMaterialOutput(plaintextDataKey := directOutput.unwrappedMaterial, symmetricSigningKey := None, unwrapInfo := directOutput.unwrapInfo, intermediateMaterial := None));
    } else if decryptionMaterials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? {
      SequenceIsSafeBecauseItIsInMemory(wrappedMaterial);
      :- Need(|wrappedMaterial| as uint64 >= (decryptionMaterials.algorithmSuite.encrypt.AES_GCM.keyLength + decryptionMaterials.algorithmSuite.encrypt.AES_GCM.tagLength) as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid material for Intermediate Unwrapping"));
      var intermediateOutput :- IntermediateUnwrap(unwrap := unwrap, wrappedMaterial := wrappedMaterial, algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext);
      return Success(UnwrapEdkMaterialOutput(plaintextDataKey := intermediateOutput.plaintextDataKey, symmetricSigningKey := Some(intermediateOutput.symmetricSigningKey), unwrapInfo := intermediateOutput.unwrapInfo, intermediateMaterial := Some(intermediateOutput.intermediateMaterial)));
    } else {
      assert false;
    }
  }

  function method GetProviderWrappedMaterial(material: seq<uint8>, algSuite: Types.AlgorithmSuiteInfo): (r: Result<seq<uint8>, Types.Error>)
    ensures r.Success? && algSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> r.value == material
    ensures r.Success? && algSuite.edkWrapping.IntermediateKeyWrapping? ==> var deserializedRes: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(material, algSuite); deserializedRes.Success? && r.value == deserializedRes.value.providerWrappedIkm
    decreases material, algSuite
  {
    if algSuite.edkWrapping.DIRECT_KEY_WRAPPING? then
      Success(material)
    else
      assert algSuite.edkWrapping.IntermediateKeyWrapping?; var deserializedWrappedRes: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(material, algSuite); if deserializedWrappedRes.Failure? then Failure(Types.AwsCryptographicMaterialProvidersException(message := "Unable to deserialize Intermediate Key Wrapped material.")) else Success(deserializedWrappedRes.value.providerWrappedIkm)
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import opened Wrappers

  import opened MaterialWrapping

  import opened IntermediateKeyWrapping

  import Crypto = AwsCryptographyPrimitivesTypes

  import Types = AwsCryptographyMaterialProvidersTypes

  import AtomicPrimitives

  import Materials

  import AlgorithmSuites

  datatype WrapEdkMaterialOutput<T> = WrapOnlyEdkMaterialOutput(nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>) | GenerateAndWrapEdkMaterialOutput(nameonly plaintextDataKey: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>)

  datatype UnwrapEdkMaterialOutput<T> = UnwrapEdkMaterialOutput(nameonly plaintextDataKey: seq<uint8>, nameonly symmetricSigningKey: Option<Types.Secret>, nameonly unwrapInfo: T, ghost nameonly intermediateMaterial: Option<seq<uint8>>)
}

module IntermediateKeyWrapping {
  const KEYWRAP_MAC_INFO: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [65, 87, 83, 95, 77, 80, 76, 95, 73, 78, 84, 69, 82, 77, 69, 68, 73, 65, 84, 69, 95, 75, 69, 89, 87, 82, 65, 80, 95, 77, 65, 67]; assert s == UTF8.EncodeAscii("AWS_MPL_INTERMEDIATE_KEYWRAP_MAC"); s
  const KEYWRAP_ENC_INFO: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [65, 87, 83, 95, 77, 80, 76, 95, 73, 78, 84, 69, 82, 77, 69, 68, 73, 65, 84, 69, 95, 75, 69, 89, 87, 82, 65, 80, 95, 69, 78, 67]; assert s == UTF8.EncodeAscii("AWS_MPL_INTERMEDIATE_KEYWRAP_ENC"); s

  function method GetIvLengthZeros(len: int32): (output: seq<uint8>)
    requires len >= 0
    ensures |output| == len as nat
    ensures forall x: BoundedInts.uint8 {:trigger x in output} | x in output :: x == 0
    decreases len
  {
    if len == 12 then
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    else
      seq(len, (_ /* _v0 */: int) => 0)
  }

  method IntermediateUnwrap<T>(unwrap: UnwrapMaterial<T>, wrappedMaterial: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateUnwrapOutput<T>, Types.Error>)
    requires unwrap.Invariant()
    requires |wrappedMaterial| >= (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as nat
    requires algorithmSuite.commitment.HKDF?
    modifies unwrap.Modifies
    ensures res.Success? ==> |res.value.plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && var unwrapRes: UnwrapOutput<T> := UnwrapOutput(unwrappedMaterial := res.value.intermediateMaterial, unwrapInfo := res.value.unwrapInfo); true && unwrap.Ensures(UnwrapInput(wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, encryptionContext := encryptionContext, algorithmSuite := algorithmSuite, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext)), Success(unwrapRes), [])
    decreases unwrap, wrappedMaterial, algorithmSuite, encryptionContext
  {
    var maybeCrypto := AtomicPrimitives.AtomicPrimitives();
    var cryptoPrimitivesX: Crypto.IAwsCryptographicPrimitivesClient :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    assert cryptoPrimitivesX is AtomicPrimitives.AtomicPrimitivesClient;
    var cryptoPrimitives := cryptoPrimitivesX as AtomicPrimitives.AtomicPrimitivesClient;
    var deserializedWrapped :- DeserializeIntermediateWrappedMaterial(wrappedMaterial, algorithmSuite);
    var DeserializedIntermediateWrappedMaterial(encryptedPdk, providerWrappedIkm) := deserializedWrapped;
    var serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var unwrapOutput :- unwrap.Invoke(UnwrapInput(wrappedMaterial := providerWrappedIkm, encryptionContext := encryptionContext, algorithmSuite := algorithmSuite, serializedEC := serializedEC), []);
    var UnwrapOutput(intermediateMaterial, unwrapInfo) := unwrapOutput;
    var derivedKeys :- DeriveKeysFromIntermediateMaterial(intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives);
    var PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey, symmetricSigningKey) := derivedKeys;
    var iv: seq<uint8> := GetIvLengthZeros(AlgorithmSuites.GetEncryptIvLength(algorithmSuite));
    var tagIndex: uint64 := |encryptedPdk| as uint64 - AlgorithmSuites.GetEncryptTagLength(algorithmSuite) as uint64;
    var aad :- serializedEC;
    var decInput := Crypto.AESDecryptInput(encAlg := algorithmSuite.encrypt.AES_GCM, iv := iv, key := pdkEncryptionKey, cipherTxt := encryptedPdk[..tagIndex], authTag := encryptedPdk[tagIndex..], aad := aad);
    var decOutR := cryptoPrimitives.AESDecrypt(decInput);
    var plaintextDataKey :- decOutR.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    assert |plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat;
    return Success(IntermediateUnwrapOutput(plaintextDataKey := plaintextDataKey, symmetricSigningKey := symmetricSigningKey, unwrapInfo := unwrapInfo, intermediateMaterial := intermediateMaterial));
  }

  method IntermediateWrap<T>(generateAndWrap: GenerateAndWrapMaterial<T>, plaintextDataKey: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateWrapOutput<T>, Types.Error>)
    requires generateAndWrap.Invariant()
    requires algorithmSuite.commitment.HKDF?
    requires |plaintextDataKey| == AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) as nat
    modifies generateAndWrap.Modifies
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(res.value.wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && generateAndWrap.Ensures(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext)), Success(GenerateAndWrapOutput(plaintextMaterial := res.value.intermediateMaterial, wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, wrapInfo := res.value.wrapInfo)), []) && res.value.wrappedMaterial == maybeIntermediateWrappedMat.value.encryptedPdk + maybeIntermediateWrappedMat.value.providerWrappedIkm && |maybeIntermediateWrappedMat.value.encryptedPdk| as uint64 == (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as uint64
    decreases generateAndWrap, plaintextDataKey, algorithmSuite, encryptionContext
  {
    var maybeCrypto := AtomicPrimitives.AtomicPrimitives();
    var cryptoPrimitivesX: Crypto.IAwsCryptographicPrimitivesClient :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    assert cryptoPrimitivesX is AtomicPrimitives.AtomicPrimitivesClient;
    var cryptoPrimitives := cryptoPrimitivesX as AtomicPrimitives.AtomicPrimitivesClient;
    var generateAndWrapOutput :- generateAndWrap.Invoke(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext)), []);
    var GenerateAndWrapOutput(intermediateMaterial, providerWrappedIkm, wrapInfo) := generateAndWrapOutput;
    var derivedKeys :- DeriveKeysFromIntermediateMaterial(intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives);
    var PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey, symmetricSigningKey) := derivedKeys;
    var iv: seq<uint8> := GetIvLengthZeros(AlgorithmSuites.GetEncryptIvLength(algorithmSuite));
    var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext);
    var encInput := Crypto.AESEncryptInput(encAlg := algorithmSuite.encrypt.AES_GCM, iv := iv, key := pdkEncryptionKey, msg := plaintextDataKey, aad := aad);
    var encOutR := cryptoPrimitives.AESEncrypt(encInput);
    var encryptedPdk :- encOutR.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    assert |encryptedPdk.cipherText + encryptedPdk.authTag| == (AlgorithmSuites.GetEncryptKeyLength(algorithmSuite) + AlgorithmSuites.GetEncryptTagLength(algorithmSuite)) as nat;
    var serializedMaterial := encryptedPdk.cipherText + encryptedPdk.authTag + providerWrappedIkm;
    return Success(IntermediateWrapOutput(wrappedMaterial := serializedMaterial, symmetricSigningKey := symmetricSigningKey, wrapInfo := wrapInfo, intermediateMaterial := intermediateMaterial));
  }

  method IntermediateGenerateAndWrap<T>(generateAndWrap: GenerateAndWrapMaterial<T>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext)
      returns (res: Result<IntermediateGenerateAndWrapOutput<T>, Types.Error>)
    requires generateAndWrap.Invariant()
    requires algorithmSuite.commitment.HKDF?
    modifies generateAndWrap.Modifies
    ensures res.Success? ==> true && var maybeIntermediateWrappedMat: Result<DeserializedIntermediateWrappedMaterial, Types.Error> := DeserializeIntermediateWrappedMaterial(res.value.wrappedMaterial, algorithmSuite); maybeIntermediateWrappedMat.Success? && generateAndWrap.Ensures(GenerateAndWrapInput(algorithmSuite := algorithmSuite, encryptionContext := encryptionContext, serializedEC := CanonicalEncryptionContext.EncryptionContextToAAD(encryptionContext)), Success(GenerateAndWrapOutput(plaintextMaterial := res.value.intermediateMaterial, wrappedMaterial := maybeIntermediateWrappedMat.value.providerWrappedIkm, wrapInfo := res.value.wrapInfo)), [])
    decreases generateAndWrap, algorithmSuite, encryptionContext
  {
    var maybeCrypto := AtomicPrimitives.AtomicPrimitives();
    var cryptoPrimitives :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := GetEncryptKeyLength(algorithmSuite)));
    var plaintextDataKey :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    var wrapOutput :- IntermediateWrap(generateAndWrap, plaintextDataKey, algorithmSuite, encryptionContext);
    return Success(IntermediateGenerateAndWrapOutput(plaintextDataKey := plaintextDataKey, wrappedMaterial := wrapOutput.wrappedMaterial, symmetricSigningKey := wrapOutput.symmetricSigningKey, wrapInfo := wrapOutput.wrapInfo, intermediateMaterial := wrapOutput.intermediateMaterial));
  }

  function method DeserializeIntermediateWrappedMaterial(material: seq<uint8>, algSuite: Types.AlgorithmSuiteInfo): (ret: Result<DeserializedIntermediateWrappedMaterial, Types.Error>)
    decreases material, algSuite
  {
    SequenceIsSafeBecauseItIsInMemory(material);
    :- Need(|material| as uint64 >= (AlgorithmSuites.GetEncryptKeyLength(algSuite) + AlgorithmSuites.GetEncryptTagLength(algSuite)) as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Unable to deserialize Intermediate Key Wrapped material: too short.")); var encryptedPdkLen: BoundedInts.int32 := AlgorithmSuites.GetEncryptKeyLength(algSuite) + AlgorithmSuites.GetEncryptTagLength(algSuite); Success(DeserializedIntermediateWrappedMaterial(encryptedPdk := material[..encryptedPdkLen], providerWrappedIkm := material[encryptedPdkLen..]))
  }

  method DeriveKeysFromIntermediateMaterial(intermediateMaterial: seq<uint8>, algorithmSuite: Types.AlgorithmSuiteInfo, encryptionContext: Types.EncryptionContext, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<PdkEncryptionAndSymmetricSigningKeys, Types.Error>)
    requires cryptoPrimitives.ValidState()
    requires algorithmSuite.commitment.HKDF?
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    decreases intermediateMaterial, algorithmSuite, encryptionContext, cryptoPrimitives
  {
    var hkdfExtractInput := Crypto.HkdfExtractInput(digestAlgorithm := algorithmSuite.commitment.HKDF.hmac, salt := None, ikm := intermediateMaterial);
    var maybePseudoRandomKey := cryptoPrimitives.HkdfExtract(hkdfExtractInput);
    var pseudoRandomKey :- maybePseudoRandomKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var symmetricSigningKeyInput := Crypto.HkdfExpandInput(digestAlgorithm := algorithmSuite.commitment.HKDF.hmac, prk := pseudoRandomKey, info := KEYWRAP_MAC_INFO, expectedLength := algorithmSuite.commitment.HKDF.outputKeyLength);
    var pdkEncryptionKeyInput := symmetricSigningKeyInput.(info := KEYWRAP_ENC_INFO);
    var maybeSymmetricSigningKey := cryptoPrimitives.HkdfExpand(symmetricSigningKeyInput);
    var symmetricSigningKey :- maybeSymmetricSigningKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    var maybePdkEncryptionKey := cryptoPrimitives.HkdfExpand(pdkEncryptionKeyInput);
    var pdkEncryptionKey :- maybePdkEncryptionKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
    return Success(PdkEncryptionAndSymmetricSigningKeys(pdkEncryptionKey := pdkEncryptionKey, symmetricSigningKey := symmetricSigningKey));
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import opened Wrappers

  import opened MaterialWrapping

  import opened AlgorithmSuites

  import Crypto = AwsCryptographyPrimitivesTypes

  import Types = AwsCryptographyMaterialProvidersTypes

  import AtomicPrimitives

  import Materials

  import UTF8

  import HKDF

  import CanonicalEncryptionContext

  datatype IntermediateUnwrapOutput<T> = IntermediateUnwrapOutput(nameonly plaintextDataKey: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly unwrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype IntermediateGenerateAndWrapOutput<T> = IntermediateGenerateAndWrapOutput(nameonly plaintextDataKey: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype IntermediateWrapOutput<T> = IntermediateWrapOutput(nameonly wrappedMaterial: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>, nameonly wrapInfo: T, ghost nameonly intermediateMaterial: seq<uint8>)

  datatype DeserializedIntermediateWrappedMaterial = DeserializedIntermediateWrappedMaterial(nameonly encryptedPdk: seq<uint8>, nameonly providerWrappedIkm: seq<uint8>)

  datatype PdkEncryptionAndSymmetricSigningKeys = PdkEncryptionAndSymmetricSigningKeys(nameonly pdkEncryptionKey: seq<uint8>, nameonly symmetricSigningKey: seq<uint8>)
}

module CanonicalEncryptionContext {
  function method EncryptionContextToAAD(encryptionContext: Types.EncryptionContext): (res: Result<seq<uint8>, Types.Error>)
    decreases encryptionContext
  {
    MapIsSafeBecauseItIsInMemory(encryptionContext);
    :- Need(|encryptionContext| as uint64 < UINT16_LIMIT as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Encryption Context is too large")); var keys: seq<seq<uint8>> := SortedSets.ComputeSetToOrderedSequence2(encryptionContext.Keys, UInt.UInt8Less); if |keys| as uint16 == 0 then Success([]) else var KeyIntoPairBytes: seq<uint8> --> Result<seq<uint8>, Error> := (k: seq<uint8>) requires k in encryptionContext => var v: ValidUTF8Bytes := encryptionContext[k]; :- Need(HasUint16Len(k) && HasUint16Len(v), Types.AwsCryptographicMaterialProvidersException(message := "Unable to serialize encryption context")); Success(UInt16ToSeq(|k| as uint16) + k + UInt16ToSeq(|v| as uint16) + v); var pairsBytes: seq<seq<uint8>> :- Seq.MapWithResult(KeyIntoPairBytes, keys); var allBytes: seq<uint8> := UInt16ToSeq(|keys| as uint16) + Seq.Flatten(pairsBytes); Success(allBytes)
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Types = AwsCryptographyMaterialProvidersTypes

  import opened Wrappers

  import Seq

  import SortedSets
}

module MaterialWrapping {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import AtomicPrimitives

  import Materials

  import AlgorithmSuites

  import CanonicalEncryptionContext
  datatype GenerateAndWrapInput = GenerateAndWrapInput(nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext, nameonly serializedEC: Result<seq<uint8>, Types.Error>)

  datatype GenerateAndWrapOutput<T> = GenerateAndWrapOutput(nameonly plaintextMaterial: seq<uint8>, nameonly wrappedMaterial: seq<uint8>, nameonly wrapInfo: T)

  datatype WrapInput = WrapInput(nameonly plaintextMaterial: seq<uint8>, nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext, nameonly serializedEC: Result<seq<uint8>, Types.Error>)

  datatype WrapOutput<T> = WrapOutput(nameonly wrappedMaterial: seq<uint8>, nameonly wrapInfo: T)

  datatype UnwrapInput = UnwrapInput(nameonly wrappedMaterial: seq<uint8>, nameonly algorithmSuite: Types.AlgorithmSuiteInfo, nameonly encryptionContext: Types.EncryptionContext, nameonly serializedEC: Result<seq<uint8>, Types.Error>)

  datatype UnwrapOutput<T> = UnwrapOutput(nameonly unwrappedMaterial: seq<uint8>, nameonly unwrapInfo: T)

  trait {:termination false} GenerateAndWrapMaterial<T> extends ActionWithResult<GenerateAndWrapInput, GenerateAndWrapOutput<T>, Types.Error> {
    method Invoke(input: GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<GenerateAndWrapInput, Result<GenerateAndWrapOutput<T>, Types.Error>>>) returns (r: Result<GenerateAndWrapOutput<T>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies

    predicate Requires(input: GenerateAndWrapInput): (outcome: bool)
      decreases input
    {
      true &&
      input.serializedEC == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext)
    }
  }

  trait {:termination false} WrapMaterial<T> extends ActionWithResult<WrapInput, WrapOutput<T>, Types.Error> {
    method Invoke(input: WrapInput, ghost attemptsState: seq<ActionInvoke<WrapInput, Result<WrapOutput<T>, Types.Error>>>) returns (r: Result<WrapOutput<T>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      decreases Modifies

    predicate Requires(input: WrapInput): (outcome: bool)
      decreases input
    {
      true &&
      input.serializedEC == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext)
    }
  }

  trait {:termination false} UnwrapMaterial<T> extends ActionWithResult<UnwrapInput, UnwrapOutput<T>, Types.Error> {
    method Invoke(input: UnwrapInput, ghost attemptsState: seq<ActionInvoke<UnwrapInput, Result<UnwrapOutput<T>, Types.Error>>>) returns (r: Result<UnwrapOutput<T>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, r, attemptsState)
      ensures r.Success? ==> |r.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies

    predicate Requires(input: UnwrapInput): (outcome: bool)
      decreases input
    {
      true &&
      input.serializedEC == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext)
    }
  }
}

module Materials {
  const EC_PUBLIC_KEY_FIELD: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 99, 114, 121, 112, 116, 111, 45, 112, 117, 98, 108, 105, 99, 45, 107, 101, 121]; assert UTF8.ValidUTF8Range(s, 0, 21); s
  const RESERVED_KEY_VALUES := {EC_PUBLIC_KEY_FIELD}

  function method InitializeEncryptionMaterials(input: Types.InitializeEncryptionMaterialsInput): (res: Result<Types.EncryptionMaterials, Types.Error>)
    ensures true && res.Success? ==> ValidEncryptionMaterials(res.value) && var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); res.value.algorithmSuite == suite && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in res.value.encryptionContext) && (suite.signature.None? <==> res.value.signingKey.None?)
    ensures true && EC_PUBLIC_KEY_FIELD in input.encryptionContext ==> true && res.Failure?
    decreases input
  {
    :- Need(EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Encryption Context ")); :- Need(forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in input.requiredEncryptionContextKeys} | key in input.requiredEncryptionContextKeys :: key in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Required encryption context keys do not exist in provided encryption context.")); var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); :- Need(suite.signature.ECDSA? <==> input.signingKey.Some? && input.verificationKey.Some?, Types.Error.AwsCryptographicMaterialProvidersException(message := "Missing signature key for signed suite.")); :- Need(suite.signature.None? <==> input.signingKey.None? && input.verificationKey.None?, Types.Error.AwsCryptographicMaterialProvidersException(message := "Signature key not allowed for non-signed suites.")); var encryptionContext: map<ValidUTF8Bytes, ValidUTF8Bytes> :- match suite.signature case ECDSA(curve) => (var enc_vk: ValidUTF8Bytes :- UTF8.Encode(Base64.Encode(input.verificationKey.value)).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); Success(input.encryptionContext[EC_PUBLIC_KEY_FIELD := enc_vk])) case None => Success(input.encryptionContext); Success(Types.EncryptionMaterials(algorithmSuite := suite, encryptionContext := encryptionContext, encryptedDataKeys := [], plaintextDataKey := Option.None, signingKey := input.signingKey, symmetricSigningKeys := if suite.symmetricSignature.None? then None else Some([]), requiredEncryptionContextKeys := input.requiredEncryptionContextKeys))
  }

  function method InitializeDecryptionMaterials(input: Types.InitializeDecryptionMaterialsInput): (res: Result<Types.DecryptionMaterials, Types.Error>)
    ensures true && res.Success? ==> ValidDecryptionMaterials(res.value) && var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); res.value.algorithmSuite == suite && (suite.signature.None? <==> EC_PUBLIC_KEY_FIELD !in input.encryptionContext) && var verificationKey: Result<Option<seq<uint8>>, Types.Error> := DecodeVerificationKey(input.encryptionContext); true && (verificationKey.Success? && verificationKey.value.Some? ==> res.value.verificationKey == Some(verificationKey.value.value))
    decreases input
  {
    :- Need(forall key: ValidUTF8Bytes {:trigger key in input.encryptionContext} {:trigger key in input.requiredEncryptionContextKeys} | key in input.requiredEncryptionContextKeys :: key in input.encryptionContext, Types.AwsCryptographicMaterialProvidersException(message := "Reproduced encryption context key did not exist in provided encryption context.")); var suite: AlgorithmSuite := AS.GetSuite(input.algorithmSuiteId); :- Need(suite.signature.ECDSA? <==> EC_PUBLIC_KEY_FIELD in input.encryptionContext, Types.Error.AwsCryptographicMaterialProvidersException(message := "Encryption Context missing verification key.")); :- Need(suite.signature.None? <==> EC_PUBLIC_KEY_FIELD !in input.encryptionContext, Types.Error.AwsCryptographicMaterialProvidersException(message := "Verification key can not exist in non-signed Algorithm Suites.")); var verificationKey: Option<seq<uint8>> :- DecodeVerificationKey(input.encryptionContext); Success(Types.DecryptionMaterials(encryptionContext := input.encryptionContext, algorithmSuite := suite, plaintextDataKey := Wrappers.None, verificationKey := verificationKey, symmetricSigningKey := Wrappers.None, requiredEncryptionContextKeys := input.requiredEncryptionContextKeys))
  }

  function method DecodeVerificationKey(encryptionContext: Types.EncryptionContext): (res: Result<Option<seq<uint8>>, Types.Error>)
    decreases encryptionContext
  {
    if EC_PUBLIC_KEY_FIELD in encryptionContext then
      var utf8Key: UTF8.ValidUTF8Bytes := encryptionContext[EC_PUBLIC_KEY_FIELD];
      var base64Key: string :- UTF8.Decode(utf8Key).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); var key: seq<uint8> :- Base64.Decode(base64Key).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e)); Success(Some(key))
    else
      Success(None)
  }

  predicate method ValidEncryptionMaterialsTransition(oldMat: Types.EncryptionMaterials, newMat: Types.EncryptionMaterials)
    decreases oldMat, newMat
  {
    SequenceIsSafeBecauseItIsInMemory(oldMat.encryptedDataKeys);
    SequenceIsSafeBecauseItIsInMemory(newMat.encryptedDataKeys);
    newMat.algorithmSuite == oldMat.algorithmSuite &&
    newMat.encryptionContext == oldMat.encryptionContext &&
    newMat.requiredEncryptionContextKeys == oldMat.requiredEncryptionContextKeys &&
    newMat.signingKey == oldMat.signingKey &&
    ((oldMat.plaintextDataKey.None? && newMat.plaintextDataKey.Some?) || oldMat.plaintextDataKey == newMat.plaintextDataKey) &&
    newMat.plaintextDataKey.Some? &&
    |oldMat.encryptedDataKeys| as uint64 <= |newMat.encryptedDataKeys| as uint64 &&
    multiset(oldMat.encryptedDataKeys) <= multiset(newMat.encryptedDataKeys) &&
    (!oldMat.algorithmSuite.symmetricSignature.None? ==>
      newMat.symmetricSigningKeys.Some? &&
      (oldMat.symmetricSigningKeys.Some? || (oldMat.symmetricSigningKeys.None? && |oldMat.encryptedDataKeys| as uint64 == 0)) &&
      multiset(oldMat.symmetricSigningKeys.UnwrapOr([])) <= multiset(newMat.symmetricSigningKeys.value)) &&
    ValidEncryptionMaterials(oldMat) &&
    ValidEncryptionMaterials(newMat)
  }

  lemma TransitionImplyValidEncryptionMaterials(oldMat: Types.EncryptionMaterials, newMat: Types.EncryptionMaterials)
    ensures !ValidEncryptionMaterials(oldMat) ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    ensures !ValidEncryptionMaterials(newMat) ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    ensures true && newMat.plaintextDataKey.None? ==> !ValidEncryptionMaterialsTransition(oldMat, newMat)
    decreases oldMat, newMat
  {
  }

  predicate method ValidEncryptionMaterials(encryptionMaterials: Types.EncryptionMaterials)
    decreases encryptionMaterials
  {
    SequenceIsSafeBecauseItIsInMemory(encryptionMaterials.encryptedDataKeys);
    OptionalSequenceIsSafeBecauseItIsInMemory(encryptionMaterials.plaintextDataKey);
    OptionalSequenceIsSafeBecauseItIsInMemory(encryptionMaterials.symmetricSigningKeys);
    AS.AlgorithmSuite?(encryptionMaterials.algorithmSuite) &&
    var suite: AlgorithmSuiteInfo := encryptionMaterials.algorithmSuite; (suite.signature.None? <==> encryptionMaterials.signingKey.None?) && (encryptionMaterials.plaintextDataKey.Some? ==> AS.GetEncryptKeyLength(suite) as uint64 == |encryptionMaterials.plaintextDataKey.value| as uint64) && (encryptionMaterials.plaintextDataKey.None? ==> |encryptionMaterials.encryptedDataKeys| as uint64 == 0) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in encryptionMaterials.encryptionContext) && (suite.signature.ECDSA? <==> encryptionMaterials.signingKey.Some?) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in encryptionMaterials.encryptionContext) && (suite.symmetricSignature.HMAC? && encryptionMaterials.symmetricSigningKeys.Some? ==> |encryptionMaterials.symmetricSigningKeys.value| as uint64 == |encryptionMaterials.encryptedDataKeys| as uint64) && (suite.symmetricSignature.HMAC? ==> encryptionMaterials.symmetricSigningKeys.Some? || (|encryptionMaterials.encryptedDataKeys| as uint64 == 0 && encryptionMaterials.symmetricSigningKeys.None?)) && (suite.symmetricSignature.None? ==> encryptionMaterials.symmetricSigningKeys.None?) && forall key: ValidUTF8Bytes {:trigger key in encryptionMaterials.encryptionContext} {:trigger key in encryptionMaterials.requiredEncryptionContextKeys} | key in encryptionMaterials.requiredEncryptionContextKeys :: key in encryptionMaterials.encryptionContext
  }

  predicate method EncryptionMaterialsHasPlaintextDataKey(encryptionMaterials: Types.EncryptionMaterials)
    decreases encryptionMaterials
  {
    SequenceIsSafeBecauseItIsInMemory(encryptionMaterials.encryptedDataKeys);
    encryptionMaterials.plaintextDataKey.Some? &&
    |encryptionMaterials.encryptedDataKeys| as uint64 > 0 &&
    ValidEncryptionMaterials(encryptionMaterials)
  }

  function method EncryptionMaterialAddEncryptedDataKeys(encryptionMaterials: Types.EncryptionMaterials, encryptedDataKeysToAdd: Types.EncryptedDataKeyList, symmetricSigningKeysToAdd: Option<Types.SymmetricSigningKeyList>): (res: Result<Types.EncryptionMaterials, Types.Error>)
    requires |encryptedDataKeysToAdd| > 0
    requires symmetricSigningKeysToAdd.Some? ==> |encryptedDataKeysToAdd| == |symmetricSigningKeysToAdd.value|
    ensures res.Success? ==> EncryptionMaterialsHasPlaintextDataKey(res.value) && ValidEncryptionMaterialsTransition(encryptionMaterials, res.value)
    decreases encryptionMaterials, encryptedDataKeysToAdd, symmetricSigningKeysToAdd
  {
    :- Need(ValidEncryptionMaterials(encryptionMaterials), Types.InvalidEncryptionMaterialsTransition(message := "Attempt to modify invalid encryption material.")); :- Need(encryptionMaterials.plaintextDataKey.Some?, Types.InvalidEncryptionMaterialsTransition(message := "Adding encrypted data keys without a plaintext data key is not allowed.")); :- Need(symmetricSigningKeysToAdd.None? ==> encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := "Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed.")); :- Need(symmetricSigningKeysToAdd.Some? ==> !encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := "Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed.")); var symmetricSigningKeys: Option<SymmetricSigningKeyList> := if symmetricSigningKeysToAdd.None? then encryptionMaterials.symmetricSigningKeys else Some(encryptionMaterials.symmetricSigningKeys.UnwrapOr([]) + symmetricSigningKeysToAdd.value); Success(Types.EncryptionMaterials(plaintextDataKey := encryptionMaterials.plaintextDataKey, encryptedDataKeys := encryptionMaterials.encryptedDataKeys + encryptedDataKeysToAdd, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, signingKey := encryptionMaterials.signingKey, symmetricSigningKeys := symmetricSigningKeys, requiredEncryptionContextKeys := encryptionMaterials.requiredEncryptionContextKeys))
  }

  function method EncryptionMaterialAddDataKey(encryptionMaterials: Types.EncryptionMaterials, plaintextDataKey: seq<uint8>, encryptedDataKeysToAdd: Types.EncryptedDataKeyList, symmetricSigningKeysToAdd: Option<Types.SymmetricSigningKeyList>): (res: Result<Types.EncryptionMaterials, Types.Error>)
    requires |encryptedDataKeysToAdd| > 0
    requires symmetricSigningKeysToAdd.Some? ==> |encryptedDataKeysToAdd| == |symmetricSigningKeysToAdd.value|
    ensures res.Success? ==> EncryptionMaterialsHasPlaintextDataKey(res.value) && ValidEncryptionMaterialsTransition(encryptionMaterials, res.value)
    decreases encryptionMaterials, plaintextDataKey, encryptedDataKeysToAdd, symmetricSigningKeysToAdd
  {
    var suite: AlgorithmSuiteInfo := encryptionMaterials.algorithmSuite;
    :- Need(ValidEncryptionMaterials(encryptionMaterials), Types.InvalidEncryptionMaterialsTransition(message := "Attempt to modify invalid encryption material.")); :- Need(encryptionMaterials.plaintextDataKey.None?, Types.InvalidEncryptionMaterialsTransition(message := "Attempt to modify plaintextDataKey.")); SequenceIsSafeBecauseItIsInMemory(plaintextDataKey); :- Need(AS.GetEncryptKeyLength(suite) as uint64 == |plaintextDataKey| as uint64, Types.InvalidEncryptionMaterialsTransition(message := "plaintextDataKey does not match Algorithm Suite specification.")); :- Need(symmetricSigningKeysToAdd.None? == encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := "Adding encrypted data keys without a symmetric signing key when using symmetric signing is not allowed.")); :- Need(symmetricSigningKeysToAdd.Some? == !encryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidEncryptionMaterialsTransition(message := "Adding encrypted data keys with a symmetric signing key when not using symmetric signing is not allowed.")); var symmetricSigningKeys: Option<SymmetricSigningKeyList> := if symmetricSigningKeysToAdd.None? then encryptionMaterials.symmetricSigningKeys else Some(encryptionMaterials.symmetricSigningKeys.UnwrapOr([]) + symmetricSigningKeysToAdd.value); Success(Types.EncryptionMaterials(plaintextDataKey := Some(plaintextDataKey), encryptedDataKeys := encryptionMaterials.encryptedDataKeys + encryptedDataKeysToAdd, algorithmSuite := encryptionMaterials.algorithmSuite, encryptionContext := encryptionMaterials.encryptionContext, signingKey := encryptionMaterials.signingKey, symmetricSigningKeys := symmetricSigningKeys, requiredEncryptionContextKeys := encryptionMaterials.requiredEncryptionContextKeys))
  }

  predicate method DecryptionMaterialsTransitionIsValid(oldMat: Types.DecryptionMaterials, newMat: Types.DecryptionMaterials)
    decreases oldMat, newMat
  {
    newMat.algorithmSuite == oldMat.algorithmSuite &&
    newMat.encryptionContext == oldMat.encryptionContext &&
    newMat.requiredEncryptionContextKeys == oldMat.requiredEncryptionContextKeys &&
    newMat.verificationKey == oldMat.verificationKey &&
    oldMat.plaintextDataKey.None? &&
    newMat.plaintextDataKey.Some? &&
    oldMat.symmetricSigningKey.None? &&
    ValidDecryptionMaterials(oldMat) &&
    ValidDecryptionMaterials(newMat)
  }

  lemma TransitionImplyValidDecryptionMaterials(oldMat: Types.DecryptionMaterials, newMat: Types.DecryptionMaterials)
    ensures !ValidDecryptionMaterials(oldMat) ==> !DecryptionMaterialsTransitionIsValid(oldMat, newMat)
    ensures !ValidDecryptionMaterials(newMat) ==> !DecryptionMaterialsTransitionIsValid(oldMat, newMat)
    decreases oldMat, newMat
  {
  }

  predicate method ValidDecryptionMaterials(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    OptionalSequenceIsSafeBecauseItIsInMemory(decryptionMaterials.plaintextDataKey);
    AS.AlgorithmSuite?(decryptionMaterials.algorithmSuite) &&
    var suite: AlgorithmSuiteInfo := decryptionMaterials.algorithmSuite; (decryptionMaterials.plaintextDataKey.Some? ==> AS.GetEncryptKeyLength(suite) as uint64 == |decryptionMaterials.plaintextDataKey.value| as uint64) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in decryptionMaterials.encryptionContext) && (suite.signature.ECDSA? <==> decryptionMaterials.verificationKey.Some?) && (!suite.signature.None? <==> EC_PUBLIC_KEY_FIELD in decryptionMaterials.encryptionContext) && (!suite.symmetricSignature.None? ==> (decryptionMaterials.plaintextDataKey.Some? <==> decryptionMaterials.symmetricSigningKey.Some?)) && (suite.symmetricSignature.None? ==> decryptionMaterials.symmetricSigningKey.None?) && forall k: ValidUTF8Bytes {:trigger k in decryptionMaterials.encryptionContext} {:trigger k in decryptionMaterials.requiredEncryptionContextKeys} | k in decryptionMaterials.requiredEncryptionContextKeys :: k in decryptionMaterials.encryptionContext
  }

  function method DecryptionMaterialsAddDataKey(decryptionMaterials: Types.DecryptionMaterials, plaintextDataKey: seq<uint8>, symmetricSigningKey: Option<seq<uint8>>): (res: Result<Types.DecryptionMaterials, Types.Error>)
    ensures res.Success? ==> DecryptionMaterialsWithPlaintextDataKey(res.value) && DecryptionMaterialsTransitionIsValid(decryptionMaterials, res.value)
    decreases decryptionMaterials, plaintextDataKey, symmetricSigningKey
  {
    SequenceIsSafeBecauseItIsInMemory(plaintextDataKey);
    var suite: AlgorithmSuiteInfo := decryptionMaterials.algorithmSuite;
    :- Need(ValidDecryptionMaterials(decryptionMaterials), Types.InvalidDecryptionMaterialsTransition(message := "Attempt to modify invalid decryption material.")); :- Need(decryptionMaterials.plaintextDataKey.None?, Types.InvalidDecryptionMaterialsTransition(message := "Attempt to modify plaintextDataKey.")); :- Need(AS.GetEncryptKeyLength(suite) as uint64 == |plaintextDataKey| as uint64, Types.InvalidDecryptionMaterialsTransition(message := "plaintextDataKey does not match Algorithm Suite specification.")); :- Need(symmetricSigningKey.Some? == !decryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidDecryptionMaterialsTransition(message := "symmetric signature key must be added with plaintextDataKey if using an algorithm suite with symmetric signing.")); :- Need(symmetricSigningKey.None? == decryptionMaterials.algorithmSuite.symmetricSignature.None?, Types.InvalidDecryptionMaterialsTransition(message := "symmetric signature key cannot be added with plaintextDataKey if using an algorithm suite without symmetric signing.")); Success(Types.DecryptionMaterials(plaintextDataKey := Some(plaintextDataKey), algorithmSuite := decryptionMaterials.algorithmSuite, encryptionContext := decryptionMaterials.encryptionContext, verificationKey := decryptionMaterials.verificationKey, symmetricSigningKey := symmetricSigningKey, requiredEncryptionContextKeys := decryptionMaterials.requiredEncryptionContextKeys))
  }

  predicate method DecryptionMaterialsWithoutPlaintextDataKey(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    decryptionMaterials.plaintextDataKey.None? &&
    ValidDecryptionMaterials(decryptionMaterials)
  }

  predicate method DecryptionMaterialsWithPlaintextDataKey(decryptionMaterials: Types.DecryptionMaterials)
    decreases decryptionMaterials
  {
    decryptionMaterials.plaintextDataKey.Some? &&
    ValidDecryptionMaterials(decryptionMaterials)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Base64

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import AS = AlgorithmSuites

  type DecryptionMaterialsPendingPlaintextDataKey = d: Types.DecryptionMaterials
    | DecryptionMaterialsWithoutPlaintextDataKey(d)
    witness *

  type SealedDecryptionMaterials = d: Types.DecryptionMaterials
    | DecryptionMaterialsWithPlaintextDataKey(d)
    witness *
}

module AlgorithmSuites {
  predicate method SupportedESDKEncrypt?(e: Encrypt)
    decreases e
  {
    e.AES_GCM? &&
    (e.AES_GCM.keyLength == 32 || e.AES_GCM.keyLength == 24 || e.AES_GCM.keyLength == 16) &&
    e.AES_GCM.tagLength == 16 &&
    e.AES_GCM.ivLength == 12
  }

  predicate method SupportedDBEEncrypt?(e: Encrypt)
    decreases e
  {
    e.AES_GCM? &&
    e.AES_GCM.keyLength == 32 &&
    e.AES_GCM.tagLength == 16 &&
    e.AES_GCM.ivLength == 12
  }

  predicate method SupportedDBEEDKWrapping?(p: EdkWrappingAlgorithm)
    decreases p
  {
    p.IntermediateKeyWrapping? &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32 &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.tagLength == 16 &&
    p.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.ivLength == 12 &&
    p.IntermediateKeyWrapping.macKeyKdf.HKDF? &&
    p.IntermediateKeyWrapping.keyEncryptionKeyKdf.HKDF?
  }

  predicate method KeyDerivationAlgorithm?(kdf: DerivationAlgorithm)
    decreases kdf
  {
    (true &&
    kdf.HKDF? ==>
      kdf.HKDF.inputKeyLength == kdf.HKDF.outputKeyLength &&
      (kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 ==>
        kdf.HKDF.inputKeyLength == 32)) &&
    !kdf.None?
  }

  predicate method CommitmentDerivationAlgorithm?(kdf: DerivationAlgorithm)
    decreases kdf
  {
    (true &&
    kdf.HKDF? ==>
      kdf.HKDF.hmac.SHA_512? &&
      kdf.HKDF.saltLength == 32 &&
      kdf.HKDF.inputKeyLength == 32 &&
      kdf.HKDF.outputKeyLength == 32) &&
    !kdf.IDENTITY?
  }

  predicate method EdkWrappingAlgorithm?(alg: EdkWrappingAlgorithm)
    decreases alg
  {
    (alg.IntermediateKeyWrapping? && alg.IntermediateKeyWrapping.keyEncryptionKeyKdf.HKDF? && alg.IntermediateKeyWrapping.macKeyKdf.HKDF? && alg.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && alg.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32) || alg.DIRECT_KEY_WRAPPING?
  }

  predicate method AlgorithmSuiteInfo?(a: AlgorithmSuiteInfo)
    decreases a
  {
    KeyDerivationAlgorithm?(a.kdf) &&
    CommitmentDerivationAlgorithm?(a.commitment) &&
    EdkWrappingAlgorithm?(a.edkWrapping) &&
    (a.kdf.HKDF? ==>
      true &&
      a.kdf.HKDF.outputKeyLength == a.encrypt.AES_GCM.keyLength) &&
    (a.signature.ECDSA? ==>
      a.kdf.HKDF?) &&
    (a.commitment.HKDF? ==>
      a.commitment.HKDF.saltLength == 32 &&
      a.commitment == a.kdf) &&
    (a.edkWrapping.IntermediateKeyWrapping? ==>
      a.kdf.HKDF? &&
      a.edkWrapping.IntermediateKeyWrapping.keyEncryptionKeyKdf == a.kdf &&
      a.edkWrapping.IntermediateKeyWrapping.macKeyKdf == a.kdf) &&
    (a.kdf.HKDF? &&
    a.commitment.None? ==>
      a.kdf.HKDF.saltLength == 0) &&
    (!a.symmetricSignature.None? ==>
      true &&
      a.edkWrapping.IntermediateKeyWrapping?)
  }

  predicate method ESDKAlgorithmSuite?(a: AlgorithmSuiteInfo)
    requires a.id.ESDK?
    decreases a
  {
    AlgorithmSuiteInfo?(a) &&
    SupportedESDKEncrypt?(a.encrypt) &&
    match a.id.ESDK case ALG_AES_128_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_NO_KDF() => a.binaryId == [0, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.IDENTITY? && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256() => a.binaryId == [1, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.None? && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256() => a.binaryId == [2, 20] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 16 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_256 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P256 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384() => a.binaryId == [3, 70] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 24 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_384 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384() => a.binaryId == [3, 120] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_384 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.None? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY() => a.binaryId == [4, 120] && a.messageVersion == 2 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.None? && a.commitment.HKDF? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING? case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384() => a.binaryId == [5, 120] && a.messageVersion == 2 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.HKDF? && a.symmetricSignature.None? && a.edkWrapping.DIRECT_KEY_WRAPPING?
  }

  predicate method DBEAlgorithmSuite?(a: AlgorithmSuiteInfo)
    requires a.id.DBE?
    decreases a
  {
    AlgorithmSuiteInfo?(a) &&
    SupportedDBEEncrypt?(a.encrypt) &&
    SupportedDBEEDKWrapping?(a.edkWrapping) &&
    match a.id.DBE case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384() => a.binaryId == [103, 0] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.None? && a.commitment.HKDF? && a.symmetricSignature.HMAC? && a.symmetricSignature.HMAC == AwsCryptographyPrimitivesTypes.SHA_384 && a.edkWrapping.IntermediateKeyWrapping? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32 case ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384() => a.binaryId == [103, 1] && a.messageVersion == 1 && a.encrypt.AES_GCM? && a.encrypt.AES_GCM.keyLength == 32 && a.kdf.HKDF? && a.kdf.HKDF.hmac == AwsCryptographyPrimitivesTypes.SHA_512 && a.signature.ECDSA? && a.signature.ECDSA.curve == AwsCryptographyPrimitivesTypes.ECDSA_P384 && a.commitment.HKDF? && a.symmetricSignature.HMAC? && a.symmetricSignature.HMAC == AwsCryptographyPrimitivesTypes.SHA_384 && a.edkWrapping.IntermediateKeyWrapping? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM? && a.edkWrapping.IntermediateKeyWrapping.pdkEncryptAlgorithm.AES_GCM.keyLength == 32
  }

  predicate method AlgorithmSuite?(a: AlgorithmSuiteInfo)
    decreases a
  {
    match a.id
    case ESDK(_ /* _v0 */) =>
      ESDKAlgorithmSuite?(a)
    case DBE(_ /* _v1 */) =>
      DBEAlgorithmSuite?(a)
  }

  const Bits256 := 32 as int32
  const Bits192 := 24 as int32
  const Bits128 := 16 as int32
  const TagLen := 16 as int32
  const IvLen := 12 as int32
  const AES_128_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits128, tagLength := TagLen, ivLength := IvLen))
  const AES_192_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits192, tagLength := TagLen, ivLength := IvLen))
  const AES_256_GCM_IV12_TAG16 := Encrypt.AES_GCM(AwsCryptographyPrimitivesTypes.AES_GCM(keyLength := Bits256, tagLength := TagLen, ivLength := IvLen))

  function method HKDF_SHA_256(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_256, saltLength := 0 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  function method HKDF_SHA_384(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_384, saltLength := 0 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  function method HKDF_SHA_512(keyLength: AwsCryptographyPrimitivesTypes.SymmetricKeyLength): (res: DerivationAlgorithm)
    decreases keyLength
  {
    DerivationAlgorithm.HKDF(HKDF.HKDF(hmac := AwsCryptographyPrimitivesTypes.SHA_512, saltLength := 32 as int32, inputKeyLength := keyLength, outputKeyLength := keyLength))
  }

  const EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512 := EdkWrappingAlgorithm.IntermediateKeyWrapping(IntermediateKeyWrapping.IntermediateKeyWrapping(keyEncryptionKeyKdf := HKDF_SHA_512(Bits256), macKeyKdf := HKDF_SHA_512(Bits256), pdkEncryptAlgorithm := AES_256_GCM_IV12_TAG16))
  const DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.DBE(DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384), binaryId := [103, 0], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.HMAC(AwsCryptographyPrimitivesTypes.SHA_384), edkWrapping := EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512)
  const DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.DBE(DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384), binaryId := [103, 1], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.HMAC(AwsCryptographyPrimitivesTypes.SHA_384), edkWrapping := EDK_INTERMEDIATE_WRAPPING_AES_GCM_256_HKDF_SHA_512)
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 70], messageVersion := 1, encrypt := AES_192_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF), binaryId := [0, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := DerivationAlgorithm.IDENTITY(IDENTITY.IDENTITY), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits128), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 70], messageVersion := 1, encrypt := AES_192_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits192), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256), binaryId := [1, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits256), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256), binaryId := [2, 20], messageVersion := 1, encrypt := AES_128_GCM_IV12_TAG16, kdf := HKDF_SHA_256(Bits128), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P256)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384), encrypt := AES_192_GCM_IV12_TAG16, binaryId := [3, 70], messageVersion := 1, kdf := HKDF_SHA_384(Bits192), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384), binaryId := [3, 120], messageVersion := 1, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_384(Bits256), commitment := DerivationAlgorithm.None(None.None), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY), binaryId := [4, 120], messageVersion := 2, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.None(None.None), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))
  const ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384: AlgorithmSuite := AlgorithmSuiteInfo.AlgorithmSuiteInfo(id := AlgorithmSuiteId.ESDK(ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384), binaryId := [5, 120], messageVersion := 2, encrypt := AES_256_GCM_IV12_TAG16, kdf := HKDF_SHA_512(Bits256), commitment := HKDF_SHA_512(Bits256), signature := SignatureAlgorithm.ECDSA(ECDSA.ECDSA(curve := AwsCryptographyPrimitivesTypes.ECDSA_P384)), symmetricSignature := SymmetricSignatureAlgorithm.None(None.None), edkWrapping := EdkWrappingAlgorithm.DIRECT_KEY_WRAPPING(DIRECT_KEY_WRAPPING.DIRECT_KEY_WRAPPING))

  function method GetSuite(id: AlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id == id
    decreases id
  {
    match id
    case ESDK(e) =>
      GetESDKSuite(e)
    case DBE(e) =>
      GetDBESuite(e)
  }

  lemma LemmaAlgorithmSuiteIdImpliesEquality(id: AlgorithmSuiteId, suite: AlgorithmSuite)
    requires id == suite.id
    ensures GetSuite(id) == suite
    decreases id, suite
  {
    match id
    case {:split false} ESDK(e) =>
      {
        LemmaESDKAlgorithmSuiteIdImpliesEquality(e, suite);
      }
    case {:split false} DBE(e) =>
      {
        LemmaDBEAlgorithmSuiteIdImpliesEquality(e, suite);
      }
  }

  lemma LemmaBinaryIdIsUnique(a: AlgorithmSuite, b: AlgorithmSuite)
    requires a.id != b.id
    ensures a.binaryId != b.binaryId
    decreases a, b
  {
  }

  const SupportedDBEAlgorithmSuites: map<DBEAlgorithmSuiteId, AlgorithmSuite> := map[DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384 := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384, DBEAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384 := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384]

  lemma LemmaSupportedDBEAlgorithmSuitesIsComplete(id: DBEAlgorithmSuiteId)
    ensures id in SupportedDBEAlgorithmSuites
    decreases id
  {
  }

  function method GetDBESuite(id: DBEAlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id.DBE? && res.id.DBE == id
    decreases id
  {
    LemmaSupportedDBEAlgorithmSuitesIsComplete(id);
    SupportedDBEAlgorithmSuites[id]
  }

  lemma LemmaDBEAlgorithmSuiteIdImpliesEquality(id: DBEAlgorithmSuiteId, suite: AlgorithmSuite)
    requires suite.id.DBE? && id == suite.id.DBE
    ensures GetDBESuite(id) == suite
    decreases id, suite
  {
    if GetDBESuite(id) != suite {
    }
  }

  const SupportedESDKAlgorithmSuites: map<ESDKAlgorithmSuiteId, AlgorithmSuite> := map[ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_NO_KDF := ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF, ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256 := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256, ESDKAlgorithmSuiteId.ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256 := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, ESDKAlgorithmSuiteId.ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384 := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY, ESDKAlgorithmSuiteId.ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384 := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384]

  lemma LemmaSupportedESDKAlgorithmSuitesIsComplete(id: ESDKAlgorithmSuiteId)
    ensures id in SupportedESDKAlgorithmSuites
    decreases id
  {
  }

  function method GetESDKSuite(id: ESDKAlgorithmSuiteId): (res: AlgorithmSuite)
    ensures res.id.ESDK? && res.id.ESDK == id
    decreases id
  {
    LemmaSupportedESDKAlgorithmSuitesIsComplete(id);
    SupportedESDKAlgorithmSuites[id]
  }

  lemma LemmaESDKAlgorithmSuiteIdImpliesEquality(id: ESDKAlgorithmSuiteId, suite: AlgorithmSuite)
    requires suite.id.ESDK? && id == suite.id.ESDK
    ensures GetESDKSuite(id) == suite
    decreases id, suite
  {
    if GetESDKSuite(id) != suite {
      assert GetESDKSuite(id).encrypt.AES_GCM.tagLength == suite.encrypt.AES_GCM.tagLength;
    }
  }

  function method GetEncryptKeyLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_SymmetricKeyLength(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.keyLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.keyLength
  }

  function method GetEncryptTagLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_Uint8Bytes(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.tagLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.tagLength
  }

  function method GetEncryptIvLength(a: AlgorithmSuiteInfo): (output: int32)
    ensures AwsCryptographyPrimitivesTypes.IsValid_PositiveInteger(output) && AwsCryptographyPrimitivesTypes.IsValid_Uint8Bits(output)
    ensures a.encrypt.AES_GCM? ==> output == a.encrypt.AES_GCM.ivLength
    decreases a
  {
    match a.encrypt
    case AES_GCM(e) =>
      e.ivLength
  }

  const AlgorithmSuiteInfoByBinaryId: map<seq<uint8>, AlgorithmSuite> := map[[0, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_NO_KDF, [0, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_NO_KDF, [0, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_NO_KDF, [1, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256, [1, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA256, [1, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA256, [2, 20] := ESDK_ALG_AES_128_GCM_IV12_TAG16_HKDF_SHA256_ECDSA_P256, [3, 70] := ESDK_ALG_AES_192_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [3, 120] := ESDK_ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384, [4, 120] := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY, [5, 120] := ESDK_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384, [103, 0] := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_SYMSIG_HMAC_SHA384, [103, 1] := DBE_ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384]

  lemma AlgorithmSuiteInfoByBinaryIdIsComplete(a: AlgorithmSuite)
    ensures a == AlgorithmSuiteInfoByBinaryId[a.binaryId]
    decreases a
  {
  }

  function method GetAlgorithmSuiteInfo(binaryId?: seq<uint8>): (output: Wrappers.Result<AlgorithmSuiteInfo, Error>)
    decreases binaryId?
  {
    :- Wrappers.Need(binaryId? in AlgorithmSuiteInfoByBinaryId, AwsCryptographicMaterialProvidersException(message := "Invalid BinaryId")); Wrappers.Success(AlgorithmSuiteInfoByBinaryId[binaryId?])
  }

  lemma ReservedAlgorithmSuiteId(a: AlgorithmSuite)
    ensures a.binaryId != [0, 0]
    decreases a
  {
  }

  lemma AlgorithmSuiteIdIsUnique(a: AlgorithmSuite, b: AlgorithmSuite)
    requires a.id != b.id
    ensures a.binaryId != b.binaryId
    decreases a, b
  {
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened AwsCryptographyMaterialProvidersTypes

  import Wrappers

  type AlgorithmSuite = a: AlgorithmSuiteInfo
    | AlgorithmSuite?(a)
    witness *
}

module Constants {
  const UINT32_TO_SEQ_LEN: uint64 := 4
  const KDF_SALT_LEN: int32 := 32
  const KDF_EXPECTED_LEN: int32 := 64
  const ECDH_COMMITMENT_KEY_LENGTH: uint64 := 32
  const ECDH_COMMITMENT_KEY_INDEX: uint64 := 32
  const ECDH_WRAPPED_KEY_MATERIAL_INDEX: uint64 := 64
  const ECDH_KDF_STRING: string := "ecdh-key-derivation"
  const ECDH_KDF_PRF_STRING: string := "HMAC_SHA384"
  const ECDH_KDF_DELIMITER: seq<uint8> := [0]
  const ECDH_PROVIDER_INFO_256_LEN: uint32 := 75
  const ECDH_PROVIDER_INFO_384_LEN: uint32 := 107
  const ECDH_PROVIDER_INFO_521_LEN: uint32 := 143
  const ECDH_PROVIDER_INFO_RPL_INDEX := 1 as uint32
  const ECDH_PROVIDER_INFO_RPK_INDEX := ECDH_PROVIDER_INFO_RPL_INDEX + ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN as uint32
  const ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN: uint64 := 4
  const ECDH_PUBLIC_KEY_LEN_ECC_NIST_256: uint64 := 91
  const ECDH_PUBLIC_KEY_LEN_ECC_NIST_384: uint64 := 120
  const ECDH_PUBLIC_KEY_LEN_ECC_NIST_521: uint64 := 158
  const ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_256: uint64 := 33
  const ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_384: uint64 := 49
  const ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_521: uint64 := 67
  const CIPHERTEXT_WRAPPED_MATERIAL_INDEX: uint64 := 68
  const ECDH_AES_256_ENC_KEY_LENGTH: int32 := 32
  const ECDH_AES_256_ENC_TAG_LENGTH: int32 := 16
  const ECDH_AES_256_ENC_IV_LENGTH: int32 := 12
  const ECDH_AES_256_ENC_ALG := PrimitiveTypes.AES_GCM(keyLength := ECDH_AES_256_ENC_KEY_LENGTH, tagLength := ECDH_AES_256_ENC_TAG_LENGTH, ivLength := ECDH_AES_256_ENC_IV_LENGTH)
  const PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115]; assert UTF8.ValidUTF8Range(s, 0, 7); s
  const PROVIDER_ID_HIERARCHY: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115, 45, 104, 105, 101, 114, 97, 114, 99, 104, 121]; assert UTF8.ValidUTF8Range(s, 0, 17); s
  const RSA_PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115, 45, 114, 115, 97]; assert UTF8.ValidUTF8Range(s, 0, 11); s
  const KMS_ECDH_PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [97, 119, 115, 45, 107, 109, 115, 45, 101, 99, 100, 104]; assert s == UTF8.EncodeAscii("aws-kms-ecdh"); s
  const RAW_ECDH_PROVIDER_ID: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [114, 97, 119, 45, 101, 99, 100, 104]; assert s == UTF8.EncodeAscii("raw-ecdh"); s
  const ECDH_KDF_PRF_NAME: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [72, 77, 65, 67, 95, 83, 72, 65, 51, 56, 52]; assert s == UTF8.EncodeAscii("HMAC_SHA384"); s
  const ECDH_KDF_UTF8: UTF8.ValidUTF8Bytes := var s: seq<BoundedInts.uint8> := [101, 99, 100, 104, 45, 107, 101, 121, 45, 100, 101, 114, 105, 118, 97, 116, 105, 111, 110]; assert s == UTF8.EncodeAscii("ecdh-key-derivation"); s

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import AwsArnParsing

  import opened UInt = StandardLibrary.UInt

  import PrimitiveTypes = AwsCryptographyPrimitivesTypes

  type AwsKmsEncryptedDataKey = edk: Types.EncryptedDataKey
    | edk.keyProviderId == PROVIDER_ID && UTF8.ValidUTF8Seq(edk.keyProviderInfo)
    witness *

  datatype AwsKmsEdkHelper = AwsKmsEdkHelper(edk: AwsKmsEncryptedDataKey, arn: AwsArnParsing.AwsKmsArn)
}

module {:options "/functionSyntax:4"} Keyring {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Materials
  trait {:termination false} VerifiableInterface extends Types.IKeyring {
    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
  }
}

module AwsKmsMrkKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened AwsKmsKeyring

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import opened Seq

  import opened Actions

  import opened Constants

  import Keyring

  import Materials

  import AlgorithmSuites

  import UTF8

  import EdkWrapping

  import MaterialWrapping

  import ErrorMessages
  class AwsKmsMrkKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, awsKmsKey: string, grantTokens: KMS.GrantTokenList)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH as nat
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures unchanged(History)
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> output.Failure?
      ensures !KMS.IsValid_KeyIdType(awsKmsKey) ==> output.Failure?
      ensures input.materials.plaintextDataKey.Some? && !KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) ==> output.Failure?
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.IntermediateKeyWrapping? ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite)), KeySpec := None)
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> true && var suite: AlgorithmSuiteInfo := input.materials.algorithmSuite; true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(suite)), KeySpec := None)
      ensures output.Success? && input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.GenerateDataKey).output.Success? && var GenerateResponse: GenerateDataKeyResponse := Last(client.History.GenerateDataKey).output.value; GenerateResponse.CiphertextBlob.Some? && GenerateResponse.KeyId.Some? && UTF8.Encode(GenerateResponse.KeyId.value).Success? && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && KMS.IsValid_CiphertextType(Last(output.value.materials.encryptedDataKeys).ciphertext) && Last(output.value.materials.encryptedDataKeys).ciphertext == GenerateResponse.CiphertextBlob.value && Last(output.value.materials.encryptedDataKeys).keyProviderInfo == UTF8.Encode(GenerateResponse.KeyId.value).value && 0 < |client.History.GenerateDataKey| && exists returnedKeyId: KeyIdType, kmsPlaintext: Option<PlaintextType> {:trigger KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), Plaintext := kmsPlaintext)} :: true && Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), Plaintext := kmsPlaintext)
      ensures output.Success? && input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).input == KMS.EncryptRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.materials.plaintextDataKey.value, EncryptionAlgorithm := None)
      ensures input.materials.plaintextDataKey.Some? && output.Success? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Encrypt).output.Success? && var EncryptResponse: EncryptResponse := Last(client.History.Encrypt).output.value; EncryptResponse.CiphertextBlob.Some? && EncryptResponse.KeyId.Some? && UTF8.Encode(EncryptResponse.KeyId.value).Success? && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && Last(output.value.materials.encryptedDataKeys).ciphertext == EncryptResponse.CiphertextBlob.value && Last(output.value.materials.encryptedDataKeys).keyProviderInfo == UTF8.Encode(EncryptResponse.KeyId.value).value && KMS.IsValid_CiphertextType(Last(output.value.materials.encryptedDataKeys).ciphertext) && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).output.Success? && exists returnedKeyId: Option<KeyIdType>, returnedEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> {:trigger KMS.EncryptResponse(CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)} :: true && Last(client.History.Encrypt).output.value == KMS.EncryptResponse(CiphertextBlob := Some(Last(output.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)
      ensures input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && StringifyEncryptionContext(input.materials.encryptionContext).Success? && |client.History.Encrypt| == |old(client.History.Encrypt)| + 1 && Last(client.History.Encrypt).output.Failure? ==> output.Failure?
      ensures input.materials.plaintextDataKey.None? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? && StringifyEncryptionContext(input.materials.encryptionContext).Success? && |client.History.GenerateDataKey| == |old(client.History.GenerateDataKey)| + 1 && Last(client.History.GenerateDataKey).output.Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.materials.encryptionContext);
      var kmsGenerateAndWrap := new KmsGenerateAndWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var kmsWrap := new KmsWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsWrapInfo>(encryptionMaterials := materials, wrap := kmsWrap, generateAndWrap := kmsGenerateAndWrap);
      var kmsKeyArn := wrapOutput.wrapInfo.kmsKeyArn;
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var providerInfo :- UTF8.Encode(kmsKeyArn).MapFailure(WrapStringToError);
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 < UINT16_LIMIT as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS GenerateDataKey: Key ID too long."));
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID, keyProviderInfo := providerInfo, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        assert |client.History.GenerateDataKey| > 0 && Last(client.History.GenerateDataKey).output.Success?;
        assert |kmsGenerateAndWrap.client.History.GenerateDataKey| > 0 && Last(kmsGenerateAndWrap.client.History.GenerateDataKey).output.Success?;
        assert Last(client.History.GenerateDataKey).output.value == Last(kmsGenerateAndWrap.client.History.GenerateDataKey).output.value;
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures unchanged(History)
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures input.materials.plaintextDataKey.None? && output.Success? ==> output.value.materials.plaintextDataKey.Some? && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && var suite: AlgorithmSuiteInfo := input.materials.algorithmSuite; AlgorithmSuites.GetEncryptKeyLength(suite) as nat == |output.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: EncryptedDataKey {:trigger edk.keyProviderId} {:trigger edk.ciphertext} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: true && var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, input.materials.algorithmSuite); maybeWrappedMaterial.Success? && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == LastDecrypt.input && LastDecrypt.output.value.KeyId == Some(awsKmsKey) && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> LastDecrypt.output.value.Plaintext == output.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      :- OkForDecrypt(awsKmsArn, awsKmsKey);
      var filter := new AwsKmsUtils.OnDecryptMrkAwareEncryptedDataKeyFilter(awsKmsArn, PROVIDER_ID);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      var decryptClosure: DecryptSingleEncryptedDataKey := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      assert Last(attempts).input in input.encryptedDataKeys;
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attempts: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey))
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }
}

module AwsKmsKeyring {

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened Seq

  import opened Actions

  import opened Constants

  import opened A = AwsKmsMrkMatchForDecrypt

  import Keyring

  import Materials

  import AlgorithmSuites

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import UUID

  import EdkWrapping

  import MaterialWrapping

  import ErrorMessages
  class AwsKmsKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const awsKmsArn: AwsKmsIdentifier
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, awsKmsKey: string, grantTokens: KMS.GrantTokenList)
      requires ParseAwsKmsIdentifier(awsKmsKey).Success?
      requires UTF8.IsASCIIString(awsKmsKey)
      requires 0 < |awsKmsKey| <= MAX_AWS_KMS_IDENTIFIER_LENGTH as nat
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, awsKmsKey, grantTokens
    {
      var parsedAwsKmsId := ParseAwsKmsIdentifier(awsKmsKey);
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.awsKmsArn := parsedAwsKmsId.value;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> res.Failure?
      ensures !KMS.IsValid_KeyIdType(awsKmsKey) ==> res.Failure?
      ensures input.materials.plaintextDataKey.Some? && !KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) ==> res.Failure?
      ensures res.Success? && input.materials.plaintextDataKey.None? && (false || (input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.IntermediateKeyWrapping?)) ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && Last(client.History.GenerateDataKey).input == KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite)), KeySpec := None)
      ensures input.materials.plaintextDataKey.None? && res.Success? ==> res.value.materials.plaintextDataKey.Some? && |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && var algSuite: AlgorithmSuiteInfo := input.materials.algorithmSuite; true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(Last(res.value.materials.encryptedDataKeys).ciphertext, input.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && |client.History.GenerateDataKey| > 0 && Last(client.History.GenerateDataKey).output.Success? && AlgorithmSuites.GetEncryptKeyLength(algSuite) as int == |res.value.materials.plaintextDataKey.value| && exists returnedKeyId: KeyIdType, kmsPlaintext: PlaintextType {:trigger Some(returnedKeyId), Some(kmsPlaintext)} :: Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(returnedKeyId), CiphertextBlob := Some(maybeProviderWrappedMaterial.value), Plaintext := Some(kmsPlaintext)) && (res.value.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> kmsPlaintext == res.value.materials.plaintextDataKey.value)
      ensures res.Success? && input.materials.plaintextDataKey.Some? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> KMS.IsValid_PlaintextType(input.materials.plaintextDataKey.value) && StringifyEncryptionContext(input.materials.encryptionContext).Success? && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); 0 < |client.History.Encrypt| && Last(client.History.Encrypt).input == KMS.EncryptRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.materials.plaintextDataKey.value, EncryptionAlgorithm := None)
      ensures input.materials.plaintextDataKey.Some? && res.Success? && input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> |res.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && KMS.IsValid_CiphertextType(Last(res.value.materials.encryptedDataKeys).ciphertext) && 0 < |client.History.Encrypt| && Last(client.History.Encrypt).output.Success? && exists returnedKeyId: Option<KeyIdType>, returnedEncryptionAlgorithm: Option<EncryptionAlgorithmSpec> {:trigger KMS.EncryptResponse(CiphertextBlob := Some(Last(res.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)} :: true && Last(client.History.Encrypt).output.value == KMS.EncryptResponse(CiphertextBlob := Some(Last(res.value.materials.encryptedDataKeys).ciphertext), KeyId := returnedKeyId, EncryptionAlgorithm := returnedEncryptionAlgorithm)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.materials.encryptionContext);
      var kmsGenerateAndWrap := new KmsGenerateAndWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var kmsWrap := new KmsWrapKeyMaterial(client, awsKmsKey, grantTokens);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<KmsWrapInfo>(encryptionMaterials := materials, wrap := kmsWrap, generateAndWrap := kmsGenerateAndWrap);
      var kmsKeyArn := wrapOutput.wrapInfo.kmsKeyArn;
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var providerInfo :- UTF8.Encode(kmsKeyArn).MapFailure(WrapStringToError);
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 < UINT16_LIMIT as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS GenerateDataKey: Key ID too long."));
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID, keyProviderInfo := providerInfo, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures input.materials.plaintextDataKey.Some? ==> res.Failure?
      ensures true && res.Success? ==> true && var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite) as nat == |res.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Last(client.History.Decrypt); LastDecrypt.output.Success? && (exists edk: EncryptedDataKey {:trigger edk.keyProviderId} {:trigger edk.ciphertext} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: true && var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, input.materials.algorithmSuite); maybeWrappedMaterial.Success? && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == LastDecrypt.input && LastDecrypt.output.value.KeyId == Some(awsKmsKey)) && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> LastDecrypt.output.value.Plaintext == res.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      :- OkForDecrypt(awsKmsArn, awsKmsKey);
      var filter := new OnDecryptEncryptedDataKeyFilter(awsKmsKey);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      assert forall j: EncryptedDataKey {:trigger filter.Ensures(j, Success(true))} {:trigger j in edksToAttempt} | j in edksToAttempt :: filter.Ensures(j, Success(true));
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, client, awsKmsKey, grantTokens);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      ghost var LastDecrypt := Last(client.History.Decrypt);
      assert LastDecrypt.output.Success?;
      assert LastDecrypt.output.value.KeyId == Some(awsKmsKey);
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class OnDecryptEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const awsKmsKey: AwsKmsIdentifierString

    constructor (awsKmsKey: AwsKmsIdentifierString)
      decreases awsKmsKey
    {
      this.awsKmsKey := awsKmsKey;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == PROVIDER_ID)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != PROVIDER_ID {
        return Success(false);
      }
      if !UTF8.ValidUTF8Seq(edk.keyProviderInfo) {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := "Invalid AWS KMS encoding, provider info is not UTF8."));
      }
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var _ /* _v0 */ :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success(this.awsKmsKey == keyId);
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, awsKmsKey, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, materials.algorithmSuite); maybeWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeWrappedMaterial.value) && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := maybeWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true
    }

    method {:vcs_split_on_every_assert} Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  datatype KmsUnwrapInfo = KmsUnwrapInfo

  datatype KmsWrapInfo = KmsWrapInfo(kmsKeyArn: string)

  class KmsUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<KmsUnwrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.IsValid_CiphertextType(input.wrappedMaterial) && KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Last(client.History.Decrypt).input && Last(client.History.Decrypt).output.Success? && Last(client.History.Decrypt).output.value.Plaintext.Some? && Last(client.History.Decrypt).output.value.Plaintext == Some(res.value.unwrappedMaterial) && Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<KmsUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      :- Need(KMS.IsValid_CiphertextType(input.wrappedMaterial), Types.AwsCryptographicMaterialProvidersException(message := "Ciphertext length invalid"));
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      var decryptRequest := KMS.DecryptRequest(KeyId := Some(awsKmsKey), CiphertextBlob := input.wrappedMaterial, EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None);
      var maybeDecryptResponse := client.Decrypt(decryptRequest);
      var decryptResponse :- maybeDecryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      OptionalSequenceIsSafeBecauseItIsInMemory(decryptResponse.Plaintext);
      :- Need(decryptResponse.KeyId.Some? && decryptResponse.KeyId.value == awsKmsKey && decryptResponse.Plaintext.Some? && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as uint64 == |decryptResponse.Plaintext.value| as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from KMS Decrypt"));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResponse.Plaintext.value, unwrapInfo := KmsUnwrapInfo());
      return Success(output);
    }
  }

  class KmsGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<KmsWrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate {:vcs_split_on_every_assert} Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); true && (res.Success? ==> Invariant() && maybeStringifiedEncCtx.Success? && 0 < |client.History.GenerateDataKey| && KMS.GenerateDataKeyRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)), KeySpec := None) == Last(client.History.GenerateDataKey).input && Last(client.History.GenerateDataKey).output.Success? && Last(client.History.GenerateDataKey).output.value.CiphertextBlob.Some? && Last(client.History.GenerateDataKey).output.value.CiphertextBlob == Some(res.value.wrappedMaterial) && Last(client.History.GenerateDataKey).output.value.Plaintext.Some? && Last(client.History.GenerateDataKey).output.value.Plaintext == Some(res.value.plaintextMaterial) && Last(client.History.GenerateDataKey).output.value.KeyId == Some(res.value.wrapInfo.kmsKeyArn) && ParseAwsKmsIdentifier(res.value.wrapInfo.kmsKeyArn).Success? && AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat == |res.value.plaintextMaterial| && KMS.IsValid_CiphertextType(res.value.wrappedMaterial) && Last(client.History.GenerateDataKey).output.value == KMS.GenerateDataKeyResponse(KeyId := Some(res.value.wrapInfo.kmsKeyArn), CiphertextBlob := Some(res.value.wrappedMaterial), Plaintext := Some(res.value.plaintextMaterial)))
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<KmsWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == input.algorithmSuite.encrypt.AES_GCM.keyLength as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      var generatorRequest := KMS.GenerateDataKeyRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, NumberOfBytes := Some(AlgorithmSuites.GetEncryptKeyLength(suite)), KeySpec := None);
      var maybeGenerateResponse := client.GenerateDataKey(generatorRequest);
      var generateResponse :- maybeGenerateResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(generateResponse.KeyId.Some? && ParseAwsKmsIdentifier(generateResponse.KeyId.value).Success?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from KMS GenerateDataKey:: Invalid Key Id"));
      OptionalSequenceIsSafeBecauseItIsInMemory(generateResponse.Plaintext);
      :- Need(generateResponse.Plaintext.Some? && AlgorithmSuites.GetEncryptKeyLength(suite) as uint64 == |generateResponse.Plaintext.value| as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS GenerateDataKey: Invalid data key"));
      :- Need(generateResponse.CiphertextBlob.Some? && KMS.IsValid_CiphertextType(generateResponse.CiphertextBlob.value), Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS GeneratedDataKey: Invalid ciphertext"));
      :- Need(true && generateResponse.CiphertextForRecipient.None?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS GeneratedDataKey: Invalid CiphertextForRecipient"));
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := generateResponse.Plaintext.value, wrappedMaterial := generateResponse.CiphertextBlob.value, wrapInfo := KmsWrapInfo(generateResponse.KeyId.value));
      return Success(output);
    }
  }

  class KmsWrapKeyMaterial extends MaterialWrapping.WrapMaterial<KmsWrapInfo> {
    const client: KMS.IKMSClient
    const awsKmsKey: AwsKmsIdentifierString
    const grantTokens: KMS.GrantTokenList

    constructor (client: KMS.IKMSClient, awsKmsKey: AwsKmsIdentifierString, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.awsKmsKey == awsKmsKey && this.grantTokens == grantTokens
      ensures Invariant()
      decreases client, awsKmsKey, grantTokens
    {
      this.client := client;
      this.awsKmsKey := awsKmsKey;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies &&
      KMS.IsValid_KeyIdType(awsKmsKey)
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(input.encryptionContext); true && (res.Success? ==> Invariant() && KMS.IsValid_PlaintextType(input.plaintextMaterial) && KMS.IsValid_KeyIdType(awsKmsKey) && maybeStringifiedEncCtx.Success? && 0 < |client.History.Encrypt| && KMS.EncryptRequest(EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.plaintextMaterial, EncryptionAlgorithm := None) == Last(client.History.Encrypt).input && Last(client.History.Encrypt).output.Success? && Last(client.History.Encrypt).output.value.CiphertextBlob.Some? && Last(client.History.Encrypt).output.value.CiphertextBlob == Some(res.value.wrappedMaterial) && Last(client.History.Encrypt).output.value.KeyId == Some(res.value.wrapInfo.kmsKeyArn) && ParseAwsKmsIdentifier(res.value.wrapInfo.kmsKeyArn).Success? && KMS.IsValid_CiphertextType(res.value.wrappedMaterial))
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<KmsWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.encryptionContext);
      :- Need(KMS.IsValid_PlaintextType(input.plaintextMaterial), Types.AwsCryptographicMaterialProvidersException(message := "Invalid Plaintext on KMS Encrypt"));
      var encryptRequest := KMS.EncryptRequest(EncryptionContext := Some(stringifiedEncCtx), GrantTokens := Some(grantTokens), KeyId := awsKmsKey, Plaintext := input.plaintextMaterial, EncryptionAlgorithm := None);
      var maybeEncryptResponse := client.Encrypt(encryptRequest);
      var encryptResponse :- maybeEncryptResponse.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
      :- Need(encryptResponse.KeyId.Some? && ParseAwsKmsIdentifier(encryptResponse.KeyId.value).Success?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS Encrypt:: Invalid Key Id"));
      :- Need(encryptResponse.CiphertextBlob.Some?, Types.AwsCryptographicMaterialProvidersException(message := "Invalid response from AWS KMS Encrypt: Invalid Ciphertext Blob"));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := encryptResponse.CiphertextBlob.value, wrapInfo := KmsWrapInfo(encryptResponse.KeyId.value));
      return Success(output);
    }
  }
}

module AwsKmsMrkDiscoveryKeyring {
  function method ToStringForRegion(arn: AwsKmsArn, region: string): (res: string)
    decreases arn, region
  {
    if IsMultiRegionAwsKmsArn(arn) then
      arn.ToArnString(Some(region))
    else
      arn.ToString()
  }

  function method DiscoveryMatch(arn: AwsKmsArn, discoveryFilter: Option<Types.DiscoveryFilter>, region: string): (res: bool)
    ensures discoveryFilter.Some? && res ==> discoveryFilter.value.partition == arn.partition && arn.account in discoveryFilter.value.accountIds
    ensures !IsMultiRegionAwsKmsArn(arn) && res ==> arn.region == region
    decreases arn, discoveryFilter, region
  {
    match discoveryFilter { case Some(filter) => filter.partition == arn.partition && arn.account in filter.accountIds case None() => true } &&
    if !IsMultiRegionAwsKmsArn(arn) then region == arn.region else true
  }

  lemma LemmaMultisetSubMembership<T>(a: seq<T>, b: seq<T>)
    requires multiset(a) <= multiset(b)
    ensures forall i: T {:trigger i in b} {:trigger i in a} | i in a :: i in b
    decreases a, b
  {
    if |a| == 0 {
    } else {
      assert multiset([Seq.First(a)]) <= multiset(b);
      assert Seq.First(a) in b;
      assert a == [Seq.First(a)] + a[1..];
      LemmaMultisetSubMembership(a[1..], b);
    }
  }

  lemma /*{:_inductionTrigger |parts|}*/ /*{:_inductionTrigger _default.Flatten(parts)}*/ /*{:_induction parts}*/ LemmaFlattenMembership<T>(parts: seq<seq<T>>, flat: seq<T>)
    requires Seq.Flatten(parts) == flat
    ensures forall index: int {:trigger parts[index]} | 0 <= index < |parts| :: multiset(parts[index]) <= multiset(flat)
    ensures multiset(Seq.Flatten(parts)) == multiset(flat)
    ensures forall part: seq<T> {:trigger part in parts} | part in parts :: forall i: T {:trigger i in flat} {:trigger i in part} | i in part :: i in flat
    ensures forall i: T {:trigger i in flat} | i in flat :: exists part: seq<T> {:trigger i in part} {:trigger part in parts} | part in parts :: i in part
    decreases parts, flat
  {
    if |parts| == 0 {
    } else {
      assert multiset(Seq.First(parts)) <= multiset(flat);
      assert parts == [Seq.First(parts)] + parts[1..];
      assert flat == Seq.First(parts) + Seq.Flatten(parts[1..]);
      LemmaFlattenMembership(parts[1..], Seq.Flatten(parts[1..]));
    }
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened AwsArnParsing

  import opened Actions

  import opened Constants

  import AlgorithmSuites

  import Keyring

  import Materials

  import UUID

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import opened AwsKmsUtils

  import AwsKmsKeyring

  import EdkWrapping

  import MaterialWrapping

  import ErrorMessages

  class AwsKmsMrkDiscoveryKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const discoveryFilter: Option<Types.DiscoveryFilter>
    const grantTokens: KMS.GrantTokenList
    const region: string

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, region: string, discoveryFilter: Option<Types.DiscoveryFilter>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.region == region && this.discoveryFilter == discoveryFilter && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, region, discoveryFilter, grantTokens
    {
      this.client := client;
      this.region := region;
      this.discoveryFilter := discoveryFilter;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Failure?
      decreases Modifies - {History}
    {
      return Failure(Types.AwsCryptographicMaterialProvidersException(message := "Encryption is not supported with a Discovery Keyring."));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures input.materials.plaintextDataKey.Some? ==> true && output.Failure?
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> output.Failure?
      ensures true && output.Success? ==> Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.materials) && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); output.value.materials.plaintextDataKey.Some? && 0 < |client.History.Decrypt| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Seq.Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: Types.EncryptedDataKey, awsKmsKey: string {:trigger Option<string>.Some(awsKmsKey), edk.keyProviderId} {:trigger Option<string>.Some(awsKmsKey), edk.ciphertext} {:trigger Option<string>.Some(awsKmsKey), edk in input.encryptedDataKeys} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.keyProviderId} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.ciphertext} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk in input.encryptedDataKeys} | true && edk in input.encryptedDataKeys :: true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, output.value.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_KeyIdType(awsKmsKey) && var request: DecryptRequest := KMS.DecryptRequest(KeyId := Option.Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Option.Some(stringifiedEncCtx), GrantTokens := Option.Some(grantTokens), EncryptionAlgorithm := Option.None()); Seq.Last(client.History.Decrypt).input == request && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == output.value.materials.plaintextDataKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var encryptedDataKeys := input.encryptedDataKeys;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      var edkFilterTransform: AwsKmsEncryptedDataKeyFilterTransform := new AwsKmsEncryptedDataKeyFilterTransform(region, discoveryFilter);
      var edksToAttempt, parts :- Actions.DeterministicFlatMapWithResult(edkFilterTransform, encryptedDataKeys);
      forall i: int | 0 <= i < |parts|
        ensures edkFilterTransform.Ensures(encryptedDataKeys[i], Success(parts[i])) && 1 >= |parts[i]| && |encryptedDataKeys| == |parts| && edksToAttempt == Seq.Flatten(parts) && |encryptedDataKeys| >= |edksToAttempt| && multiset(parts[i]) <= multiset(edksToAttempt) && multiset(edksToAttempt) <= multiset(Seq.Flatten(parts)) && forall helper: AwsKmsEdkHelper {:trigger helper.arn} {:trigger helper.edk} {:trigger helper in edksToAttempt} {:trigger helper in parts[i]} | helper in parts[i] :: helper in edksToAttempt && helper.edk == encryptedDataKeys[i] && helper.arn.resource.resourceType == "key"
      {
        if |parts| < |edksToAttempt| {
          Seq.LemmaFlattenLengthLeMul(parts, 1);
          Seq.LemmaFlattenAndFlattenReverseAreEquivalent(parts);
          assert |parts| * 1 >= |Seq.Flatten(parts)|;
        }
        forall helper: AwsKmsEdkHelper | helper in parts[i]
          ensures helper in edksToAttempt && helper.edk == encryptedDataKeys[i] && helper.arn.resource.resourceType == "key"
        {
          LemmaMultisetSubMembership(parts[i], edksToAttempt);
        }
      }
      forall helper: AwsKmsEdkHelper | helper in edksToAttempt
        ensures helper.edk in encryptedDataKeys && helper.arn.resource.resourceType == "key"
      {
        LemmaFlattenMembership(parts, edksToAttempt);
        assert helper in Seq.Flatten(parts);
      }
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      var decryptAction: AwsKmsEncryptedDataKeyDecryptor := new AwsKmsEncryptedDataKeyDecryptor(materials, client, region, grantTokens);
      var outcome, attempts := Actions.ReduceToSuccess(decryptAction, edksToAttempt);
      return match outcome { case Success(mat) => (assert exists helper: AwsKmsEdkHelper {:trigger decryptAction.Ensures(helper, Success(mat), attempts)} {:trigger helper.arn} {:trigger helper.edk} {:trigger helper in edksToAttempt} | helper in edksToAttempt :: helper.edk in encryptedDataKeys && helper.arn.resource.resourceType == "key" && decryptAction.Ensures(helper, Success(mat), attempts); Success(Types.OnDecryptOutput(materials := mat))) case Failure(errors) => Failure(Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.")) };
    }
  }

  class AwsKmsEncryptedDataKeyFilterTransform extends DeterministicActionWithResult<Types.EncryptedDataKey, seq<AwsKmsEdkHelper>, Types.Error> {
    const region: string
    const discoveryFilter: Option<Types.DiscoveryFilter>

    constructor (region: string, discoveryFilter: Option<Types.DiscoveryFilter>)
      ensures this.region == region && this.discoveryFilter == discoveryFilter
      decreases region, discoveryFilter
    {
      this.region := region;
      this.discoveryFilter := discoveryFilter;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      decreases edk, res
    {
      true &&
      res.Success? ==>
        if |res.value| == 1 then true && ghost var h: AwsKmsEdkHelper := res.value[0]; h.edk.keyProviderId == PROVIDER_ID && UTF8.ValidUTF8Seq(h.edk.keyProviderInfo) && UTF8.Decode(h.edk.keyProviderInfo).Success? && ParseAwsKmsArn(UTF8.Decode(h.edk.keyProviderInfo).value).Success? && h.arn == ParseAwsKmsArn(UTF8.Decode(h.edk.keyProviderInfo).value).value && h.edk == edk && h.arn.resource.resourceType == "key" && DiscoveryMatch(h.arn, discoveryFilter, region) else true && |res.value| == 0
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      if edk.keyProviderId != PROVIDER_ID {
        return Success([]);
      }
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := "Invalid AWS KMS encoding, provider info is not UTF8."));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      var arn :- ParseAwsKmsArn(keyId).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      :- Need(arn.resource.resourceType == "key", Types.AwsCryptographicMaterialProvidersException(message := "Only AWS KMS Keys supported"));
      if !DiscoveryMatch(arn, discoveryFilter, region) {
        return Success([]);
      }
      return Success([AwsKmsEdkHelper(edk, arn)]);
    }
  }

  class AwsKmsEncryptedDataKeyDecryptor extends ActionWithResult<AwsKmsEdkHelper, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const region: string
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, region: string, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.region == region && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, region, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.region := region;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(helper: AwsKmsEdkHelper, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attempts: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) &&
        ghost var keyArn: string := ToStringForRegion(helper.arn, region); true && ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(helper.edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && KMS.IsValid_KeyIdType(keyArn) && maybeStringifiedEncCtx.Success? && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(keyArn), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(keyArn) && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey)
    }

    predicate Requires(helper: AwsKmsEdkHelper)
      decreases helper
    {
      true
    }

    method Invoke(helper: AwsKmsEdkHelper, ghost attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(helper, res, attemptsState)
      decreases Modifies
    {
      var awsKmsKey := ToStringForRegion(helper.arn, region);
      var _ /* _v0 */ :- ValidateKmsKeyId(awsKmsKey);
      var kmsUnwrap := new AwsKmsKeyring.KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(helper.edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      res := Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
    }
  }
}

module AwsKmsHierarchicalKeyring {
  const BRANCH_KEY_STORE_GSI := "Active-Keys"
  const BRANCH_KEY_FIELD := "enc"
  const VERSION_FIELD := "version"
  const BRANCH_KEY_IDENTIFIER_FIELD := "branch-key-id"
  const KEY_CONDITION_EXPRESSION := "#status = :status and #branch_key_id = :branch_key_id"
  const EXPRESSION_ATTRIBUTE_NAMES := map["#status" := "status", "#branch_key_id" := "branch-key-id"]
  const EXPRESSION_ATTRIBUTE_VALUE_STATUS_KEY := ":status"
  const EXPRESSION_ATTRIBUTE_VALUE_STATUS_VALUE := "ACTIVE"
  const EXPRESSION_ATTRIBUTE_VALUE_BRANCH_KEY := ":branch_key_id"
  const H_WRAP_SALT_LEN: Types.PositiveInteger := 16
  const H_WRAP_NONCE_LEN: Types.PositiveInteger := 12
  const DERIVED_BRANCH_KEY_EXPECTED_LENGTH: Types.PositiveInteger := 32
  const AES_256_ENC_KEY_LENGTH: int32 := 32
  const AES_256_ENC_TAG_LENGTH: int32 := 16
  const AES_256_ENC_IV_LENGTH: int32 := 12
  const AES_256_ENC_ALG := Crypto.AES_GCM(keyLength := AES_256_ENC_KEY_LENGTH, tagLength := AES_256_ENC_TAG_LENGTH, ivLength := AES_256_ENC_IV_LENGTH)
  const EDK_CIPHERTEXT_VERSION_LENGTH: int32 := 16
  const EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX := H_WRAP_SALT_LEN + H_WRAP_NONCE_LEN
  const EDK_CIPHERTEXT_VERSION_INDEX := EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX + EDK_CIPHERTEXT_VERSION_LENGTH
  const EXPECTED_EDK_CIPHERTEXT_OVERHEAD := EDK_CIPHERTEXT_VERSION_INDEX + AES_256_ENC_TAG_LENGTH

  predicate method cacheEntryWithinLimits(creationTime: Types.PositiveLong, now: Types.PositiveLong, ttlSeconds: Types.PositiveLong): (output: bool)
    decreases creationTime, now, ttlSeconds
  {
    now - creationTime <= ttlSeconds as Types.PositiveLong
  }

  method DeriveEncryptionKeyFromBranchKey(branchKey: seq<uint8>, salt: seq<uint8>, purpose: Option<seq<uint8>>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      returns (output: Result<seq<uint8>, Types.Error>)
    requires cryptoPrimitives.ValidState()
    modifies cryptoPrimitives.Modifies
    ensures cryptoPrimitives.ValidState()
    ensures output.Success? ==> |output.value| == 32
    ensures |cryptoPrimitives.History.GenerateRandomBytes| == old(|cryptoPrimitives.History.GenerateRandomBytes|)
    ensures |cryptoPrimitives.History.KdfCounterMode| > 0
    decreases branchKey, salt, purpose, cryptoPrimitives
  {
    var maybeDerivedBranchKey := cryptoPrimitives.KdfCounterMode(Crypto.KdfCtrInput(digestAlgorithm := Crypto.DigestAlgorithm.SHA_256, ikm := branchKey, expectedLength := DERIVED_BRANCH_KEY_EXPECTED_LENGTH, purpose := purpose, nonce := Some(salt)));
    var derivedBranchKey :- maybeDerivedBranchKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    output := Success(derivedBranchKey);
  }

  function method {:opaque} WrappingAad(branchKeyId: seq<uint8>, branchKeyVersion: seq<uint8>, aad: seq<uint8>): (res: seq<uint8>)
    requires UTF8.ValidUTF8Seq(branchKeyId)
    ensures res == PROVIDER_ID_HIERARCHY + branchKeyId + branchKeyVersion + aad
    decreases branchKeyId, branchKeyVersion, aad
  {
    PROVIDER_ID_HIERARCHY + branchKeyId + branchKeyVersion + aad
  }

  function method SerializeEDKCiphertext(encOutput: Crypto.AESEncryptOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened Seq

  import opened Actions

  import opened Constants

  import opened A = AwsKmsMrkMatchForDecrypt

  import LocalCMC

  import SynchronizedLocalCMC

  import StormTracker

  import StormTrackingCMC

  import opened CacheConstants

  import opened AlgorithmSuites

  import EdkWrapping

  import MaterialWrapping

  import CanonicalEncryptionContext

  import Keyring

  import Materials

  import Time

  import Random

  import Digest

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import KMS = ComAmazonawsKmsTypes

  import DDB = ComAmazonawsDynamodbTypes

  import KeyStore = AwsCryptographyKeyStoreTypes

  import UTF8

  import UUID

  import HKDF

  import HMAC

  import opened AESEncryption

  import AtomicPrimitives

  import ErrorMessages

  class AwsKmsHierarchicalKeyring extends Keyring.VerifiableInterface {
    const branchKeyId: Option<string>
    const branchKeyIdSupplier: Option<Types.IBranchKeyIdSupplier>
    const keyStore: KeyStore.IKeyStoreClient
    const ttlSeconds: Types.PositiveLong
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient
    const cache: Types.ICryptographicMaterialsCache
    const partitionIdBytes: seq<uint8>
    const logicalKeyStoreNameBytes: seq<uint8>

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      keyStore.ValidState() &&
      cryptoPrimitives.ValidState() &&
      cache.ValidState() &&
      (branchKeyIdSupplier.Some? ==>
        branchKeyIdSupplier.value.ValidState()) &&
      keyStore.Modifies <= Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      cache.Modifies <= Modifies &&
      (branchKeyIdSupplier.Some? ==>
        branchKeyIdSupplier.value.Modifies <= Modifies) &&
      History !in keyStore.Modifies &&
      History !in cryptoPrimitives.Modifies &&
      History !in cache.Modifies &&
      (branchKeyIdSupplier.Some? ==>
        History !in branchKeyIdSupplier.value.Modifies) &&
      (branchKeyIdSupplier.Some? || branchKeyId.Some?) &&
      (branchKeyIdSupplier.None? || branchKeyId.None?)
    }

    constructor (keyStore: KeyStore.IKeyStoreClient, branchKeyId: Option<string>, branchKeyIdSupplier: Option<Types.IBranchKeyIdSupplier>, ttlSeconds: Types.PositiveLong, cmc: Types.ICryptographicMaterialsCache, partitionIdBytes: seq<uint8>, logicalKeyStoreNameBytes: seq<uint8>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires ttlSeconds >= 0
      requires keyStore.ValidState() && cryptoPrimitives.ValidState() && cmc.ValidState()
      requires branchKeyIdSupplier.Some? ==> branchKeyIdSupplier.value.ValidState()
      requires branchKeyIdSupplier.Some? || branchKeyId.Some?
      requires branchKeyIdSupplier.None? || branchKeyId.None?
      ensures this.keyStore == keyStore && this.branchKeyIdSupplier == branchKeyIdSupplier && this.ttlSeconds == ttlSeconds && this.partitionIdBytes == partitionIdBytes && this.logicalKeyStoreNameBytes == logicalKeyStoreNameBytes && this.cache == cmc
      ensures ValidState() && fresh(this) && fresh(History) && var maybeSupplierModifies: set<object> := if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {}; true && fresh(Modifies - keyStore.Modifies - cryptoPrimitives.Modifies - maybeSupplierModifies - cmc.Modifies)
      decreases keyStore, branchKeyId, branchKeyIdSupplier, ttlSeconds, cmc, partitionIdBytes, logicalKeyStoreNameBytes, cryptoPrimitives
    {
      this.keyStore := keyStore;
      this.branchKeyId := branchKeyId;
      this.branchKeyIdSupplier := branchKeyIdSupplier;
      this.ttlSeconds := ttlSeconds;
      this.cryptoPrimitives := cryptoPrimitives;
      this.cache := cmc;
      this.partitionIdBytes := partitionIdBytes;
      this.logicalKeyStoreNameBytes := logicalKeyStoreNameBytes;
      History := new Types.IKeyringCallHistory();
      ghost var maybeSupplierModifies := if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {};
      Modifies := {History} + keyStore.Modifies + cryptoPrimitives.Modifies + maybeSupplierModifies + cmc.Modifies;
    }

    method GetBranchKeyId(context: Types.EncryptionContext) returns (ret: Result<string, Types.Error>)
      requires ValidState()
      modifies if branchKeyIdSupplier.Some? then branchKeyIdSupplier.value.Modifies else {}
      ensures ValidState()
      ensures branchKeyId.Some? ==> ret.Success? && ret.value == branchKeyId.value
      decreases context
    {
      if branchKeyId.Some? {
        return Success(branchKeyId.value);
      } else {
        var GetBranchKeyIdOut :- branchKeyIdSupplier.value.GetBranchKeyId(Types.GetBranchKeyIdInput(encryptionContext := context));
        return Success(GetBranchKeyIdOut.branchKeyId);
      }
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var branchKeyIdForEncrypt :- GetBranchKeyId(materials.encryptionContext);
      var branchKeyIdUtf8 :- UTF8.Encode(branchKeyIdForEncrypt).MapFailure(WrapStringToError);
      var cacheId :- GetActiveCacheId(branchKeyIdForEncrypt, branchKeyIdUtf8, cryptoPrimitives);
      var hierarchicalMaterials :- GetActiveHierarchicalMaterials(branchKeyIdForEncrypt, cacheId, keyStore);
      var branchKey := hierarchicalMaterials.branchKey;
      var branchKeyVersion := hierarchicalMaterials.branchKeyVersion;
      var branchKeyVersionAsString :- UTF8.Decode(branchKeyVersion).MapFailure(WrapStringToError);
      var branchKeyVersionAsBytes :- UUID.ToByteArray(branchKeyVersionAsString).MapFailure(WrapStringToError);
      var kmsHierarchyGenerateAndWrap := new KmsHierarchyGenerateAndWrapKeyMaterial(hierarchicalMaterials.branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, cryptoPrimitives);
      var kmsHierarchyWrap := new KmsHierarchyWrapKeyMaterial(hierarchicalMaterials.branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<HierarchyWrapInfo>(encryptionMaterials := materials, wrap := kmsHierarchyWrap, generateAndWrap := kmsHierarchyGenerateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk := Types.EncryptedDataKey(keyProviderId := PROVIDER_ID_HIERARCHY, keyProviderInfo := branchKeyIdUtf8, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), E("Keyring received decryption materials that already contain a plaintext data key."));
      var branchKeyIdForDecrypt :- GetBranchKeyId(materials.encryptionContext);
      var filter := new OnDecryptHierarchyEncryptedDataKeyFilter(branchKeyIdForDecrypt);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials := materials, keyStore := keyStore, cryptoPrimitives := cryptoPrimitives, branchKeyId := branchKeyIdForDecrypt, ttlSeconds := ttlSeconds, cache := cache, partitionIdBytes := partitionIdBytes, logicalKeyStoreNameBytes := logicalKeyStoreNameBytes);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }

    method GetActiveCacheId(branchKeyId: string, branchKeyIdUtf8: seq<uint8>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
        returns (cacheId: Result<seq<uint8>, Types.Error>)
      requires cryptoPrimitives.ValidState()
      modifies cryptoPrimitives.Modifies
      ensures cryptoPrimitives.ValidState()
      ensures cacheId.Success? ==> |cacheId.value| == 48
      decreases branchKeyId, branchKeyIdUtf8, cryptoPrimitives
    {
      SequenceIsSafeBecauseItIsInMemory(branchKeyId);
      :- Need(true && var branchKeyId: Result<string, string> := UTF8.Decode(branchKeyIdUtf8); branchKeyId.Success? && SequenceIsSafeBecauseItIsInMemory(branchKeyId.value); 0 <= |branchKeyId.value| as uint64 < UINT32_LIMIT as uint64, E("Invalid Branch Key ID Length"));
      var hashAlgorithm := Crypto.DigestAlgorithm.SHA_384;
      var resourceId: seq<uint8> := RESOURCE_ID_HIERARCHICAL_KEYRING;
      var scopeId: seq<uint8> := SCOPE_ID_ENCRYPT;
      var suffix: seq<uint8> := logicalKeyStoreNameBytes + NULL_BYTE + branchKeyIdUtf8;
      var identifier := resourceId + NULL_BYTE + scopeId + NULL_BYTE + partitionIdBytes + NULL_BYTE + suffix;
      var maybeCacheIdDigest := cryptoPrimitives.Digest(Crypto.DigestInput(digestAlgorithm := hashAlgorithm, message := identifier));
      var cacheDigest :- maybeCacheIdDigest.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      SequenceIsSafeBecauseItIsInMemory(cacheDigest);
      :- Need(|cacheDigest| as uint64 == Digest.Length(hashAlgorithm) as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Digest generated a message not equal to the expected length."));
      return Success(cacheDigest);
    }

    method GetActiveHierarchicalMaterials(branchKeyId: string, cacheId: seq<uint8>, keyStore: KeyStore.IKeyStoreClient)
        returns (material: Result<KeyStore.BranchKeyMaterials, Types.Error>)
      requires ValidState()
      requires keyStore.ValidState() && cache.ValidState()
      modifies keyStore.Modifies, cache.Modifies
      ensures ValidState()
      ensures keyStore.ValidState() && cache.ValidState()
      decreases branchKeyId, cacheId, keyStore
    {
      var getCacheInput := Types.GetCacheEntryInput(identifier := cacheId, bytesUsed := None);
      var getCacheOutput := cache.GetCacheEntry(getCacheInput);
      if getCacheOutput.Failure? && !getCacheOutput.error.EntryDoesNotExist? {
        return Failure(getCacheOutput.error);
      }
      var now := Time.GetCurrent();
      if getCacheOutput.Failure? || !cacheEntryWithinLimits(creationTime := getCacheOutput.value.creationTime, now := now, ttlSeconds := ttlSeconds) {
        var maybeGetActiveBranchKeyOutput := keyStore.GetActiveBranchKey(KeyStore.GetActiveBranchKeyInput(branchKeyIdentifier := branchKeyId));
        var getActiveBranchKeyOutput :- maybeGetActiveBranchKeyOutput.MapFailure((e: Error) => Types.AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
        var branchKeyMaterials := getActiveBranchKeyOutput.branchKeyMaterials;
        var now := Time.GetCurrent();
        :- Need(now as int + ttlSeconds as int < UInt.INT64_MAX_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := "INT64 Overflow when putting cache entry."));
        var putCacheEntryInput := Types.PutCacheEntryInput(identifier := cacheId, materials := Types.Materials.BranchKey(branchKeyMaterials), creationTime := now, expiryTime := ttlSeconds + now, messagesUsed := None, bytesUsed := None);
        var putResult := cache.PutCacheEntry(putCacheEntryInput);
        if putResult.Failure? && !putResult.error.EntryAlreadyExists? {
          return Failure(putResult.error);
        }
        return Success(branchKeyMaterials);
      } else {
        :- Need(getCacheOutput.value.materials.BranchKey?, E("Invalid Material Type."));
        return Success(getCacheOutput.value.materials.BranchKey);
      }
    }
  }

  class OnDecryptHierarchyEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const branchKeyId: string

    constructor (branchKeyId: string)
      decreases branchKeyId
    {
      this.branchKeyId := branchKeyId;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        edk.keyProviderId == PROVIDER_ID_HIERARCHY &&
        UTF8.ValidUTF8Seq(edk.keyProviderInfo))
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var providerInfo := edk.keyProviderInfo;
      var providerId := edk.keyProviderId;
      if providerId != PROVIDER_ID_HIERARCHY {
        return Success(false);
      }
      assert UTF8.ValidUTF8Seq(PROVIDER_ID_HIERARCHY);
      assert providerId == PROVIDER_ID_HIERARCHY;
      var branchKeyId :- UTF8.Decode(providerInfo).MapFailure((e: string) => E("Invalid encoding, provider info is not UTF8."));
      return Success(this.branchKeyId == branchKeyId);
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const keyStore: KeyStore.IKeyStoreClient
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient
    const branchKeyId: string
    const ttlSeconds: Types.PositiveLong
    const cache: Types.ICryptographicMaterialsCache
    const partitionIdBytes: seq<uint8>
    const logicalKeyStoreNameBytes: seq<uint8>

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, keyStore: KeyStore.IKeyStoreClient, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient, branchKeyId: string, ttlSeconds: Types.PositiveLong, cache: Types.ICryptographicMaterialsCache, partitionIdBytes: seq<uint8>, logicalKeyStoreNameBytes: seq<uint8>)
      requires keyStore.ValidState() && cryptoPrimitives.ValidState() && cache.ValidState()
      ensures this.materials == materials && this.keyStore == keyStore && this.cryptoPrimitives == cryptoPrimitives && this.branchKeyId == branchKeyId && this.ttlSeconds == ttlSeconds && this.cache == cache && this.partitionIdBytes == partitionIdBytes && this.logicalKeyStoreNameBytes == logicalKeyStoreNameBytes
      ensures Invariant()
      decreases materials, keyStore, cryptoPrimitives, branchKeyId, ttlSeconds, cache, partitionIdBytes, logicalKeyStoreNameBytes
    {
      this.materials := materials;
      this.keyStore := keyStore;
      this.cryptoPrimitives := cryptoPrimitives;
      this.branchKeyId := branchKeyId;
      this.ttlSeconds := ttlSeconds;
      this.cache := cache;
      this.partitionIdBytes := partitionIdBytes;
      this.logicalKeyStoreNameBytes := logicalKeyStoreNameBytes;
      Modifies := keyStore.Modifies + cryptoPrimitives.Modifies + cache.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      keyStore.ValidState() &&
      cryptoPrimitives.ValidState() &&
      cache.ValidState() &&
      keyStore.Modifies + cryptoPrimitives.Modifies + cache.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value)
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true &&
      UTF8.ValidUTF8Seq(edk.keyProviderInfo)
    }

    method Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      requires Requires(edk)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      assert UTF8.ValidUTF8Seq(edk.keyProviderId);
      var suite := materials.algorithmSuite;
      var keyProviderId := edk.keyProviderId;
      var branchKeyIdUtf8 := edk.keyProviderInfo;
      var ciphertext := edk.ciphertext;
      var providerWrappedMaterial :- EdkWrapping.GetProviderWrappedMaterial(ciphertext, suite);
      SequenceIsSafeBecauseItIsInMemory(providerWrappedMaterial);
      :- Need(|providerWrappedMaterial| as uint64 >= EDK_CIPHERTEXT_VERSION_INDEX as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Received EDK Ciphertext of incorrect length."));
      var branchKeyVersionUuid := providerWrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX];
      var version :- UUID.FromByteArray(branchKeyVersionUuid).MapFailure(WrapStringToError);
      var cacheId :- GetVersionCacheId(branchKeyIdUtf8, version, cryptoPrimitives);
      var hierarchicalMaterials :- GetHierarchicalMaterialsVersion(branchKeyId, branchKeyIdUtf8, version, cacheId);
      var branchKey := hierarchicalMaterials.branchKey;
      var branchKeyVersion := hierarchicalMaterials.branchKeyVersion;
      var branchKeyVersionAsString :- UTF8.Decode(branchKeyVersion).MapFailure(WrapStringToError);
      var branchKeyVersionAsBytes :- UUID.ToByteArray(branchKeyVersionAsString).MapFailure(WrapStringToError);
      var maybeCrypto := AtomicPrimitives.AtomicPrimitives();
      var cryptoPrimitivesX: Crypto.IAwsCryptographicPrimitivesClient :- maybeCrypto.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      assert cryptoPrimitivesX is AtomicPrimitives.AtomicPrimitivesClient;
      var cryptoPrimitives := cryptoPrimitivesX as AtomicPrimitives.AtomicPrimitivesClient;
      var kmsHierarchyUnwrap := new KmsHierarchyUnwrapKeyMaterial(branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, cryptoPrimitives);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, kmsHierarchyUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }

    method GetVersionCacheId(branchKeyIdUtf8: seq<uint8>, branchKeyVersion: string, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
        returns (cacheId: Result<seq<uint8>, Types.Error>)
      ensures cacheId.Success? ==> |cacheId.value| == 48
      decreases branchKeyIdUtf8, branchKeyVersion, cryptoPrimitives
    {
      SequenceIsSafeBecauseItIsInMemory(branchKeyId);
      :- Need(true && var branchKeyId: Result<string, string> := UTF8.Decode(branchKeyIdUtf8); branchKeyId.Success? && SequenceIsSafeBecauseItIsInMemory(branchKeyId.value); 0 <= |branchKeyId.value| as uint64 < UINT32_LIMIT as uint64, E("Invalid Branch Key ID Length"));
      var hashAlgorithm := Crypto.DigestAlgorithm.SHA_384;
      var resourceId: seq<uint8> := RESOURCE_ID_HIERARCHICAL_KEYRING;
      var scopeId: seq<uint8> := SCOPE_ID_DECRYPT;
      :- Need(UTF8.IsASCIIString(branchKeyVersion), E("Unable to represent as an ASCII string."));
      var versionBytes :- UTF8.Encode(branchKeyVersion).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
      var suffix: seq<uint8> := logicalKeyStoreNameBytes + NULL_BYTE + branchKeyIdUtf8 + NULL_BYTE + versionBytes;
      var identifier := resourceId + NULL_BYTE + scopeId + NULL_BYTE + partitionIdBytes + NULL_BYTE + suffix;
      var identifierDigestInput := Crypto.DigestInput(digestAlgorithm := hashAlgorithm, message := identifier);
      var maybeCacheDigest := Digest.Digest(identifierDigestInput);
      var cacheDigest :- maybeCacheDigest.MapFailure((e: Types.Error) => Types.AwsCryptographyPrimitives(e));
      assert |cacheDigest| == Digest.Length(hashAlgorithm) as nat;
      return Success(cacheDigest);
    }

    method GetHierarchicalMaterialsVersion(branchKeyId: string, branchKeyIdUtf8: seq<uint8>, version: string, cacheId: seq<uint8>)
        returns (material: Result<KeyStore.BranchKeyMaterials, Types.Error>)
      requires Invariant()
      requires keyStore.ValidState() && cache.ValidState()
      modifies keyStore.Modifies, cache.Modifies
      ensures keyStore.ValidState() && cache.ValidState()
      decreases branchKeyId, branchKeyIdUtf8, version, cacheId
    {
      var getCacheInput := Types.GetCacheEntryInput(identifier := cacheId, bytesUsed := None);
      var getCacheOutput := cache.GetCacheEntry(getCacheInput);
      if getCacheOutput.Failure? && !getCacheOutput.error.EntryDoesNotExist? {
        return Failure(getCacheOutput.error);
      }
      var now := Time.GetCurrent();
      if getCacheOutput.Failure? || !cacheEntryWithinLimits(creationTime := getCacheOutput.value.creationTime, now := now, ttlSeconds := ttlSeconds) {
        var maybeGetBranchKeyVersionOutput := keyStore.GetBranchKeyVersion(KeyStore.GetBranchKeyVersionInput(branchKeyIdentifier := branchKeyId, branchKeyVersion := version));
        var getBranchKeyVersionOutput :- maybeGetBranchKeyVersionOutput.MapFailure((e: Error) => Types.AwsCryptographyKeyStore(AwsCryptographyKeyStore := e));
        var branchKeyMaterials := getBranchKeyVersionOutput.branchKeyMaterials;
        var now := Time.GetCurrent();
        :- Need(now as int + ttlSeconds as int < UInt.INT64_MAX_LIMIT, Types.AwsCryptographicMaterialProvidersException(message := "INT64 Overflow when putting cache entry."));
        var putCacheEntryInput := Types.PutCacheEntryInput(identifier := cacheId, materials := Types.Materials.BranchKey(branchKeyMaterials), creationTime := now, expiryTime := ttlSeconds + now, messagesUsed := None, bytesUsed := None);
        var putResult := cache.PutCacheEntry(putCacheEntryInput);
        if putResult.Failure? && !putResult.error.EntryAlreadyExists? {
          return Failure(putResult.error);
        }
        return Success(branchKeyMaterials);
      } else {
        :- Need(getCacheOutput.value.materials.BranchKey?, E("Invalid Material Type."));
        return Success(getCacheOutput.value.materials.BranchKey);
      }
    }
  }

  datatype HierarchyUnwrapInfo = HierarchyUnwrapInfo

  datatype HierarchyWrapInfo = HierarchyWrapInfo

  class KmsHierarchyUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<HierarchyUnwrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        ghost var KeyLength: int32 := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite); |input.wrappedMaterial| == EXPECTED_EDK_CIPHERTEXT_OVERHEAD as int + KeyLength as int && |crypto.History.AESDecrypt| > 0 && Seq.Last(crypto.History.AESDecrypt).output.Success? && ghost var AESDecryptInput: AESDecryptInput := Seq.Last(crypto.History.AESDecrypt).input; true && ghost var AESDecryptOutput: seq<uint8> := Seq.Last(crypto.History.AESDecrypt).output.value; true && ghost var wrappedMaterial: seq<uint8> := input.wrappedMaterial; true && ghost var aad: Types.EncryptionContext := input.encryptionContext; true && ghost var salt: seq<BoundedInts.uint8> := wrappedMaterial[..H_WRAP_SALT_LEN]; true && ghost var iv: seq<BoundedInts.uint8> := wrappedMaterial[H_WRAP_SALT_LEN .. EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX]; true && ghost var branchKeyVersionUuid: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX]; true && ghost var wrappedKey: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX + KeyLength]; true && ghost var authTag: seq<BoundedInts.uint8> := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX + KeyLength..]; CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? && ghost var serializedEC: seq<uint8> := CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value; true && ghost var wrappingAad: seq<uint8> := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC); AESDecryptInput.encAlg == AES_256_ENC_ALG && AESDecryptInput.cipherTxt == wrappedKey && AESDecryptInput.authTag == authTag && AESDecryptInput.iv == iv && AESDecryptInput.aad == wrappingAad && AESDecryptOutput == res.value.unwrappedMaterial
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<HierarchyUnwrapInfo>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var wrappedMaterial := input.wrappedMaterial;
      var aad := input.encryptionContext;
      var KeyLength := AlgorithmSuites.GetEncryptKeyLength(suite);
      SequenceIsSafeBecauseItIsInMemory(wrappedMaterial);
      :- Need(|wrappedMaterial| as uint64 == EXPECTED_EDK_CIPHERTEXT_OVERHEAD as uint64 + KeyLength as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Received EDK Ciphertext of incorrect length2."));
      var salt := wrappedMaterial[..H_WRAP_SALT_LEN];
      var iv := wrappedMaterial[H_WRAP_SALT_LEN .. EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX];
      var branchKeyVersionUuid := wrappedMaterial[EDK_CIPHERTEXT_BRANCH_KEY_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX];
      var wrappedKey := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX .. EDK_CIPHERTEXT_VERSION_INDEX + KeyLength];
      var authTag := wrappedMaterial[EDK_CIPHERTEXT_VERSION_INDEX + KeyLength..];
      var serializedEC :- input.serializedEC;
      var wrappingAad := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC);
      var derivedBranchKey :- DeriveEncryptionKeyFromBranchKey(branchKey, salt, Some(PROVIDER_ID_HIERARCHY), crypto);
      var maybeUnwrappedPdk := crypto.AESDecrypt(Crypto.AESDecryptInput(encAlg := AES_256_ENC_ALG, key := derivedBranchKey, cipherTxt := wrappedKey, authTag := authTag, iv := iv, aad := wrappingAad));
      var unwrappedPdk :- maybeUnwrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      assert |unwrappedPdk| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat;
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := unwrappedPdk, unwrapInfo := HierarchyUnwrapInfo());
      return Success(output);
    }
  }

  class KmsHierarchyGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<HierarchyWrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<HierarchyWrapInfo>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == input.algorithmSuite.encrypt.AES_GCM.keyLength as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var pdkResult := crypto.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := GetEncryptKeyLength(suite)));
      var pdk :- pdkResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new KmsHierarchyWrapKeyMaterial(branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto);
      var wrapOutput: MaterialWrapping.WrapOutput<HierarchyWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := pdk, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := pdk, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := HierarchyWrapInfo());
      return Success(output);
    }
  }

  class KmsHierarchyWrapKeyMaterial extends MaterialWrapping.WrapMaterial<HierarchyWrapInfo> {
    const branchKey: seq<uint8>
    const branchKeyIdUtf8: UTF8.ValidUTF8Bytes
    const branchKeyVersionAsBytes: seq<uint8>
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (branchKey: seq<uint8>, branchKeyIdUtf8: UTF8.ValidUTF8Bytes, branchKeyVersionAsBytes: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.branchKey == branchKey && this.branchKeyIdUtf8 == branchKeyIdUtf8 && this.branchKeyVersionAsBytes == branchKeyVersionAsBytes && this.crypto == crypto
      ensures Invariant()
      decreases branchKey, branchKeyIdUtf8, branchKeyVersionAsBytes, crypto
    {
      this.branchKey := branchKey;
      this.branchKeyIdUtf8 := branchKeyIdUtf8;
      this.branchKeyVersionAsBytes := branchKeyVersionAsBytes;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        0 < |crypto.History.AESEncrypt| &&
        Seq.Last(crypto.History.AESEncrypt).output.Success? &&
        ghost var AESEncryptInput: AESEncryptInput := Seq.Last(crypto.History.AESEncrypt).input; true && ghost var AESEncryptOutput: AESEncryptOutput := Seq.Last(crypto.History.AESEncrypt).output.value; CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? && ghost var serializedEC: Result<seq<uint8>, Types.Error> := CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext); true && ghost var wrappingAad: seq<uint8> := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC.value); AESEncryptInput.encAlg == AES_256_ENC_ALG && AESEncryptInput.msg == input.plaintextMaterial && AESEncryptInput.aad == wrappingAad && |res.value.wrappedMaterial| > |AESEncryptOutput.cipherText| + |AESEncryptOutput.authTag| && res.value.wrapInfo == HierarchyWrapInfo())
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<HierarchyWrapInfo>, Types.Error>)
      requires Invariant()
      requires Requires(input)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var maybeNonceSalt := crypto.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := H_WRAP_SALT_LEN + H_WRAP_NONCE_LEN));
      var saltAndNonce :- maybeNonceSalt.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      assert |crypto.History.GenerateRandomBytes| == old(|crypto.History.GenerateRandomBytes|) + 1;
      assert |saltAndNonce| == (H_WRAP_NONCE_LEN + H_WRAP_SALT_LEN) as int;
      var salt := saltAndNonce[..H_WRAP_SALT_LEN];
      var nonce := saltAndNonce[H_WRAP_SALT_LEN..];
      var serializedEC :- input.serializedEC;
      var wrappingAad := WrappingAad(branchKeyIdUtf8, branchKeyVersionAsBytes, serializedEC);
      var derivedBranchKey :- DeriveEncryptionKeyFromBranchKey(branchKey, salt, Some(PROVIDER_ID_HIERARCHY), crypto);
      var maybeWrappedPdk := crypto.AESEncrypt(Crypto.AESEncryptInput(encAlg := AES_256_ENC_ALG, iv := nonce, key := derivedBranchKey, msg := input.plaintextMaterial, aad := wrappingAad));
      var wrappedPdk :- maybeWrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := salt + nonce + branchKeyVersionAsBytes + wrappedPdk.cipherText + wrappedPdk.authTag, wrapInfo := HierarchyWrapInfo());
      return Success(output);
    }
  }
}

module CacheConstants {
  const NULL_BYTE: seq<uint8> := [0]
  const RESOURCE_ID_CACHING_CMM: seq<uint8> := [1]
  const RESOURCE_ID_HIERARCHICAL_KEYRING: seq<uint8> := [2]
  const SCOPE_ID_ENCRYPT: seq<uint8> := [1]
  const SCOPE_ID_DECRYPT: seq<uint8> := [2]
  const SCOPE_ID_SEARCHABLE_ENCRYPTION: seq<uint8> := [3]

  import opened UInt = StandardLibrary.UInt

  import Seq
}

module {:options "/functionSyntax:4"} {:extern "software.amazon.cryptography.internaldafny.SynchronizedLocalCMC"} SynchronizedLocalCMC {

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import LocalCMC
  class {:extern} SynchronizedLocalCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies && this in Modifies
    {
      History in Modifies &&
      this in Modifies
    }

    predicate InternalValidState()
      reads this`InternalModifies, InternalModifies
      ensures InternalValidState() ==> History !in InternalModifies
      decreases InternalModifies + {this}
    {
      true &&
      History !in InternalModifies
    }

    constructor {:extern} (wrapped: LocalCMC.LocalCMC)
      ensures ValidState() && fresh(this.Modifies)
      decreases wrapped

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "GetCacheEntry"} GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "PutCacheEntry"} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "DeleteCacheEntry"} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      decreases InternalModifies

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "UpdateUsageMetadata"} UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      decreases InternalModifies
  }
}

module {:options "/functionSyntax:4"} LocalCMC {
  const NULL: Ref<CacheEntry> := Null
  const INT32_MAX_VALUE: int32 := 2040109465
  const INT64_MAX_VALUE: int64 := 8762203435012037017

  function {:opaque} RemoveCacheEntry(s: seq<CacheEntry>, v: CacheEntry): (s': seq<CacheEntry>)
    requires multiset(s)[v] == 1
    ensures v !in s'
    ensures multiset(s') == multiset(s) - multiset{v}
    ensures ghost var pos: nat := IndexOfCacheEntry(s, v); (forall i: nat {:trigger s'[i]} {:trigger s[i]} | 0 <= i < pos :: s[i] == s'[i]) && (forall i: nat {:trigger s'[i]} | pos <= i < |s'| :: s[i + 1] == s'[i]) && s' == s[..pos] + s[pos + 1..]
    decreases s, v
  {
    ghost var pos: nat := IndexOfCacheEntry(s, v);
    assert s == s[..pos] + s[pos..];
    assert multiset(s[pos..])[v] == 1;
    assert s[pos..] == [s[pos]] + s[pos + 1..];
    s[..pos] + s[pos + 1..]
  }

  function IndexOfCacheEntry(s: seq<CacheEntry>, v: CacheEntry): (pos: nat)
    requires v in s
    ensures pos < |s| && s[pos] == v
    ensures v !in s[..pos]
    decreases s, v
  {
    if s[0] == v then
      0
    else
      1 + IndexOfCacheEntry(s[1..], v)
  }

  method RemoveValue<K, V(==)>(k0: K, m: map<K, V>)
    requires k0 in m
    requires forall k: K, k': K {:trigger m[k'], m[k]} {:trigger m[k'], k in m} {:trigger m[k], k' in m} {:trigger k' in m, k in m} | k in m && k' in m && k != k' :: m[k] != m[k']
    ensures (m - {k0}).Values == m.Values - {m[k0]}
    decreases m
  {
    var m' := m - {k0};
    calc {
      m'.Values;
      set k: K {:trigger m'[k]} {:trigger k in m'} | k in m' :: m'[k];
      set k: K {:trigger m[k]} {:trigger k in m - {k0}} | k in m - {k0} :: m[k];
      m.Values - {m[k0]};
    }
  }

  predicate MutableMapIsInjective<K, V>(m: MutableMap<K, V>)
    reads m
    decreases {m}, m
  {
    forall k: K, k': K {:trigger m.Select(k'), m.Select(k)} {:trigger m.Select(k'), k in m.Keys()} {:trigger m.Select(k), k' in m.Keys()} {:trigger k' in m.Keys(), k in m.Keys()} | k in m.Keys() && k' in m.Keys() && k != k' :: 
      m.Select(k) != m.Select(k')
  }

  predicate MutableMapContains<K, V>(big: MutableMap<K, V>, small: MutableMap<K, V>)
    reads {big, small}
    decreases {big, small}, big, small
  {
    small.Keys() <= big.Keys() &&
    forall k: K {:trigger big.Select(k)} {:trigger small.Select(k)} {:trigger k in small.Keys()} | k in small.Keys() :: 
      small.Select(k) == big.Select(k)
  }

  lemma LemmaMutableMapContainsPreservesInjectivity<K, V>(big: MutableMap<K, V>, small: MutableMap<K, V>)
    requires MutableMapContains(big, small)
    requires MutableMapIsInjective(big)
    ensures MutableMapIsInjective(small)
    decreases big, small
  {
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened DafnyLibraries

  import Time

  import Types = AwsCryptographyMaterialProvidersTypes

  import Seq

  export
    reveals LocalCMC
    provides Types, Wrappers, DafnyLibraries, CacheEntry, UInt, LocalCMC.GetCacheEntry', LocalCMC.PutCacheEntry', LocalCMC.DeleteCacheEntry', LocalCMC.UpdateUsageMetadata', LocalCMC.GetCacheEntryEnsuresPublicly, LocalCMC.PutCacheEntryEnsuresPublicly, LocalCMC.DeleteCacheEntryEnsuresPublicly, LocalCMC.UpdateUsageMetadataEnsuresPublicly, LocalCMC.ValidState, LocalCMC.InternalValidState, LocalCMC.GetCacheEntryWithTime, LocalCMC.InternalDeleteCacheEntry?, LocalCMC.entryCapacity, LocalCMC.entryPruningTailSize


  datatype Ref<T> = Ptr(deref: T) | Null

  class CacheEntry {
    var prev: Ref<CacheEntry>
    var next: Ref<CacheEntry>
    const materials: Types.Materials
    const identifier: seq<uint8>
    const creationTime: Types.PositiveLong
    const expiryTime: Types.PositiveLong
    var messagesUsed: Types.PositiveInteger
    var bytesUsed: Types.PositiveInteger

    constructor (nameonly materials': Types.Materials, nameonly identifier': seq<uint8>, nameonly creationTime': Types.PositiveLong, nameonly expiryTime': Types.PositiveLong, nameonly messagesUsed': Types.PositiveInteger, nameonly bytesUsed': Types.PositiveInteger)
      ensures identifier == identifier' && materials == materials' && identifier == identifier' && creationTime == creationTime' && expiryTime == expiryTime' && messagesUsed == messagesUsed' && bytesUsed == bytesUsed'
      ensures prev == Null && next == Null
      ensures fresh(this)
      decreases materials', identifier', creationTime', expiryTime', messagesUsed', bytesUsed'
    {
      materials := materials';
      identifier := identifier';
      creationTime := creationTime';
      expiryTime := expiryTime';
      messagesUsed := messagesUsed';
      bytesUsed := bytesUsed';
      prev := NULL;
      next := NULL;
    }
  }

  class DoublyLinkedCacheEntryList {
    ghost var Items: seq<CacheEntry>

    predicate Invariant()
      reads this, Items
      decreases (set _s2s_0: CacheEntry? {:trigger _s2s_0 in Items} | _s2s_0 in Items :: _s2s_0) + {this}
    {
      (0 == |Items| <==> head.Null? && tail.Null?) &&
      (0 < |Items| <==> head.Ptr? && tail.Ptr? && head.deref == Items[0] && tail.deref == Items[|Items| - 1]) &&
      (head.Ptr? <==> tail.Ptr?) &&
      (head.Ptr? ==>
        head.deref.prev.Null?) &&
      (tail.Ptr? ==>
        tail.deref.next.Null?) &&
      (forall v: CacheEntry? {:trigger multiset(Items)[v]} {:trigger v in Items} | v in Items :: 
        multiset(Items)[v] == 1) &&
      forall i: nat {:trigger Items[i]} | 0 <= i < |Items| :: 
        Prev?(i, Items[i], Items) &&
        Next?(i, Items[i], Items)
    }

    predicate Prev?(i: nat, c: CacheEntry, Items': seq<CacheEntry>)
      requires 0 <= i < |Items'|
      requires Items'[i] == c
      reads Items'
      decreases set _s2s_0: CacheEntry? {:trigger _s2s_0 in Items'} | _s2s_0 in Items' :: _s2s_0, i, c, Items'
    {
      if i == 0 then
        Items'[0].prev.Null?
      else
        Items'[i].prev.Ptr? && Items'[i].prev.deref == Items'[i - 1]
    }

    predicate Next?(i: nat, c: CacheEntry, Items': seq<CacheEntry>)
      requires 0 <= i < |Items'|
      requires Items'[i] == c
      reads Items'
      decreases set _s2s_0: CacheEntry? {:trigger _s2s_0 in Items'} | _s2s_0 in Items' :: _s2s_0, i, c, Items'
    {
      if i < |Items'| - 1 then
        Items'[i].next.Ptr? &&
        Items'[i].next.deref == Items'[i + 1]
      else
        assert i == |Items'| - 1; true && Items'[i].next.Null?
    }

    constructor ()
      ensures Items == []
      ensures Invariant()
    {
      head := Null;
      tail := Null;
      Items := [];
    }

    var head: Ref<CacheEntry>
    var tail: Ref<CacheEntry>

    method pushCell(toPush: CacheEntry)
      requires toPush !in Items
      requires toPush.next.Null? && toPush.prev.Null?
      requires Invariant()
      modifies this, Items, toPush
      ensures Invariant()
      ensures Items == [toPush] + old(Items)
      decreases toPush
    {
      Items := [toPush] + Items;
      var cRef := Ptr(toPush);
      if head.Ptr? {
        head.deref.prev := cRef;
        toPush.next := head;
        head := cRef;
      } else {
        head := cRef;
        tail := head;
      }
    }

    method moveToFront(c: CacheEntry)
      requires c in Items
      requires exists i: nat {:trigger Items[i]} | 0 <= i < |Items| :: c == Items[i]
      requires Invariant()
      modifies this, Items
      ensures Invariant()
      ensures head.Ptr? && head.deref == c
      ensures multiset(Items) == multiset(old(Items))
      decreases c
    {
      if head.deref != c {
        var toPush := Ptr(c);
        remove(c);
        assert head.deref in Items;
        Items := [toPush.deref] + Items;
        if head.Ptr? {
          head.deref.prev := toPush;
          toPush.deref.next := head;
          head := toPush;
        } else {
          head := toPush;
          tail := head;
        }
      }
      assert head.Ptr? <==> tail.Ptr?;
    }

    method {:vcs_split_on_every_assert} remove(toRemove: CacheEntry)
      requires Invariant()
      requires toRemove in Items
      modifies this, Items
      ensures Invariant()
      ensures multiset(Items) == multiset(old(Items)) - multiset{toRemove}
      ensures toRemove !in Items
      ensures toRemove.next.Null? && toRemove.prev.Null?
      ensures |Items| < |old(Items)|
      decreases toRemove
    {
      ghost var pos := IndexOfCacheEntry(Items, toRemove);
      Items := RemoveCacheEntry(Items, toRemove);
      if toRemove.prev.Null? {
        assert toRemove.prev.Null? ==> Ptr(toRemove) == head;
        assert pos == 0;
        head := toRemove.next;
      } else {
        assert toRemove != head.deref;
        assert 0 != pos;
        assert 0 < |Items|;
        assert Items[pos - 1] == toRemove.prev.deref;
        toRemove.prev.deref.next := toRemove.next;
      }
      if toRemove.next.Null? {
        assert toRemove.next.Null? ==> Ptr(toRemove) == tail;
        tail := toRemove.prev;
      } else {
        assert toRemove != tail.deref;
        assert 0 < |Items|;
        toRemove.next.deref.prev := toRemove.prev;
      }
      label AFTER:
      assert {:split_here} true;
      assert Items == old@AFTER(Items);
      assert toRemove !in Items;
      toRemove.next := NULL;
      toRemove.prev := NULL;
    }
  }

  class LocalCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies && this in Modifies
    {
      History in Modifies &&
      this in Modifies
    }

    predicate InternalValidState()
      reads this`InternalModifies, InternalModifies
      ensures InternalValidState() ==> History !in InternalModifies
      decreases InternalModifies + {this}
    {
      History !in InternalModifies &&
      this in InternalModifies &&
      queue in InternalModifies &&
      cache in InternalModifies &&
      (forall i: CacheEntry {:trigger i in InternalModifies} {:trigger i in queue.Items} | i in queue.Items :: 
        i in InternalModifies) &&
      Invariant()
    }

    predicate Invariant()
      reads this, queue, queue.Items, cache
      decreases (set _s2s_0: CacheEntry? {:trigger _s2s_0 in queue.Items} | _s2s_0 in queue.Items :: _s2s_0) + {this, queue, cache}
    {
      queue.Invariant() &&
      MutableMapIsInjective(cache) &&
      multiset(cache.Values()) == multiset(queue.Items) &&
      (forall c: CacheEntry {:trigger c.identifier} {:trigger c in queue.Items} | c in queue.Items :: 
        c.identifier in cache.Keys() &&
        cache.Select(c.identifier) == c) &&
      ValueIsSafeBecauseItIsInMemory(cache.Size()); cache.Size() as uint64 <= entryCapacity
    }

    var queue: DoublyLinkedCacheEntryList
    var cache: MutableMap<seq<uint8>, CacheEntry>
    const entryCapacity: uint64
    const entryPruningTailSize: uint64

    constructor (entryCapacity': uint64, entryPruningTailSize': uint64 := 1)
      requires entryPruningTailSize' >= 1
      ensures entryCapacity == entryCapacity' && entryPruningTailSize == entryPruningTailSize' && ValidState() && InternalValidState() && fresh(this.Modifies) && fresh(this.InternalModifies)
      decreases entryCapacity', entryPruningTailSize'
    {
      entryCapacity := entryCapacity';
      entryPruningTailSize := entryPruningTailSize';
      cache := new MutableMap<seq<uint8>, CacheEntry>();
      queue := new DoublyLinkedCacheEntryList();
      History := new Types.ICryptographicMaterialsCacheCallHistory();
      Modifies := {History, this};
      InternalModifies := {queue, cache, this};
    }

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      decreases InternalModifies
    {
      var now := Time.GetCurrent();
      output := GetCacheEntryWithTime(input, now);
    }

    method GetCacheEntryWithTime(input: Types.GetCacheEntryInput, now: Types.PositiveLong) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      ensures output.Success? ==> now <= output.value.expiryTime
      decreases InternalModifies
    {
      if cache.HasKey(input.identifier) {
        var entry := cache.Select(input.identifier);
        if now <= entry.expiryTime {
          assert entry in multiset(queue.Items);
          queue.moveToFront(entry);
          output := Success(Types.GetCacheEntryOutput(materials := entry.materials, creationTime := entry.creationTime, expiryTime := entry.expiryTime, messagesUsed := entry.messagesUsed, bytesUsed := entry.bytesUsed));
          var _ /* _v0 */ :- pruning(now);
        } else {
          var _ /* _v1 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
          output := Failure(Types.EntryDoesNotExist(message := "Entry past TTL"));
        }
      } else {
        output := Failure(Types.EntryDoesNotExist(message := "Entry does not exist"));
      }
    }

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:vcs_split_on_every_assert} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures fresh(InternalModifies - old(InternalModifies))
      decreases InternalModifies
    {
      if entryCapacity == 0 {
        return Success(());
      }
      if cache.HasKey(input.identifier) {
        var _ /* _v2 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
      }
      assert input.identifier !in cache.Keys();
      assert 0 < entryCapacity;
      if entryCapacity == cache.Size() as uint64 {
        assert 0 < |multiset(cache.Values())|;
        assert queue.tail.deref.identifier in cache.Keys();
        var _ /* _v3 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := queue.tail.deref.identifier));
      }
      label CAN_ADD:
      var cell := new CacheEntry(materials' := input.materials, identifier' := input.identifier, creationTime' := input.creationTime, expiryTime' := input.expiryTime, messagesUsed' := input.messagesUsed.UnwrapOr(0), bytesUsed' := input.bytesUsed.UnwrapOr(0));
      if cell in cache.Values() {
        assert cell in multiset(cache.Values());
      }
      queue.pushCell(cell);
      cache.Put(input.identifier, cell);
      InternalModifies := InternalModifies + {cell};
      output := Success(());
      forall k: seq<uint8>, k': seq<uint8> | k in cache.Keys() && k' in cache.Keys() && k != k'
        ensures cache.Select(k) != cache.Select(k')
      {
        if k != input.identifier && k' != input.identifier {
          assert k in old@CAN_ADD(cache.Keys());
          assert k' in old@CAN_ADD(cache.Keys());
          assert old@CAN_ADD(cache.Select(k)) != old@CAN_ADD(cache.Select(k'));
        }
      }
      assert forall c: CacheEntry {:trigger c.identifier} {:trigger c in queue.Items} | c in queue.Items :: c.identifier in cache.Keys() && cache.Select(c.identifier) == c;
      assert Invariant();
    }

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    twostate predicate InternalDeleteCacheEntry?(input: Types.DeleteCacheEntryInput, new output: Result<(), Types.Error>)
      requires InternalValidState()
      reads InternalModifies
      decreases InternalModifies, input, output
    {
      input.identifier !in cache.Keys() &&
      (input.identifier in old(cache.Keys()) ==>
        true &&
        old(cache.Select(input.identifier)) !in queue.Items &&
        cache.Size() == old(cache.Size()) - 1 &&
        old(cache.Keys()) - {input.identifier} == cache.Keys())
    }

    method {:vcs_split_on_every_assert} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      ensures InternalDeleteCacheEntry?(input, output)
      decreases InternalModifies
    {
      if cache.HasKey(input.identifier) {
        assert input.identifier in cache.Keys();
        var cell := cache.Select(input.identifier);
        assert cell in multiset(queue.Items);
        label CAN_REMOVE:
        cache.Remove(input.identifier);
        assert cell !in cache.Values();
        assert MutableMapIsInjective(cache) by {
          assert forall k: seq<uint8> {:trigger old(cache.Select(k))} {:trigger k in cache.Keys()} | k in cache.Keys() :: old(allocated(cache.Select(k)));
          assert forall k: seq<uint8> {:trigger cache.Select(k)} {:trigger k in cache.Keys()} | k in cache.Keys() :: unchanged(cache.Select(k));
          assert MutableMapIsInjective(old@CAN_REMOVE(cache));
          assert MutableMapContains(old@CAN_REMOVE(cache), cache);
          LemmaMutableMapContainsPreservesInjectivity(old@CAN_REMOVE(cache), cache);
        }
        assert |cache.Keys()| == |old@CAN_REMOVE(cache.Keys())| - 1;
        assert cache.Size() as uint64 <= old@CAN_REMOVE(cache.Size()) as uint64 <= entryCapacity;
        queue.remove(cell);
        assert multiset(cache.Values()) == multiset(queue.Items) by {
          ghost var cacheMultiset := multiset(cache.Values());
          ghost var queueMultiset := multiset(queue.Items);
          assert cacheMultiset[cell := 0] == queueMultiset[cell := 0];
          assert cell !in cacheMultiset;
          assert cell !in queueMultiset;
        }
        InternalModifies := InternalModifies - {cell};
      }
      output := Success(());
    }

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures InternalModifies <= old(InternalModifies)
      decreases InternalModifies
    {
      if cache.HasKey(input.identifier) {
        var cell := cache.Select(input.identifier);
        assert cell in multiset(cache.Values());
        if cell.messagesUsed <= INT32_MAX_VALUE - 1 && cell.bytesUsed <= INT32_MAX_VALUE - input.bytesUsed {
          cell.messagesUsed, cell.bytesUsed := cell.messagesUsed + 1, cell.bytesUsed + input.bytesUsed;
        } else {
          var _ /* _v4 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := input.identifier));
        }
      }
      return Success(());
    }

    method pruning(now: Types.PositiveLong) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      decreases InternalModifies
    {
      for i: BoundedInts.uint64 := 0 to entryPruningTailSize
        invariant InternalValidState()
        invariant InternalModifies <= old(InternalModifies)
      {
        if queue.tail.Ptr? {
          if queue.tail.deref.expiryTime < now {
            var _ /* _v5 */ :- DeleteCacheEntry'(Types.DeleteCacheEntryInput(identifier := queue.tail.deref.identifier));
          } else {
            return Success(());
          }
        } else {
          return Success(());
        }
      }
      return Success(());
    }
  }
}

module {:options "/functionSyntax:4"} {:extern "software.amazon.cryptography.internaldafny.StormTrackingCMC"} StormTrackingCMC {
  function method CreateGetCacheEntrySuccess(output: Types.GetCacheEntryOutput): Result<Types.GetCacheEntryOutput, Types.Error>
    decreases output
  {
    Success(output)
  }

  function method CreateGetCacheEntryFailure(error: Types.Error): Result<Types.GetCacheEntryOutput, Types.Error>
    decreases error
  {
    Failure(error)
  }

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import StormTracker

  class {:extern} StormTrackingCMC extends Types.ICryptographicMaterialsCache {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies && this in Modifies
    {
      History in Modifies &&
      this in Modifies
    }

    predicate InternalValidState()
      reads this`InternalModifies, InternalModifies
      ensures InternalValidState() ==> History !in InternalModifies
      decreases InternalModifies + {this}
    {
      true &&
      History !in InternalModifies
    }

    constructor {:extern} (wrapped: StormTracker.StormTracker)
      ensures ValidState() && InternalValidState() && fresh(this.Modifies) && fresh(this.InternalModifies)
      decreases wrapped

    predicate GetCacheEntryEnsuresPublicly(input: Types.GetCacheEntryInput, output: Result<Types.GetCacheEntryOutput, Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "GetCacheEntry"} GetCacheEntry'(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures GetCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate PutCacheEntryEnsuresPublicly(input: Types.PutCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "PutCacheEntry"} PutCacheEntry'(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures PutCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases InternalModifies

    predicate DeleteCacheEntryEnsuresPublicly(input: Types.DeleteCacheEntryInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "DeleteCacheEntry"} DeleteCacheEntry'(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      ensures DeleteCacheEntryEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures InternalModifies <= old(InternalModifies)
      decreases InternalModifies

    predicate UpdateUsageMetadataEnsuresPublicly(input: Types.UpdateUsageMetadataInput, output: Result<(), Types.Error>)
      decreases input, output
    {
      true
    }

    method {:extern "UpdateUsageMetadata"} UpdateUsageMetadata'(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires InternalValidState()
      modifies InternalModifies
      ensures InternalValidState()
      decreases InternalModifies
  }
}

module {:options "/functionSyntax:4"} StormTracker {
  function method DefaultStorm(): Types.StormTrackingCache
  {
    Types.StormTrackingCache(entryCapacity := 1000, entryPruningTailSize := Some(1), gracePeriod := 10 * 1000, graceInterval := 1 * 1000, fanOut := 20, inFlightTTL := 10 * 1000, sleepMilli := 20, timeUnits := Some(Types.Milliseconds))
  }

  predicate method ConsistentSettings(cache: Types.StormTrackingCache)
    decreases cache
  {
    cache.graceInterval <= cache.gracePeriod &&
    cache.inFlightTTL <= cache.gracePeriod &&
    cache.graceInterval <= cache.inFlightTTL
  }

  function method N(n: Types.CountingNumber): string
    decreases n
  {
    String.Base10Int2String(n as int)
  }

  function method BadCacheMsg(cache: Types.StormTrackingCache): string
    requires !ConsistentSettings(cache)
    decreases cache
  {
    var msg: string := "For a StormCache : ";
    var msg: seq<char> := msg + if !(cache.graceInterval <= cache.gracePeriod) then "graceInterval must not exceed gracePeriod, yet configuration has graceInterval=" + N(cache.graceInterval) + " and gracePeriod=" + N(cache.gracePeriod) + ". " else "";
    var msg: seq<char> := msg + if !(cache.inFlightTTL <= cache.gracePeriod) then "inFlightTTL must not exceed gracePeriod, yet configuration has inFlightTTL=" + N(cache.inFlightTTL) + " and gracePeriod=" + N(cache.gracePeriod) + ". " else "";
    msg
  }

  function method CheckSettings(cache: Types.StormTrackingCache): (res: Outcome<Types.Error>)
    ensures res.Pass? ==> ConsistentSettings(cache)
    decreases cache
  {
    if ConsistentSettings(cache) then
      Pass
    else
      Fail(Types.AwsCryptographicMaterialProvidersException(message := BadCacheMsg(cache)))
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened DafnyLibraries

  import Types = AwsCryptographyMaterialProvidersTypes

  import LocalCMC

  import Time

  import SortedSets

  import Seq

  import String = StandardLibrary.String

  datatype CacheState = EmptyWait | EmptyFetch | Full(data: Types.GetCacheEntryOutput)

  class StormTracker {
    predicate ValidState()
      reads this, wrapped, wrapped.InternalModifies, inFlight
      decreases wrapped.InternalModifies + {this, wrapped, inFlight}
    {
      this !in wrapped.InternalModifies &&
      inFlight !in wrapped.InternalModifies &&
      wrapped.InternalValidState() &&
      wrapped.ValidState() &&
      0 < fanOut &&
      inFlight.Size() <= fanOut as nat &&
      graceInterval <= gracePeriod &&
      inFlightTTL <= gracePeriod
    }

    var wrapped: LocalCMC.LocalCMC
    var inFlight: MutableMap<seq<uint8>, Types.PositiveLong>
    var gracePeriod: Types.PositiveLong
    var graceInterval: Types.PositiveLong
    var fanOut: Types.PositiveLong
    var inFlightTTL: Types.PositiveLong
    var lastPrune: Types.PositiveLong
    var sleepMilli: Types.PositiveLong

    constructor (cache: Types.StormTrackingCache)
      requires ConsistentSettings(cache)
      ensures this.ValidState() && fresh(this.wrapped) && fresh(this.wrapped.InternalModifies) && fresh(this.inFlight)
      ensures inFlight.Size() == 0 && lastPrune == 0
      decreases cache
    {
      var gracePeriod, graceInterval, inFlightTTL;
      if cache.timeUnits.UnwrapOr(Types.Seconds).Seconds? {
        gracePeriod := cache.gracePeriod as Types.PositiveLong * 1000;
        graceInterval := cache.graceInterval as Types.PositiveLong * 1000;
        inFlightTTL := cache.inFlightTTL as Types.PositiveLong * 1000;
      } else {
        gracePeriod := cache.gracePeriod as Types.PositiveLong;
        graceInterval := cache.graceInterval as Types.PositiveLong;
        inFlightTTL := cache.inFlightTTL as Types.PositiveLong;
      }
      this.wrapped := new LocalCMC.LocalCMC(cache.entryCapacity as uint64, cache.entryPruningTailSize.UnwrapOr(1) as uint64);
      this.inFlight := new MutableMap<seq<uint8>, Types.PositiveLong>();
      this.gracePeriod := gracePeriod;
      this.graceInterval := graceInterval;
      this.fanOut := cache.fanOut as Types.PositiveLong;
      this.inFlightTTL := inFlightTTL;
      this.sleepMilli := cache.sleepMilli as Types.PositiveLong;
      this.lastPrune := 0;
    }

    method FanOutReached(now: Types.PositiveLong) returns (res: bool)
      requires ValidState()
      modifies this`lastPrune, inFlight
      ensures ValidState()
      ensures true && old(inFlight.Size()) < fanOut as nat ==> !res && inFlight.content() == old(inFlight.content())
      ensures !res <==> inFlight.Size() < fanOut as nat
      ensures res <==> inFlight.Size() == fanOut as nat
      decreases now
    {
      PruneInFlight(now);
      return fanOut <= inFlight.Size() as Types.PositiveLong;
    }

    function method AddLong(x: Types.PositiveLong, y: Types.PositiveLong): Types.PositiveLong
      decreases x, y
    {
      if x < INT64_MAX_LIMIT as Types.PositiveLong - y then
        x + y
      else
        INT64_MAX_LIMIT as Types.PositiveLong
    }

    lemma ExpiryTimeInSecondsCanBeConvertedToMilliseconds()
      ensures INT64_MAX_LIMIT / 1000 == 9223372036854775
    {
    }

    predicate method GracePeriod?(result: Types.GetCacheEntryOutput, now: Types.PositiveLong): (output: bool)
      requires now / 1000 <= result.expiryTime
      reads this`gracePeriod
      ensures output ==> result.expiryTime < 9223372036854775 && result.expiryTime * 1000 - gracePeriod <= now < (result.expiryTime + 1) * 1000
      decreases {this}, result, now
    {
      ExpiryTimeInSecondsCanBeConvertedToMilliseconds();
      result.expiryTime < 9223372036854775 &&
      result.expiryTime * 1000 - gracePeriod <= now
    }

    method CheckInFlight(identifier: seq<uint8>, result: Types.GetCacheEntryOutput, now: Types.PositiveLong)
        returns (output: CacheState)
      requires now / 1000 <= result.expiryTime
      requires ValidState()
      modifies this`lastPrune, inFlight
      ensures ValidState()
      ensures output.Full? ==> output.data == result
      ensures output.Full? ==> now as nat < (result.expiryTime as nat + 1) * 1000
      ensures output.EmptyFetch? ==> GracePeriod?(result, now)
      ensures !GracePeriod?(result, now) ==> output.Full?
      ensures output.EmptyFetch? ==> inFlight.HasKey(identifier) && inFlight.Select(identifier) == now
      ensures GracePeriod?(result, now) && old(inFlight.Size()) < fanOut as nat && !old(inFlight.HasKey(identifier)) ==> output.EmptyFetch?
      ensures GracePeriod?(result, now) && old(inFlight.Size()) < fanOut as nat && old(inFlight.HasKey(identifier)) && now < AddLong(old(inFlight.Select(identifier)), graceInterval) ==> output.Full?
      ensures GracePeriod?(result, now) && old(inFlight.Size()) < fanOut as nat && old(inFlight.HasKey(identifier)) && AddLong(old(inFlight.Select(identifier)), graceInterval) <= now ==> output.EmptyFetch?
      decreases identifier, result, now
    {
      var fanOutReached := FanOutReached(now);
      if fanOutReached {
        assert inFlight.Size() == fanOut as nat;
        return Full(result);
      } else if !GracePeriod?(result, now) {
        return Full(result);
      } else {
        if inFlight.HasKey(identifier) {
          var entry := inFlight.Select(identifier);
          if AddLong(entry, graceInterval) > now {
            return Full(result);
          }
        }
        inFlight.Put(identifier, now);
        return EmptyFetch;
      }
    }

    method PruneInFlight(now: Types.PositiveLong)
      requires ValidState()
      modifies this`lastPrune, inFlight
      ensures ValidState()
      ensures old(inFlight.Size()) < fanOut as nat ==> inFlight.content() == old(inFlight.content()) && inFlight.Size() < fanOut as nat
      decreases now
    {
      if inFlight.Size() as Types.PositiveLong < fanOut {
        return;
      }
      if now - 1000 < lastPrune {
        return;
      }
      lastPrune := now;
      var keySet := inFlight.Keys();
      var keys := SortedSets.ComputeSetToSequence(keySet);
      for i: uint64 := 0 to |keys| as uint64
        invariant forall k: int {:trigger keys[k]} | i as nat <= k < |keys| :: keys[k] in inFlight.Keys()
        invariant ValidState()
      {
        reveal Seq.HasNoDuplicates();
        var v := inFlight.Select(keys[i]);
        if now >= AddLong(v, inFlightTTL) {
          inFlight.Remove(keys[i]);
        }
      }
    }

    method CheckNewEntry(identifier: seq<uint8>, now: Types.PositiveLong) returns (output: CacheState)
      requires ValidState()
      modifies this`lastPrune, inFlight
      ensures ValidState()
      ensures !output.Full?
      ensures output.EmptyFetch? ==> inFlight.HasKey(identifier) && inFlight.Select(identifier) == now
      ensures old(inFlight.Size()) < fanOut as nat && !old(inFlight.HasKey(identifier)) ==> output.EmptyFetch?
      ensures old(inFlight.Size()) < fanOut as nat && old(inFlight.HasKey(identifier)) && now < AddLong(old(inFlight.Select(identifier)), graceInterval) ==> output.EmptyWait?
      ensures old(inFlight.Size()) < fanOut as nat && old(inFlight.HasKey(identifier)) && AddLong(old(inFlight.Select(identifier)), graceInterval) <= now ==> output.EmptyFetch?
      decreases identifier, now
    {
      var fanOutReached := FanOutReached(now);
      if fanOutReached {
        return EmptyWait;
      } else if inFlight.HasKey(identifier) {
        var entry := inFlight.Select(identifier);
        if now < AddLong(entry, graceInterval) {
          return EmptyWait;
        }
      }
      inFlight.Put(identifier, now);
      return EmptyFetch;
    }

    method GetFromCacheWithTime(input: Types.GetCacheEntryInput, now: Types.PositiveLong) returns (output: Result<CacheState, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.InternalModifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.InternalModifies <= old(wrapped.InternalModifies)
      decreases input, now
    {
      var result := wrapped.GetCacheEntryWithTime(input, now / 1000);
      if result.Success? {
        var newResult := CheckInFlight(input.identifier, result.value, now);
        return Success(newResult);
      } else if result.error.EntryDoesNotExist? {
        var newResult := CheckNewEntry(input.identifier, now);
        return Success(newResult);
      } else {
        return Failure(result.error);
      }
    }

    method GetFromCache(input: Types.GetCacheEntryInput) returns (output: Result<CacheState, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.InternalModifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.InternalModifies <= old(wrapped.InternalModifies)
      decreases input
    {
      var now := Time.GetCurrentMilli();
      output := GetFromCacheWithTime(input, now);
    }

    method GetCacheEntry(input: Types.GetCacheEntryInput) returns (output: Result<Types.GetCacheEntryOutput, Types.Error>)
      requires ValidState()
      modifies this`lastPrune, inFlight, wrapped.InternalModifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures wrapped.InternalModifies <= old(wrapped.InternalModifies)
      decreases input
    {
      var result := GetFromCache(input);
      if result.Failure? {
        return Failure(result.error);
      } else if result.value.Full? {
        return Success(result.value.data);
      } else {
        return Failure(Types.EntryDoesNotExist(message := "Entry does not exist"));
      }
    }

    method PutCacheEntry(input: Types.PutCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.InternalModifies
      ensures ValidState()
      ensures inFlight == old(inFlight)
      ensures wrapped == old(wrapped)
      ensures fresh(wrapped.InternalModifies - old(wrapped.InternalModifies))
      decreases input
    {
      inFlight.Remove(input.identifier);
      output := wrapped.PutCacheEntry'(input);
    }

    method DeleteCacheEntry(input: Types.DeleteCacheEntryInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.InternalModifies
      ensures ValidState()
      ensures wrapped.InternalModifies <= old(wrapped.InternalModifies)
      decreases input
    {
      inFlight.Remove(input.identifier);
      output := wrapped.DeleteCacheEntry'(input);
    }

    method UpdateUsageMetadata(input: Types.UpdateUsageMetadataInput) returns (output: Result<(), Types.Error>)
      requires ValidState()
      modifies inFlight, wrapped.InternalModifies
      ensures ValidState()
      decreases input
    {
      output := wrapped.UpdateUsageMetadata'(input);
    }
  }
}

module {:options "/functionSyntax:4"} AwsKmsEcdhKeyring {
  const AWS_KMS_ECDH_KEYRING_VERSION := RawECDHKeyring.RAW_ECDH_KEYRING_VERSION

  method {:vcs_split_on_every_assert} DeriveSharedSecret(client: KMS.IKMSClient, senderAwsKmsKey: AwsKmsIdentifierString, recipientPublicKey: seq<uint8>, grantTokens: KMS.GrantTokenList)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires client.ValidState()
    requires KMS.IsValid_PublicKeyType(recipientPublicKey)
    modifies client.Modifies
    ensures client.ValidState()
    ensures res.Success? ==> 0 < |client.History.DeriveSharedSecret| && Last(client.History.DeriveSharedSecret).input == KMS.DeriveSharedSecretRequest(KeyId := senderAwsKmsKey, KeyAgreementAlgorithm := KMS.KeyAgreementAlgorithmSpec.ECDH, PublicKey := recipientPublicKey, GrantTokens := Some(grantTokens))
    decreases client, senderAwsKmsKey, recipientPublicKey, grantTokens
  {
    var deriveSharedSecretRequest := KMS.DeriveSharedSecretRequest(KeyId := senderAwsKmsKey, KeyAgreementAlgorithm := KMS.KeyAgreementAlgorithmSpec.ECDH, PublicKey := recipientPublicKey, GrantTokens := Some(grantTokens));
    var maybeDeriveSharedSecret := client.DeriveSharedSecret(deriveSharedSecretRequest);
    var deriveSharedSecretResponse :- maybeDeriveSharedSecret.MapFailure((e: Error) => Types.ComAmazonawsKms(ComAmazonawsKms := e));
    :- Need(deriveSharedSecretResponse.KeyId.Some? && deriveSharedSecretResponse.SharedSecret.Some? && deriveSharedSecretResponse.KeyAgreementAlgorithm.Some? && deriveSharedSecretResponse.KeyId.value == senderAwsKmsKey && deriveSharedSecretResponse.KeyAgreementAlgorithm.value == KMS.KeyAgreementAlgorithmSpec.ECDH, E(s := "Invalid response from KMS DeriveSharedSecret"));
    return Success(deriveSharedSecretResponse.SharedSecret.value);
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened AwsArnParsing

  import opened AwsKmsUtils

  import opened Seq

  import opened Actions

  import opened Constants

  import opened A = AwsKmsMrkMatchForDecrypt

  import opened AlgorithmSuites

  import RawECDHKeyring

  import Keyring

  import Materials

  import Types = AwsCryptographyMaterialProvidersTypes

  import PrimitiveTypes = AwsCryptographyPrimitivesTypes

  import KMS = ComAmazonawsKmsTypes

  import UTF8

  import UUID

  import EdkWrapping

  import MaterialWrapping

  import EcdhEdkWrapping

  import ErrorMessages

  import AtomicPrimitives

  import CanonicalEncryptionContext

  class AwsKmsEcdhKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const senderKmsKeyId: Option<AwsKmsIdentifierString>
    const senderPublicKey: Option<KMS.PublicKeyType>
    const recipientPublicKey: KMS.PublicKeyType
    const compressedSenderPublicKey: Option<seq<uint8>>
    const compressedRecipientPublicKey: seq<uint8>
    const keyAgreementScheme: Types.KmsEcdhStaticConfigurations
    const curveSpec: PrimitiveTypes.ECDHCurveSpec
    const grantTokens: KMS.GrantTokenList
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies &&
      cryptoPrimitives.ValidState() &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies
    }

    constructor (KeyAgreementScheme: Types.KmsEcdhStaticConfigurations, curveSpec: PrimitiveTypes.ECDHCurveSpec, client: KMS.IKMSClient, grantTokens: KMS.GrantTokenList, senderKmsKeyId: Option<AwsKmsIdentifierString>, senderPublicKey: Option<KMS.PublicKeyType>, recipientPublicKey: KMS.PublicKeyType, compressedSenderPublicKey: Option<seq<uint8>>, compressedRecipientPublicKey: seq<uint8>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires client.ValidState()
      requires cryptoPrimitives.ValidState()
      requires KMS.IsValid_PublicKeyType(recipientPublicKey)
      requires senderPublicKey.Some? ==> KMS.IsValid_PublicKeyType(senderPublicKey.value)
      requires |recipientPublicKey| < UINT32_LIMIT
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies - cryptoPrimitives.Modifies)
      decreases KeyAgreementScheme, curveSpec, client, grantTokens, senderKmsKeyId, senderPublicKey, recipientPublicKey, compressedSenderPublicKey, compressedRecipientPublicKey, cryptoPrimitives
    {
      this.keyAgreementScheme := KeyAgreementScheme;
      this.curveSpec := curveSpec;
      this.client := client;
      this.grantTokens := grantTokens;
      this.recipientPublicKey := recipientPublicKey;
      this.senderPublicKey := senderPublicKey;
      this.compressedSenderPublicKey := compressedSenderPublicKey;
      this.compressedRecipientPublicKey := compressedRecipientPublicKey;
      this.senderKmsKeyId := senderKmsKeyId;
      this.cryptoPrimitives := cryptoPrimitives;
      History := new Types.IKeyringCallHistory();
      Modifies := {History};
      Modifies := Modifies + client.Modifies + cryptoPrimitives.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> res.Failure?
      ensures this.keyAgreementScheme.KmsPublicKeyDiscovery? ==> res.Failure?
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> res.Failure?
      decreases Modifies - {History}
    {
      :- Need(!keyAgreementScheme.KmsPublicKeyDiscovery?, E("KmsPublicKeyDiscovery Key Agreement Scheme is forbidden on encrypt."));
      :- Need(this.senderKmsKeyId.Some?, E("Keyring MUST be configured with a sender KMS Key ID"));
      :- Need(this.senderPublicKey.Some?, E("Keyring MUST be configured with a senderPublicKey"));
      var senderKmsKeyId := this.senderKmsKeyId.value;
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var stringifiedEncCtx :- StringifyEncryptionContext(input.materials.encryptionContext);
      var sharedSecret :- DeriveSharedSecret(client, senderKmsKeyId, recipientPublicKey, grantTokens);
      var operationCompressedSenderPublicKey := if this.compressedSenderPublicKey.None? then [] else this.compressedSenderPublicKey.value;
      var curveSpecUtf8 :- UTF8.Encode(RawECDHKeyring.CurveSpecTypeToString(this.curveSpec)).MapFailure(WrapStringToError);
      var canonicalizedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext);
      var fixedInfo := EcdhEdkWrapping.SerializeFixedInfo(ECDH_KDF_UTF8, curveSpecUtf8, operationCompressedSenderPublicKey, this.compressedRecipientPublicKey, canonicalizedEC, AWS_KMS_ECDH_KEYRING_VERSION);
      var ecdhGenerateAndWrap := new EcdhEdkWrapping.EcdhGenerateAndWrapKeyMaterial(sharedSecret, fixedInfo, cryptoPrimitives);
      var ecdhWrap := new EcdhEdkWrapping.EcdhWrapKeyMaterial(sharedSecret, fixedInfo, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<EcdhEdkWrapping.EcdhWrapInfo>(encryptionMaterials := materials, wrap := ecdhWrap, generateAndWrap := ecdhGenerateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      :- Need(RawECDHKeyring.ValidCompressedPublicKeyLength(operationCompressedSenderPublicKey) && RawECDHKeyring.ValidCompressedPublicKeyLength(compressedRecipientPublicKey), E("Invalid compressed public key length."));
      var edk := Types.EncryptedDataKey(keyProviderId := KMS_ECDH_PROVIDER_ID, keyProviderInfo := RawECDHKeyring.SerializeProviderInfo(operationCompressedSenderPublicKey, compressedRecipientPublicKey), ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), E("Keyring received decryption materials that already contain a plaintext data key."));
      var filter := new OnDecryptEcdhDataKeyFilter(keyAgreementScheme, this.compressedRecipientPublicKey, this.compressedSenderPublicKey);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(E(errorMessage));
      }
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, cryptoPrimitives, this.compressedRecipientPublicKey, client, grantTokens, keyAgreementScheme, curveSpec);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient
    const recipientPublicKey: seq<uint8>
    const client: KMS.IKMSClient
    const grantTokens: KMS.GrantTokenList
    const keyAgreementScheme: Types.KmsEcdhStaticConfigurations
    const curveSpec: PrimitiveTypes.ECDHCurveSpec

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient, recipientPublicKey: seq<uint8>, client: KMS.IKMSClient, grantTokens: KMS.GrantTokenList, keyAgreementScheme: Types.KmsEcdhStaticConfigurations, curveSpec: PrimitiveTypes.ECDHCurveSpec)
      requires cryptoPrimitives.ValidState() && client.ValidState()
      ensures this.materials == materials && this.cryptoPrimitives == cryptoPrimitives && this.recipientPublicKey == recipientPublicKey && this.keyAgreementScheme == keyAgreementScheme && this.client == client && this.curveSpec == curveSpec && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, cryptoPrimitives, recipientPublicKey, client, grantTokens, keyAgreementScheme, curveSpec
    {
      this.materials := materials;
      this.cryptoPrimitives := cryptoPrimitives;
      this.recipientPublicKey := recipientPublicKey;
      this.keyAgreementScheme := keyAgreementScheme;
      this.client := client;
      this.curveSpec := curveSpec;
      this.grantTokens := grantTokens;
      Modifies := cryptoPrimitives.Modifies + client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      client.ValidState() &&
      cryptoPrimitives.Modifies + client.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value)
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true &&
      UTF8.ValidUTF8Seq(edk.keyProviderId)
    }

    method {:vcs_split_on_every_assert} Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      requires Requires(edk)
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      assert UTF8.ValidUTF8Seq(edk.keyProviderId);
      var suite := materials.algorithmSuite;
      var keyProviderId := edk.keyProviderId;
      var providerInfo := edk.keyProviderInfo;
      var ciphertext := edk.ciphertext;
      var providerWrappedMaterial :- EdkWrapping.GetProviderWrappedMaterial(ciphertext, suite);
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 <= ECDH_PROVIDER_INFO_521_LEN as uint64 && RawECDHKeyring.ValidProviderInfoLength(providerInfo), E("EDK ProviderInfo longer than expected"));
      var keyringVersion := providerInfo[0 as uint32];
      :- Need([keyringVersion] == AWS_KMS_ECDH_KEYRING_VERSION, E("Incorrect Keyring version found in provider info."));
      var recipientPublicKeyLength := SeqToUInt32(providerInfo[ECDH_PROVIDER_INFO_RPL_INDEX .. ECDH_PROVIDER_INFO_RPK_INDEX]);
      var recipientPublicKeyLengthIndex := ECDH_PROVIDER_INFO_RPK_INDEX as uint64 + recipientPublicKeyLength as uint64;
      var senderPublicKeyIndex := recipientPublicKeyLengthIndex + ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN;
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(recipientPublicKeyLengthIndex + 4 < |providerInfo| as uint64, E("Key Provider Info Serialization Error. Serialized length less than expected."));
      var providerInfoRecipientPublicKey := providerInfo[ECDH_PROVIDER_INFO_RPK_INDEX .. recipientPublicKeyLengthIndex];
      var providerInfoSenderPublicKey := providerInfo[senderPublicKeyIndex..];
      var senderPublicKey :- RawECDHKeyring.DecompressPublicKey(providerInfoSenderPublicKey, this.curveSpec, this.cryptoPrimitives);
      var recipientPublicKey :- RawECDHKeyring.DecompressPublicKey(providerInfoRecipientPublicKey, this.curveSpec, this.cryptoPrimitives);
      var _ /* _v0 */ :- RawECDHKeyring.ValidatePublicKey(this.cryptoPrimitives, this.curveSpec, senderPublicKey);
      var _ /* _v1 */ :- RawECDHKeyring.ValidatePublicKey(this.cryptoPrimitives, this.curveSpec, recipientPublicKey);
      :- Need(KMS.IsValid_PublicKeyType(senderPublicKey) && KMS.IsValid_PublicKeyType(this.recipientPublicKey), E("Received serialized sender public key of incorrect length"));
      var sharedSecretPublicKey: seq<uint8>;
      var sharedSecretKmsKeyId;
      match this.keyAgreementScheme {
        case {:split false} KmsPublicKeyDiscovery(kmsPublicKeyDiscovery) =>
          {
            var _ /* _v2 */ :- ValidateKmsKeyId(kmsPublicKeyDiscovery.recipientKmsIdentifier);
            sharedSecretPublicKey := senderPublicKey;
            sharedSecretKmsKeyId := kmsPublicKeyDiscovery.recipientKmsIdentifier;
          }
        case {:split false} KmsPrivateKeyToStaticPublicKey(kmsPrivateKeyToStaticPublicKey) =>
          {
            var _ /* _v3 */ :- ValidateKmsKeyId(kmsPrivateKeyToStaticPublicKey.senderKmsIdentifier);
            sharedSecretKmsKeyId := kmsPrivateKeyToStaticPublicKey.senderKmsIdentifier;
            if kmsPrivateKeyToStaticPublicKey.recipientPublicKey == recipientPublicKey {
              sharedSecretPublicKey := recipientPublicKey;
            } else {
              sharedSecretPublicKey := senderPublicKey;
            }
          }
      }
      :- Need(KMS.IsValid_PublicKeyType(sharedSecretPublicKey), E("Received Recipient Public Key of incorrect expected length"));
      var sharedSecret :- DeriveSharedSecret(client, sharedSecretKmsKeyId, sharedSecretPublicKey, grantTokens);
      var ecdhUnwrap := new EcdhEdkWrapping.EcdhUnwrap(providerInfoSenderPublicKey, providerInfoRecipientPublicKey, sharedSecret, AWS_KMS_ECDH_KEYRING_VERSION, curveSpec, cryptoPrimitives);
      var unwrapOutputRes := RawECDHKeyring.EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, ecdhUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }

  class OnDecryptEcdhDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const keyAgreementScheme: Types.KmsEcdhStaticConfigurations
    const compressedRecipientPublicKey: seq<uint8>
    const compressedSenderPublicKey: seq<uint8>

    constructor (keyAgreementScheme: Types.KmsEcdhStaticConfigurations, compressedRecipientPublicKey: seq<uint8>, compressedSenderPublicKey: Option<seq<uint8>>)
      decreases keyAgreementScheme, compressedRecipientPublicKey, compressedSenderPublicKey
    {
      this.keyAgreementScheme := keyAgreementScheme;
      this.compressedRecipientPublicKey := compressedRecipientPublicKey;
      if compressedSenderPublicKey.Some? {
        this.compressedSenderPublicKey := compressedSenderPublicKey.value;
      } else {
        this.compressedSenderPublicKey := [];
      }
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        (edk.keyProviderId == KMS_ECDH_PROVIDER_ID || edk.keyProviderId == RAW_ECDH_PROVIDER_ID) &&
        UTF8.ValidUTF8Seq(edk.keyProviderId))
    }

    method {:vcs_split_on_every_assert} Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var providerInfo := edk.keyProviderInfo;
      var providerId := edk.keyProviderId;
      if providerId != RAW_ECDH_PROVIDER_ID && providerId != KMS_ECDH_PROVIDER_ID {
        return Success(false);
      }
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 <= ECDH_PROVIDER_INFO_521_LEN as uint64 && RawECDHKeyring.ValidProviderInfoLength(providerInfo), E("EDK ProviderInfo longer than expected"));
      var keyringVersion := providerInfo[0 as uint32];
      :- Need([keyringVersion] == AWS_KMS_ECDH_KEYRING_VERSION, E("Incorrect Keyring version found in provider info."));
      var recipientPublicKeyLength := SeqToUInt32(providerInfo[ECDH_PROVIDER_INFO_RPL_INDEX .. ECDH_PROVIDER_INFO_RPK_INDEX]);
      var recipientPublicKeyLengthIndex := ECDH_PROVIDER_INFO_RPK_INDEX as uint64 + recipientPublicKeyLength as uint64;
      var senderPublicKeyIndex := recipientPublicKeyLengthIndex + ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN;
      :- Need(recipientPublicKeyLengthIndex + 4 < |providerInfo| as uint64, E("Key Provider Info Serialization Error. Serialized length less than expected."));
      var providerInfoRecipientPublicKey := providerInfo[ECDH_PROVIDER_INFO_RPK_INDEX .. recipientPublicKeyLengthIndex];
      var providerInfoSenderPublicKey := providerInfo[senderPublicKeyIndex..];
      if this.keyAgreementScheme.KmsPublicKeyDiscovery? {
        return Success(this.compressedRecipientPublicKey == providerInfoRecipientPublicKey);
      } else {
        return Success((this.compressedSenderPublicKey == providerInfoSenderPublicKey && this.compressedRecipientPublicKey == providerInfoRecipientPublicKey) || (this.compressedSenderPublicKey == providerInfoRecipientPublicKey && this.compressedRecipientPublicKey == providerInfoSenderPublicKey));
      }
    }
  }
}

module {:options "/functionSyntax:4"} RawECDHKeyring {
  const RAW_ECDH_KEYRING_VERSION: seq<uint8> := [1]

  predicate method ValidPublicKeyLength(p: seq<uint8>)
    decreases p
  {
    SequenceIsSafeBecauseItIsInMemory(p);
    var len: uint64 := |p| as uint64;
    true &&
    (len == ECDH_PUBLIC_KEY_LEN_ECC_NIST_256 || len == ECDH_PUBLIC_KEY_LEN_ECC_NIST_384 || len == ECDH_PUBLIC_KEY_LEN_ECC_NIST_521)
  }

  predicate method ValidCompressedPublicKeyLength(p: seq<uint8>)
    decreases p
  {
    SequenceIsSafeBecauseItIsInMemory(p);
    var len: uint64 := |p| as uint64;
    true &&
    (len == ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_256 || len == ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_384 || len == ECDH_PUBLIC_KEY_COMPRESSED_LEN_ECC_NIST_521)
  }

  predicate method ValidProviderInfoLength(p: seq<uint8>)
    decreases p
  {
    SequenceIsSafeBecauseItIsInMemory(p);
    var len: uint64 := |p| as uint64;
    len == ECDH_PROVIDER_INFO_256_LEN as uint64 || len == ECDH_PROVIDER_INFO_384_LEN as uint64 || len == ECDH_PROVIDER_INFO_521_LEN as uint64
  }

  method {:vcs_split_on_every_assert} LocalDeriveSharedSecret(senderPrivateKey: PrimitiveTypes.ECCPrivateKey, recipientPublicKey: PrimitiveTypes.ECCPublicKey, curveSpec: PrimitiveTypes.ECDHCurveSpec, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.DeriveSharedSecret| > 0 && Last(crypto.History.DeriveSharedSecret).output.Success? && Last(crypto.History.DeriveSharedSecret).input == PrimitiveTypes.DeriveSharedSecretInput(eccCurve := curveSpec, privateKey := senderPrivateKey, publicKey := recipientPublicKey) && Last(crypto.History.DeriveSharedSecret).output.value.sharedSecret == res.value
    decreases senderPrivateKey, recipientPublicKey, curveSpec, crypto
  {
    var maybeSharedSecret := crypto.DeriveSharedSecret(PrimitiveTypes.DeriveSharedSecretInput(eccCurve := curveSpec, privateKey := senderPrivateKey, publicKey := recipientPublicKey));
    var sharedSecretOutput :- maybeSharedSecret.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    return Success(sharedSecretOutput.sharedSecret);
  }

  method {:vcs_split_on_every_assert} CompressPublicKey(publicKey: PrimitiveTypes.ECCPublicKey, curveSpec: PrimitiveTypes.ECDHCurveSpec, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.CompressPublicKey| > 0 && Last(crypto.History.CompressPublicKey).output.Success? && Last(crypto.History.CompressPublicKey).input == PrimitiveTypes.CompressPublicKeyInput(eccCurve := curveSpec, publicKey := publicKey) && Last(crypto.History.CompressPublicKey).output.value.compressedPublicKey == res.value
    decreases publicKey, curveSpec, crypto
  {
    var maybeCompressedPublicKey := crypto.CompressPublicKey(PrimitiveTypes.CompressPublicKeyInput(publicKey := publicKey, eccCurve := curveSpec));
    var compressedPublicKey :- maybeCompressedPublicKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    return Success(compressedPublicKey.compressedPublicKey);
  }

  method {:vcs_split_on_every_assert} DecompressPublicKey(publicKey: seq<uint8>, curveSpec: PrimitiveTypes.ECDHCurveSpec, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.DecompressPublicKey| > 0 && Last(crypto.History.DecompressPublicKey).output.Success? && Last(crypto.History.DecompressPublicKey).input == PrimitiveTypes.DecompressPublicKeyInput(eccCurve := curveSpec, compressedPublicKey := publicKey) && Last(crypto.History.DecompressPublicKey).output.value.publicKey.der == res.value
    decreases publicKey, curveSpec, crypto
  {
    var maybePublicKey := crypto.DecompressPublicKey(PrimitiveTypes.DecompressPublicKeyInput(compressedPublicKey := publicKey, eccCurve := curveSpec));
    var publicKey :- maybePublicKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    return Success(publicKey.publicKey.der);
  }

  function method SerializeProviderInfo(senderPublicKey: seq<uint8>, recipientPublicKey: seq<uint8>): (res: seq<uint8>)
    requires ValidCompressedPublicKeyLength(recipientPublicKey)
    requires ValidCompressedPublicKeyLength(senderPublicKey)
    ensures |res| == |RAW_ECDH_KEYRING_VERSION| + |UInt32ToSeq(|recipientPublicKey| as uint32)| + |recipientPublicKey| + |UInt32ToSeq(|senderPublicKey| as uint32)| + |senderPublicKey|
    decreases senderPublicKey, recipientPublicKey
  {
    RAW_ECDH_KEYRING_VERSION + UInt32ToSeq(|recipientPublicKey| as uint32) + recipientPublicKey + UInt32ToSeq(|senderPublicKey| as uint32) + senderPublicKey
  }

  method {:vcs_split_on_every_assert} GenerateEphemeralEccKeyPair(curveSpec: PrimitiveTypes.ECDHCurveSpec, crypto: AtomicPrimitives.AtomicPrimitivesClient) returns (res: Result<PrimitiveTypes.GenerateECCKeyPairOutput, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.GenerateECCKeyPair| > 0 && Last(crypto.History.GenerateECCKeyPair).output.Success? && Last(crypto.History.GenerateECCKeyPair).input == PrimitiveTypes.GenerateECCKeyPairInput(eccCurve := curveSpec)
    decreases curveSpec, crypto
  {
    var maybeKeyPair := crypto.GenerateECCKeyPair(PrimitiveTypes.GenerateECCKeyPairInput(eccCurve := curveSpec));
    var keyPair :- maybeKeyPair.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    res := Success(keyPair);
  }

  method ValidatePublicKey(crypto: AtomicPrimitives.AtomicPrimitivesClient, curveSpec: PrimitiveTypes.ECDHCurveSpec, publicKey: seq<uint8>)
      returns (res: Result<bool, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures res.Success? ==> |crypto.History.ValidatePublicKey| > 0 && Last(crypto.History.ValidatePublicKey).output.Success? && Last(crypto.History.ValidatePublicKey).input == PrimitiveTypes.ValidatePublicKeyInput(eccCurve := curveSpec, publicKey := publicKey)
    decreases crypto, curveSpec, publicKey
  {
    var maybeValidate := crypto.ValidatePublicKey(PrimitiveTypes.ValidatePublicKeyInput(eccCurve := curveSpec, publicKey := publicKey));
    var validate :- maybeValidate.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    res := Success(validate.success);
  }

  function method CurveSpecTypeToString(c: PrimitiveTypes.ECDHCurveSpec): string
    decreases c
  {
    match c {
      case ECC_NIST_P256() =>
        "p256"
      case ECC_NIST_P384() =>
        "p384"
      case ECC_NIST_P521() =>
        "p521"
      case SM2() =>
        "sm2"
    }
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened String = StandardLibrary.String

  import opened Actions

  import opened Wrappers

  import opened Constants

  import Types = AwsCryptographyMaterialProvidersTypes

  import PrimitiveTypes = AwsCryptographyPrimitivesTypes

  import AtomicPrimitives

  import Keyring

  import Materials

  import opened AlgorithmSuites

  import Random

  import ECDH

  import UTF8

  import opened Seq

  import MaterialWrapping

  import EdkWrapping

  import EcdhEdkWrapping

  import ErrorMessages

  import CanonicalEncryptionContext

  class RawEcdhKeyring extends Keyring.VerifiableInterface {
    const senderPrivateKey: PrimitiveTypes.ECCPrivateKey
    const senderPublicKey: PrimitiveTypes.ECCPublicKey
    const recipientPublicKey: PrimitiveTypes.ECCPublicKey
    const compressedSenderPublicKey: seq<uint8>
    const compressedRecipientPublicKey: seq<uint8>
    const keyAgreementScheme: Types.RawEcdhStaticConfigurations
    const curveSpec: PrimitiveTypes.ECDHCurveSpec
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.ValidState() &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies
    }

    constructor (keyAgreementScheme: Types.RawEcdhStaticConfigurations, curveSpec: PrimitiveTypes.ECDHCurveSpec, senderPrivateKey: Option<seq<uint8>>, senderPublicKey: Option<seq<uint8>>, recipientPublicKey: seq<uint8>, compressedSenderPublicKey: Option<seq<uint8>>, compressedRecipientPublicKey: seq<uint8>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires senderPublicKey.Some? ==> ValidPublicKeyLength(senderPublicKey.value)
      requires ValidPublicKeyLength(recipientPublicKey)
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies)
      decreases keyAgreementScheme, curveSpec, senderPrivateKey, senderPublicKey, recipientPublicKey, compressedSenderPublicKey, compressedRecipientPublicKey, cryptoPrimitives
    {
      this.keyAgreementScheme := keyAgreementScheme;
      this.curveSpec := curveSpec;
      this.cryptoPrimitives := cryptoPrimitives;
      this.recipientPublicKey := PrimitiveTypes.ECCPublicKey(der := recipientPublicKey);
      this.compressedRecipientPublicKey := compressedRecipientPublicKey;
      if senderPublicKey.Some? && senderPrivateKey.Some? && compressedSenderPublicKey.Some? {
        this.senderPublicKey := PrimitiveTypes.ECCPublicKey(der := senderPublicKey.value);
        this.senderPrivateKey := PrimitiveTypes.ECCPrivateKey(pem := senderPrivateKey.value);
        this.compressedSenderPublicKey := compressedSenderPublicKey.value;
      } else {
        this.senderPublicKey := PrimitiveTypes.ECCPublicKey(der := []);
        this.senderPrivateKey := PrimitiveTypes.ECCPrivateKey(pem := []);
        this.compressedSenderPublicKey := [];
      }
      History := new Types.IKeyringCallHistory();
      Modifies := {History};
      Modifies := Modifies + cryptoPrimitives.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (res: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures this.keyAgreementScheme.PublicKeyDiscovery? ==> res.Failure?
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> res.Failure?
      decreases Modifies - {History}
    {
      if this.keyAgreementScheme.PublicKeyDiscovery? {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := "PublicKeyDiscovery Key Agreement Scheme is forbidden on encrypt."));
      }
      var operationSenderPrivateKey: PrimitiveTypes.ECCPrivateKey;
      var operationSenderPublicKey: PrimitiveTypes.ECCPublicKey;
      var operationCompressedSenderPublicKey: seq<uint8>;
      if this.keyAgreementScheme.EphemeralPrivateKeyToStaticPublicKey? {
        var ephemeralKeyPair :- GenerateEphemeralEccKeyPair(this.curveSpec, this.cryptoPrimitives);
        operationSenderPrivateKey := ephemeralKeyPair.privateKey;
        operationSenderPublicKey := ephemeralKeyPair.publicKey;
        var operationCompressedSenderPublicKey? :- CompressPublicKey(PrimitiveTypes.ECCPublicKey(der := operationSenderPublicKey.der), this.curveSpec, this.cryptoPrimitives);
        operationCompressedSenderPublicKey := operationCompressedSenderPublicKey?;
      } else {
        operationSenderPrivateKey := this.senderPrivateKey;
        operationSenderPublicKey := this.senderPublicKey;
        operationCompressedSenderPublicKey := this.compressedSenderPublicKey;
      }
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      var sharedSecret :- LocalDeriveSharedSecret(operationSenderPrivateKey, recipientPublicKey, this.curveSpec, this.cryptoPrimitives);
      var curveSpecUtf8 :- UTF8.Encode(CurveSpecTypeToString(this.curveSpec)).MapFailure(E);
      var canonicalizedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext);
      var fixedInfo := EcdhEdkWrapping.SerializeFixedInfo(ECDH_KDF_UTF8, curveSpecUtf8, operationCompressedSenderPublicKey, this.compressedRecipientPublicKey, canonicalizedEC, RAW_ECDH_KEYRING_VERSION);
      var ecdhGenerateAndWrap := new EcdhEdkWrapping.EcdhGenerateAndWrapKeyMaterial(sharedSecret, fixedInfo, cryptoPrimitives);
      var ecdhWrap := new EcdhEdkWrapping.EcdhWrapKeyMaterial(sharedSecret, fixedInfo, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<EcdhEdkWrapping.EcdhWrapInfo>(encryptionMaterials := materials, wrap := ecdhWrap, generateAndWrap := ecdhGenerateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      :- Need(ValidCompressedPublicKeyLength(operationCompressedSenderPublicKey) && ValidCompressedPublicKeyLength(this.compressedRecipientPublicKey), E("Invalid compressed public key length."));
      var edk := Types.EncryptedDataKey(keyProviderId := RAW_ECDH_PROVIDER_ID, keyProviderInfo := SerializeProviderInfo(operationCompressedSenderPublicKey, this.compressedRecipientPublicKey), ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures res.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, res.value.materials)
      ensures this.keyAgreementScheme.EphemeralPrivateKeyToStaticPublicKey? ==> res.Failure?
      decreases Modifies - {History}
    {
      if this.keyAgreementScheme.EphemeralPrivateKeyToStaticPublicKey? {
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := "EphemeralPrivateKeyToStaticPublicKey Key Agreement Scheme is forbidden on decrypt."));
      }
      var materials := input.materials;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), E("Keyring received decryption materials that already contain a plaintext data key."));
      var operationCompressedSenderPublicKey := if this.compressedSenderPublicKey == [] then Option.None() else Some(this.compressedSenderPublicKey);
      var filter := new OnDecryptEcdhDataKeyFilter(keyAgreementScheme, this.compressedRecipientPublicKey, operationCompressedSenderPublicKey);
      var edksToAttempt :- FilterWithResult(filter, input.encryptedDataKeys);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(E(errorMessage));
      }
      var decryptClosure := new DecryptSingleEncryptedDataKey(materials, cryptoPrimitives, this.compressedSenderPublicKey, this.compressedRecipientPublicKey, keyAgreementScheme, curveSpec);
      var outcome, attempts := ReduceToSuccess(decryptClosure, edksToAttempt);
      var SealedDecryptionMaterials :- outcome.MapFailure((errors: seq<Types.Error>) => Types.CollectionOfErrors(list := errors, message := "No Configured Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`."));
      assert decryptClosure.Ensures(Last(attempts).input, Success(SealedDecryptionMaterials), DropLast(attempts));
      return Success(Types.OnDecryptOutput(materials := SealedDecryptionMaterials));
    }
  }

  class OnDecryptEcdhDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const keyAgreementScheme: Types.RawEcdhStaticConfigurations
    const compressedRecipientPublicKey: seq<uint8>
    const compressedSenderPublicKey: seq<uint8>

    constructor (keyAgreementScheme: Types.RawEcdhStaticConfigurations, compressedRecipientPublicKey: seq<uint8>, compressedSenderPublicKey: Option<seq<uint8>>)
      decreases keyAgreementScheme, compressedRecipientPublicKey, compressedSenderPublicKey
    {
      this.keyAgreementScheme := keyAgreementScheme;
      this.compressedRecipientPublicKey := compressedRecipientPublicKey;
      if compressedSenderPublicKey.Some? {
        this.compressedSenderPublicKey := compressedSenderPublicKey.value;
      } else {
        this.compressedSenderPublicKey := [];
      }
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      true &&
      (res.Success? &&
      res.value ==>
        (edk.keyProviderId == KMS_ECDH_PROVIDER_ID || edk.keyProviderId == RAW_ECDH_PROVIDER_ID) &&
        UTF8.ValidUTF8Seq(edk.keyProviderId))
    }

    method {:vcs_split_on_every_assert} Invoke(edk: Types.EncryptedDataKey) returns (res: Result<bool, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      var providerInfo := edk.keyProviderInfo;
      var providerId := edk.keyProviderId;
      if providerId != RAW_ECDH_PROVIDER_ID && providerId != KMS_ECDH_PROVIDER_ID {
        return Success(false);
      }
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 <= ECDH_PROVIDER_INFO_521_LEN as uint64 && ValidProviderInfoLength(providerInfo), E("EDK ProviderInfo longer than expected"));
      var keyringVersion := providerInfo[0 as uint32];
      :- Need([keyringVersion] == RAW_ECDH_KEYRING_VERSION, E("Incorrect Keyring version found in provider info."));
      var recipientPublicKeyLength := SeqToUInt32(providerInfo[ECDH_PROVIDER_INFO_RPL_INDEX .. ECDH_PROVIDER_INFO_RPK_INDEX]);
      var recipientPublicKeyLengthIndex := ECDH_PROVIDER_INFO_RPK_INDEX as uint64 + recipientPublicKeyLength as uint64;
      var senderPublicKeyIndex := recipientPublicKeyLengthIndex + ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN;
      :- Need(recipientPublicKeyLengthIndex + 4 < |providerInfo| as uint64, E("Key Provider Info Serialization Error. Serialized length less than expected."));
      var providerInfoRecipientPublicKey := providerInfo[ECDH_PROVIDER_INFO_RPK_INDEX .. recipientPublicKeyLengthIndex];
      var providerInfoSenderPublicKey := providerInfo[senderPublicKeyIndex..];
      if this.keyAgreementScheme.PublicKeyDiscovery? {
        return Success(this.compressedRecipientPublicKey == providerInfoRecipientPublicKey);
      } else {
        return Success((this.compressedSenderPublicKey == providerInfoSenderPublicKey && this.compressedRecipientPublicKey == providerInfoRecipientPublicKey) || (this.compressedSenderPublicKey == providerInfoRecipientPublicKey && this.compressedRecipientPublicKey == providerInfoSenderPublicKey));
      }
    }
  }

  class DecryptSingleEncryptedDataKey extends ActionWithResult<Types.EncryptedDataKey, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient
    const senderPublicKey: seq<uint8>
    const recipientPublicKey: seq<uint8>
    const keyAgreementScheme: Types.RawEcdhStaticConfigurations
    const curveSpec: PrimitiveTypes.ECDHCurveSpec

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient, senderPublicKey: seq<uint8>, recipientPublicKey: seq<uint8>, keyAgreementScheme: Types.RawEcdhStaticConfigurations, curveSpec: PrimitiveTypes.ECDHCurveSpec)
      requires cryptoPrimitives.ValidState()
      requires true && (keyAgreementScheme.PublicKeyDiscovery? || keyAgreementScheme.RawPrivateKeyToStaticPublicKey?)
      ensures this.materials == materials && this.cryptoPrimitives == cryptoPrimitives && this.recipientPublicKey == recipientPublicKey && this.senderPublicKey == senderPublicKey && this.keyAgreementScheme == keyAgreementScheme && this.curveSpec == curveSpec
      ensures true && (this.keyAgreementScheme.PublicKeyDiscovery? || this.keyAgreementScheme.RawPrivateKeyToStaticPublicKey?)
      ensures Invariant()
      decreases materials, cryptoPrimitives, senderPublicKey, recipientPublicKey, keyAgreementScheme, curveSpec
    {
      this.materials := materials;
      this.cryptoPrimitives := cryptoPrimitives;
      this.recipientPublicKey := recipientPublicKey;
      this.senderPublicKey := senderPublicKey;
      this.keyAgreementScheme := keyAgreementScheme;
      this.curveSpec := curveSpec;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      cryptoPrimitives.Modifies == Modifies
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        Materials.DecryptionMaterialsTransitionIsValid(materials, res.value)
    }

    predicate Requires(edk: Types.EncryptedDataKey)
      decreases edk
    {
      true &&
      UTF8.ValidUTF8Seq(edk.keyProviderId)
    }

    method {:vcs_split_on_every_assert} Invoke(edk: Types.EncryptedDataKey, ghost attemptsState: seq<ActionInvoke<Types.EncryptedDataKey, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(edk, res, attemptsState)
      decreases Modifies
    {
      assert UTF8.ValidUTF8Seq(edk.keyProviderId);
      var suite := materials.algorithmSuite;
      var keyProviderId := edk.keyProviderId;
      var providerInfo := edk.keyProviderInfo;
      var ciphertext := edk.ciphertext;
      var providerWrappedMaterial :- EdkWrapping.GetProviderWrappedMaterial(ciphertext, suite);
      SequenceIsSafeBecauseItIsInMemory(providerInfo);
      :- Need(|providerInfo| as uint64 <= ECDH_PROVIDER_INFO_521_LEN as uint64 && ValidProviderInfoLength(providerInfo), E("EDK ProviderInfo longer than expected"));
      var keyringVersion := providerInfo[0 as uint32];
      :- Need([keyringVersion] == RAW_ECDH_KEYRING_VERSION, E("Incorrect Keyring version found in provider info."));
      var recipientPublicKeyLength := SeqToUInt32(providerInfo[ECDH_PROVIDER_INFO_RPL_INDEX .. ECDH_PROVIDER_INFO_RPK_INDEX]);
      var recipientPublicKeyLengthIndex := ECDH_PROVIDER_INFO_RPK_INDEX as uint64 + recipientPublicKeyLength as uint64;
      var senderPublicKeyIndex := recipientPublicKeyLengthIndex + ECDH_PROVIDER_INFO_PUBLIC_KEY_LEN;
      :- Need(recipientPublicKeyLengthIndex + 4 < |providerInfo| as uint64, E("Key Provider Info Serialization Error. Serialized length less than expected."));
      var providerInfoRecipientPublicKey := providerInfo[ECDH_PROVIDER_INFO_RPK_INDEX .. recipientPublicKeyLengthIndex];
      var providerInfoSenderPublicKey := providerInfo[senderPublicKeyIndex..];
      var senderPublicKey :- DecompressPublicKey(providerInfoSenderPublicKey, this.curveSpec, this.cryptoPrimitives);
      var recipientPublicKey :- DecompressPublicKey(providerInfoRecipientPublicKey, this.curveSpec, this.cryptoPrimitives);
      var _ /* _v0 */ :- ValidatePublicKey(this.cryptoPrimitives, this.curveSpec, senderPublicKey);
      var _ /* _v1 */ :- ValidatePublicKey(this.cryptoPrimitives, this.curveSpec, recipientPublicKey);
      var sharedSecretPublicKey: seq<uint8>;
      var sharedSecretPrivateKey: seq<uint8>;
      match this.keyAgreementScheme {
        case {:split false} PublicKeyDiscovery(publicKeyDiscovery) =>
          {
            sharedSecretPublicKey := senderPublicKey;
            sharedSecretPrivateKey := publicKeyDiscovery.recipientStaticPrivateKey;
          }
        case {:split false} RawPrivateKeyToStaticPublicKey(rawPrivateKeyToStaticPublicKey) =>
          {
            sharedSecretPrivateKey := rawPrivateKeyToStaticPublicKey.senderStaticPrivateKey;
            if rawPrivateKeyToStaticPublicKey.recipientPublicKey == recipientPublicKey {
              sharedSecretPublicKey := recipientPublicKey;
            } else {
              sharedSecretPublicKey := senderPublicKey;
            }
          }
        case {:split false} EphemeralPrivateKeyToStaticPublicKey(_ /* _v2 */) =>
          {
            return Failure(E("EphemeralPrivateKeyToStaticPublicKey Not allowed on decrypt"));
          }
      }
      var _ /* _v3 */ :- ValidatePublicKey(this.cryptoPrimitives, this.curveSpec, sharedSecretPublicKey);
      var sharedSecret :- LocalDeriveSharedSecret(PrimitiveTypes.ECCPrivateKey(pem := sharedSecretPrivateKey), PrimitiveTypes.ECCPublicKey(der := sharedSecretPublicKey), this.curveSpec, this.cryptoPrimitives);
      var ecdhUnwrap := new EcdhEdkWrapping.EcdhUnwrap(providerInfoSenderPublicKey, providerInfoRecipientPublicKey, sharedSecret, RAW_ECDH_KEYRING_VERSION, curveSpec, cryptoPrimitives);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, ecdhUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }
}

module {:options "/functionSyntax:4"} EcdhEdkWrapping {
  method {:vcs_split_on_every_assert} DeriveSharedKeyingMaterial(sharedSecret: seq<uint8>, fixedInfo: seq<uint8>, salt: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      returns (res: Result<seq<uint8>, Types.Error>)
    requires crypto.ValidState()
    modifies crypto.Modifies
    ensures crypto.ValidState()
    ensures |crypto.History.KdfCounterMode| > 0
    ensures Last(crypto.History.KdfCounterMode).input == PrimitiveTypes.KdfCtrInput(digestAlgorithm := PrimitiveTypes.DigestAlgorithm.SHA_384, ikm := sharedSecret, expectedLength := KDF_EXPECTED_LEN, purpose := Some(fixedInfo), nonce := Some(salt))
    ensures res.Success? ==> Last(crypto.History.KdfCounterMode).output.Success? && |Last(crypto.History.KdfCounterMode).output.value| == KDF_EXPECTED_LEN as int && |res.value| == |Last(crypto.History.KdfCounterMode).output.value|
    decreases sharedSecret, fixedInfo, salt, crypto
  {
    var maybeDerivedKeyingMaterial := crypto.KdfCounterMode(PrimitiveTypes.KdfCtrInput(digestAlgorithm := PrimitiveTypes.DigestAlgorithm.SHA_384, ikm := sharedSecret, expectedLength := KDF_EXPECTED_LEN, purpose := Some(fixedInfo), nonce := Some(salt)));
    var derivedKeyingMaterial :- maybeDerivedKeyingMaterial.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
    res := Success(derivedKeyingMaterial);
  }

  function method SerializeFixedInfo(ecdhKeyDerivationUtf8: UTF8.ValidUTF8Bytes, curveSpecUtf8: UTF8.ValidUTF8Bytes, senderPublicKey: seq<uint8>, recipientPublicKey: seq<uint8>, canonicalizedEC: seq<uint8>, keyringVersion: seq<uint8>): (res: seq<uint8>)
    ensures res == ecdhKeyDerivationUtf8 + ECDH_KDF_DELIMITER + curveSpecUtf8 + ECDH_KDF_DELIMITER + ECDH_KDF_PRF_NAME + ECDH_KDF_DELIMITER + senderPublicKey + recipientPublicKey + ECDH_KDF_DELIMITER + keyringVersion + ECDH_KDF_DELIMITER + canonicalizedEC
    decreases ecdhKeyDerivationUtf8, curveSpecUtf8, senderPublicKey, recipientPublicKey, canonicalizedEC, keyringVersion
  {
    ecdhKeyDerivationUtf8 + ECDH_KDF_DELIMITER + curveSpecUtf8 + ECDH_KDF_DELIMITER + ECDH_KDF_PRF_NAME + ECDH_KDF_DELIMITER + senderPublicKey + recipientPublicKey + ECDH_KDF_DELIMITER + keyringVersion + ECDH_KDF_DELIMITER + canonicalizedEC
  }

  function method CurveSpecTypeToString(c: PrimitiveTypes.ECDHCurveSpec): string
    decreases c
  {
    match c {
      case ECC_NIST_P256() =>
        "p256"
      case ECC_NIST_P384() =>
        "p384"
      case ECC_NIST_P521() =>
        "p521"
      case SM2() =>
        "sm2"
    }
  }

  function method E(s: string): Types.Error
    decreases s
  {
    Types.AwsCryptographicMaterialProvidersException(message := s)
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import opened Wrappers

  import opened MaterialWrapping

  import opened IntermediateKeyWrapping

  import opened Constants

  import opened Seq

  import opened AlgorithmSuites

  import PrimitiveTypes = AwsCryptographyPrimitivesTypes

  import Types = AwsCryptographyMaterialProvidersTypes

  import AtomicPrimitives

  import Materials

  datatype EcdhUnwrapInfo = EcdhUnwrapInfo

  datatype EcdhWrapInfo = EcdhWrapInfo

  class EcdhUnwrap extends MaterialWrapping.UnwrapMaterial<EcdhUnwrapInfo> {
    const senderPublicKey: seq<uint8>
    const recipientPublicKey: seq<uint8>
    const sharedSecret: seq<uint8>
    const keyringVersion: seq<uint8>
    const curveSpec: PrimitiveTypes.ECDHCurveSpec
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (senderPublicKey: seq<uint8>, recipientPublicKey: seq<uint8>, sharedSecret: seq<uint8>, keyringVersion: seq<uint8>, curveSpec: PrimitiveTypes.ECDHCurveSpec, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.senderPublicKey == senderPublicKey && this.recipientPublicKey == recipientPublicKey && this.sharedSecret == sharedSecret && this.keyringVersion == keyringVersion && this.curveSpec == curveSpec && this.crypto == crypto
      ensures Invariant()
      decreases senderPublicKey, recipientPublicKey, sharedSecret, keyringVersion, curveSpec, crypto
    {
      this.senderPublicKey := senderPublicKey;
      this.recipientPublicKey := recipientPublicKey;
      this.sharedSecret := sharedSecret;
      this.keyringVersion := keyringVersion;
      this.curveSpec := curveSpec;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<EcdhUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<EcdhUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method {:vcs_split_on_every_assert} Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<EcdhUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<EcdhUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Failure? ==> res.Failure?
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var wrappedMaterial := input.wrappedMaterial;
      var aad := input.encryptionContext;
      SequenceIsSafeBecauseItIsInMemory(wrappedMaterial);
      :- Need(|wrappedMaterial| as uint64 > CIPHERTEXT_WRAPPED_MATERIAL_INDEX, E("Received ciphertext is shorter than expected."));
      var KeyLength := AlgorithmSuites.GetEncryptKeyLength(suite);
      :- Need(|wrappedMaterial| > ECDH_WRAPPED_KEY_MATERIAL_INDEX as nat + KeyLength as nat, Types.AwsCryptographicMaterialProvidersException(message := "Received EDK Ciphertext of incorrect length3."));
      var kdfNonce := wrappedMaterial[..ECDH_COMMITMENT_KEY_INDEX];
      var iv := seq(ECDH_AES_256_ENC_ALG.ivLength as nat, (_ /* _v0 */: int) => 0);
      var commitmentKey := wrappedMaterial[ECDH_COMMITMENT_KEY_INDEX .. ECDH_WRAPPED_KEY_MATERIAL_INDEX];
      var wrappedKey := wrappedMaterial[ECDH_WRAPPED_KEY_MATERIAL_INDEX .. ECDH_WRAPPED_KEY_MATERIAL_INDEX + KeyLength as uint64];
      var authTag := wrappedMaterial[ECDH_WRAPPED_KEY_MATERIAL_INDEX + KeyLength as uint64..];
      var curveSpecUtf8 :- UTF8.Encode(CurveSpecTypeToString(this.curveSpec)).MapFailure(E);
      var canonicalizedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var fixedInfo := SerializeFixedInfo(ECDH_KDF_UTF8, curveSpecUtf8, senderPublicKey, recipientPublicKey, canonicalizedEC, keyringVersion);
      var derivedKeyingMaterial :- DeriveSharedKeyingMaterial(this.sharedSecret, fixedInfo, kdfNonce, crypto);
      var calculatedCommitmentKey: seq<uint8> := derivedKeyingMaterial[..32 as uint32];
      var sharedKeyingMaterial: seq<uint8> := derivedKeyingMaterial[32 as uint32..];
      :- Need(|calculatedCommitmentKey| as uint64 == |commitmentKey| as uint64, E("Calculated commitment key length does NOT match expected commitment key length"));
      var check?, _ /* _v1 */ := commitmentKeyCheck(calculatedCommitmentKey, commitmentKey);
      :- Need(check?, E("Commitment keys do not match"));
      var maybeUnwrappedPdk := crypto.AESDecrypt(PrimitiveTypes.AESDecryptInput(encAlg := ECDH_AES_256_ENC_ALG, key := sharedKeyingMaterial, cipherTxt := wrappedKey, authTag := authTag, iv := iv, aad := fixedInfo));
      var unwrappedPdk :- maybeUnwrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      SequenceIsSafeBecauseItIsInMemory(unwrappedPdk);
      :- Need(|unwrappedPdk| as uint64 == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as uint64, E("Invalid Key Length"));
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := unwrappedPdk, unwrapInfo := EcdhUnwrapInfo());
      return Success(output);
    }

    method commitmentKeyCheck(calculatedCommitmentKey: seq<uint8>, serializedCommitmentKey: seq<uint8>)
        returns (res: bool, ghost collectedCommitmentKey: seq<bv8>)
      requires |calculatedCommitmentKey| == |serializedCommitmentKey|
      ensures |collectedCommitmentKey| == |serializedCommitmentKey|
      ensures forall j: int {:trigger serializedCommitmentKey[j]} {:trigger calculatedCommitmentKey[j]} {:trigger collectedCommitmentKey[j]} | 0 <= j < |collectedCommitmentKey| :: collectedCommitmentKey[j] == calculatedCommitmentKey[j] as bv8 ^ serializedCommitmentKey[j] as bv8
      decreases calculatedCommitmentKey, serializedCommitmentKey
    {
      collectedCommitmentKey := [];
      var diff? := 0;
      SequenceIsSafeBecauseItIsInMemory(serializedCommitmentKey);
      for i: uint64 := 0 to |serializedCommitmentKey| as uint64
        invariant |collectedCommitmentKey| == i as nat
        invariant forall j: BoundedInts.uint64 {:trigger serializedCommitmentKey[j]} {:trigger calculatedCommitmentKey[j]} {:trigger collectedCommitmentKey[j]} | 0 <= j < i :: collectedCommitmentKey[j] == calculatedCommitmentKey[j] as bv8 ^ serializedCommitmentKey[j] as bv8
      {
        diff? := diff? | (calculatedCommitmentKey[i] as bv8 ^ serializedCommitmentKey[i] as bv8);
        collectedCommitmentKey := collectedCommitmentKey + [calculatedCommitmentKey[i] as bv8 ^ serializedCommitmentKey[i] as bv8];
      }
      res := diff? == 0;
    }
  }

  class EcdhGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<EcdhWrapInfo> {
    const sharedSecret: seq<uint8>
    const fixedInfo: seq<uint8>
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (sharedSecret: seq<uint8>, fixedInfo: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.sharedSecret == sharedSecret && this.fixedInfo == fixedInfo && this.crypto == crypto
      ensures Invariant()
      decreases sharedSecret, fixedInfo, crypto
    {
      this.sharedSecret := sharedSecret;
      this.fixedInfo := fixedInfo;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<EcdhWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<EcdhWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method {:vcs_split_on_every_assert} Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<EcdhWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<EcdhWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == input.algorithmSuite.encrypt.AES_GCM.keyLength as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var pdkResult := crypto.GenerateRandomBytes(PrimitiveTypes.GenerateRandomBytesInput(length := GetEncryptKeyLength(suite)));
      var pdk :- pdkResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new EcdhWrapKeyMaterial(sharedSecret, fixedInfo, crypto);
      var wrapOutput: MaterialWrapping.WrapOutput<EcdhWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := pdk, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := pdk, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := wrapOutput.wrapInfo);
      return Success(output);
    }
  }

  class EcdhWrapKeyMaterial extends MaterialWrapping.WrapMaterial<EcdhWrapInfo> {
    const sharedSecret: seq<uint8>
    const fixedInfo: seq<uint8>
    const crypto: AtomicPrimitives.AtomicPrimitivesClient

    constructor (sharedSecret: seq<uint8>, fixedInfo: seq<uint8>, crypto: AtomicPrimitives.AtomicPrimitivesClient)
      requires crypto.ValidState()
      ensures this.sharedSecret == sharedSecret && this.fixedInfo == fixedInfo && this.crypto == crypto
      ensures Invariant()
      decreases sharedSecret, fixedInfo, crypto
    {
      this.sharedSecret := sharedSecret;
      this.fixedInfo := fixedInfo;
      this.crypto := crypto;
      Modifies := crypto.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      crypto.ValidState() &&
      crypto.Modifies == Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<EcdhWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<EcdhWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        0 < |crypto.History.AESEncrypt| &&
        Seq.Last(crypto.History.AESEncrypt).output.Success? &&
        ghost var AESEncryptInput: AESEncryptInput := Seq.Last(crypto.History.AESEncrypt).input; true && ghost var AESEncryptOutput: AESEncryptOutput := Seq.Last(crypto.History.AESEncrypt).output.value; true && ghost var iv: seq<BoundedInts.uint8> := seq(ECDH_AES_256_ENC_ALG.ivLength as nat, (_ /* _v2 */: int) => 0); AESEncryptInput.encAlg == ECDH_AES_256_ENC_ALG && AESEncryptInput.msg == input.plaintextMaterial && AESEncryptInput.iv == iv && AESEncryptInput.aad == fixedInfo && |res.value.wrappedMaterial| > |AESEncryptOutput.cipherText| + |AESEncryptOutput.authTag|
    }

    method {:vcs_split_on_every_assert} Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<EcdhWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<EcdhWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var canonicalizedEC :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var maybeSalt := crypto.GenerateRandomBytes(PrimitiveTypes.GenerateRandomBytesInput(length := KDF_SALT_LEN));
      var salt :- maybeSalt.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var derivedKeyingMaterial :- DeriveSharedKeyingMaterial(sharedSecret, fixedInfo, salt, crypto);
      var commitmentKey: seq<uint8> := derivedKeyingMaterial[..32 as uint32];
      var sharedKeyingMaterial: seq<uint8> := derivedKeyingMaterial[32 as uint32..];
      var iv := seq(ECDH_AES_256_ENC_ALG.ivLength as nat, (_ /* _v3 */: int) => 0);
      var maybeWrappedPdk := crypto.AESEncrypt(PrimitiveTypes.AESEncryptInput(encAlg := ECDH_AES_256_ENC_ALG, iv := iv, key := sharedKeyingMaterial, msg := input.plaintextMaterial, aad := fixedInfo));
      var wrappedPdk :- maybeWrappedPdk.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := salt + commitmentKey + wrappedPdk.cipherText + wrappedPdk.authTag, wrapInfo := EcdhWrapInfo());
      return Success(output);
    }
  }
}

module AwsKmsDiscoveryKeyring {
  function method DiscoveryMatch(arn: AwsKmsArn, discoveryFilter: Option<Types.DiscoveryFilter>): (res: bool)
    ensures discoveryFilter.Some? && res ==> discoveryFilter.value.partition == arn.partition && discoveryFilter.value.accountIds <= [arn.account]
    decreases arn, discoveryFilter
  {
    true &&
    match discoveryFilter { case Some(filter) => filter.partition == arn.partition && filter.accountIds <= [arn.account] case None() => true }
  }

  lemma /*{:_inductionTrigger |parts|}*/ /*{:_inductionTrigger _default.Flatten(parts)}*/ /*{:_induction parts}*/ LemmaFlattenMembership<T>(parts: seq<seq<T>>, flat: seq<T>)
    requires Seq.Flatten(parts) == flat
    ensures forall index: int {:trigger parts[index]} | 0 <= index < |parts| :: multiset(parts[index]) <= multiset(flat)
    ensures multiset(Seq.Flatten(parts)) == multiset(flat)
    ensures forall part: seq<T> {:trigger part in parts} | part in parts :: forall i: T {:trigger i in flat} {:trigger i in part} | i in part :: i in flat
    ensures forall i: T {:trigger i in flat} | i in flat :: exists part: seq<T> {:trigger i in part} {:trigger part in parts} | part in parts :: i in part
    decreases parts, flat
  {
    if |parts| == 0 {
    } else {
      assert multiset(Seq.First(parts)) <= multiset(flat);
      assert parts == [Seq.First(parts)] + parts[1..];
      assert flat == Seq.First(parts) + Seq.Flatten(parts[1..]);
      LemmaFlattenMembership(parts[1..], Seq.Flatten(parts[1..]));
    }
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened Actions

  import opened Constants

  import AlgorithmSuites

  import Keyring

  import Materials

  import opened AwsArnParsing

  import UTF8

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = ComAmazonawsKmsTypes

  import opened AwsKmsUtils

  import opened AwsKmsKeyring

  import EdkWrapping

  import MaterialWrapping

  import ErrorMessages

  class AwsKmsDiscoveryKeyring extends Keyring.VerifiableInterface {
    const client: KMS.IKMSClient
    const discoveryFilter: Option<Types.DiscoveryFilter>
    const grantTokens: KMS.GrantTokenList

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      client.ValidState() &&
      client.Modifies <= Modifies &&
      History !in client.Modifies
    }

    constructor (client: KMS.IKMSClient, discoveryFilter: Option<Types.DiscoveryFilter>, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.client == client && this.discoveryFilter == discoveryFilter && this.grantTokens == grantTokens
      ensures ValidState() && fresh(this) && fresh(History) && fresh(Modifies - client.Modifies)
      decreases client, discoveryFilter, grantTokens
    {
      this.client := client;
      this.discoveryFilter := discoveryFilter;
      this.grantTokens := grantTokens;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + client.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Failure?
      decreases Modifies - {History}
    {
      return Failure(Types.AwsCryptographicMaterialProvidersException(message := "Encryption is not supported with a Discovery Keyring."));
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (res: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, res)
      ensures unchanged(History)
      ensures input.materials.plaintextDataKey.Some? ==> true && res.Failure?
      ensures StringifyEncryptionContext(input.materials.encryptionContext).Failure? ==> res.Failure?
      ensures res.Success? ==> true && var stringifiedEncCtx: KMS.EncryptionContextType := StringifyEncryptionContext(input.materials.encryptionContext).Extract(); 0 < |client.History.Decrypt| && AlgorithmSuites.GetEncryptKeyLength(input.materials.algorithmSuite) as nat == |res.value.materials.plaintextDataKey.value| && var LastDecrypt: DafnyCallEvent<DecryptRequest, Result<DecryptResponse, Error>> := Seq.Last(client.History.Decrypt); LastDecrypt.output.Success? && exists edk: Types.EncryptedDataKey, awsKmsKey: string {:trigger Option<string>.Some(awsKmsKey), edk.keyProviderId} {:trigger Option<string>.Some(awsKmsKey), edk.ciphertext} {:trigger Option<string>.Some(awsKmsKey), edk in input.encryptedDataKeys} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.keyProviderId} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk.ciphertext} {:trigger _default.IsValid_KeyIdType(awsKmsKey), edk in input.encryptedDataKeys} | true && edk in input.encryptedDataKeys :: true && var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(edk.ciphertext, res.value.materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && edk.keyProviderId == PROVIDER_ID && KMS.IsValid_KeyIdType(awsKmsKey) && var request: DecryptRequest := KMS.DecryptRequest(KeyId := Option.Some(awsKmsKey), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Option.Some(stringifiedEncCtx), GrantTokens := Option.Some(grantTokens), EncryptionAlgorithm := Option.None()); Seq.Last(client.History.Decrypt).input == request && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (input.materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.materials.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(awsKmsKey)
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var encryptedDataKeys := input.encryptedDataKeys;
      var suite := input.materials.algorithmSuite;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      var edkFilter: AwsKmsEncryptedDataKeyFilter := new AwsKmsEncryptedDataKeyFilter(discoveryFilter);
      var matchingEdks :- Actions.FilterWithResult(edkFilter, encryptedDataKeys);
      var edkTransform: AwsKmsEncryptedDataKeyTransformer := new AwsKmsEncryptedDataKeyTransformer();
      var edksToAttempt, parts :- Actions.DeterministicFlatMapWithResult(edkTransform, matchingEdks);
      SequenceIsSafeBecauseItIsInMemory(edksToAttempt);
      if 0 == |edksToAttempt| as uint64 {
        var errorMessage :- ErrorMessages.IncorrectDataKeys(input.encryptedDataKeys, input.materials.algorithmSuite);
        return Failure(Types.AwsCryptographicMaterialProvidersException(message := errorMessage));
      }
      forall helper: AwsKmsEdkHelper | helper in edksToAttempt
        ensures helper.edk in encryptedDataKeys
      {
        LemmaFlattenMembership(parts, edksToAttempt);
        assert helper.edk in encryptedDataKeys;
      }
      var decryptAction: AwsKmsEncryptedDataKeyDecryptor := new AwsKmsEncryptedDataKeyDecryptor(materials, client, grantTokens);
      var outcome, attempts := Actions.ReduceToSuccess(decryptAction, edksToAttempt);
      return match outcome { case Success(mat) => (assert exists helper: AwsKmsEdkHelper {:trigger decryptAction.Ensures(helper, Success(mat), attempts)} {:trigger helper.edk} {:trigger helper in edksToAttempt} | helper in edksToAttempt :: helper.edk in encryptedDataKeys && decryptAction.Ensures(helper, Success(mat), attempts); Success(Types.OnDecryptOutput(materials := mat))) case Failure(errors) => Failure(Types.CollectionOfErrors(list := errors, message := "No Configured KMS Key was able to decrypt the Data Key. The list of encountered Exceptions is available via `list`.")) };
    }
  }

  class AwsKmsEncryptedDataKeyFilter extends DeterministicActionWithResult<Types.EncryptedDataKey, bool, Types.Error> {
    const discoveryFilter: Option<Types.DiscoveryFilter>

    constructor (discoveryFilter: Option<Types.DiscoveryFilter>)
      ensures true && this.discoveryFilter == discoveryFilter
      decreases discoveryFilter
    {
      this.discoveryFilter := discoveryFilter;
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<bool, Types.Error>)
      decreases edk, res
    {
      res.Success? &&
      res.value ==>
        UTF8.ValidUTF8Seq(edk.keyProviderInfo) &&
        ghost var keyId: Result<string, string> := UTF8.Decode(edk.keyProviderInfo); keyId.Success? && ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(keyId.value); arn.Success? && edk.keyProviderId == PROVIDER_ID && arn.value.resource.resourceType == "key" && DiscoveryMatch(arn.value, discoveryFilter)
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (output: Result<bool, Types.Error>)
      ensures Ensures(edk, output)
      decreases edk
    {
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := "Invalid AWS KMS encoding, provider info is not UTF8."));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      :- Need(arn.resource.resourceType == "key", Types.AwsCryptographicMaterialProvidersException(message := "Only AWS KMS Keys supported"));
      if edk.keyProviderId != PROVIDER_ID {
        return Success(false);
      }
      if !DiscoveryMatch(arn, discoveryFilter) {
        return Success(false);
      }
      return Success(true);
    }
  }

  class AwsKmsEncryptedDataKeyTransformer extends DeterministicActionWithResult<Types.EncryptedDataKey, seq<AwsKmsEdkHelper>, Types.Error> {
    constructor ()
    {
    }

    predicate Ensures(edk: Types.EncryptedDataKey, res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      decreases edk, res
    {
      true &&
      res.Success? ==>
        |res.value| == 1 &&
        ghost var matchingEdk: AwsKmsEdkHelper := res.value[0]; UTF8.ValidUTF8Seq(edk.keyProviderInfo) && ghost var keyId: Result<string, string> := UTF8.Decode(edk.keyProviderInfo); keyId.Success? && ghost var arn: Result<AwsKmsArn, string> := ParseAwsKmsArn(keyId.value); arn.Success? && arn.value == matchingEdk.arn && matchingEdk.edk == edk
    }

    method Invoke(edk: Types.EncryptedDataKey) returns (res: Result<seq<AwsKmsEdkHelper>, Types.Error>)
      ensures Ensures(edk, res)
      decreases edk
    {
      :- Need(edk.keyProviderId == PROVIDER_ID, Types.AwsCryptographicMaterialProvidersException(message := "Encrypted data key was not generated by KMS"));
      :- Need(UTF8.ValidUTF8Seq(edk.keyProviderInfo), Types.AwsCryptographicMaterialProvidersException(message := "Invalid AWS KMS encoding, provider info is not UTF8."));
      var keyId :- UTF8.Decode(edk.keyProviderInfo).MapFailure(WrapStringToError);
      var arn :- ParseAwsKmsArn(keyId).MapFailure(WrapStringToError);
      return Success([AwsKmsEdkHelper(edk, arn)]);
    }
  }

  class AwsKmsEncryptedDataKeyDecryptor extends ActionWithResult<AwsKmsEdkHelper, Materials.SealedDecryptionMaterials, Types.Error> {
    const materials: Materials.DecryptionMaterialsPendingPlaintextDataKey
    const client: KMS.IKMSClient
    const grantTokens: KMS.GrantTokenList

    constructor (materials: Materials.DecryptionMaterialsPendingPlaintextDataKey, client: KMS.IKMSClient, grantTokens: KMS.GrantTokenList)
      requires client.ValidState()
      ensures this.materials == materials && this.client == client && this.grantTokens == grantTokens
      ensures Invariant()
      decreases materials, client, grantTokens
    {
      this.materials := materials;
      this.client := client;
      this.grantTokens := grantTokens;
      Modifies := client.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      client.ValidState() &&
      client.Modifies == Modifies
    }

    predicate Ensures(helper: AwsKmsEdkHelper, res: Result<Materials.SealedDecryptionMaterials, Types.Error>, attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      res.Success? ==>
        Invariant() &&
        ghost var keyArn: string := helper.arn.ToString(); true && ghost var maybeProviderWrappedMaterial: Result<seq<uint8>, Types.Error> := EdkWrapping.GetProviderWrappedMaterial(helper.edk.ciphertext, materials.algorithmSuite); maybeProviderWrappedMaterial.Success? && KMS.IsValid_CiphertextType(maybeProviderWrappedMaterial.value) && KMS.IsValid_KeyIdType(keyArn) && ghost var maybeStringifiedEncCtx: Result<KMS.EncryptionContextType, Types.Error> := StringifyEncryptionContext(materials.encryptionContext); maybeStringifiedEncCtx.Success? && Materials.DecryptionMaterialsTransitionIsValid(materials, res.value) && 0 < |client.History.Decrypt| && KMS.DecryptRequest(KeyId := Some(keyArn), CiphertextBlob := maybeProviderWrappedMaterial.value, EncryptionContext := Some(maybeStringifiedEncCtx.value), GrantTokens := Some(grantTokens), EncryptionAlgorithm := None) == Seq.Last(client.History.Decrypt).input && Seq.Last(client.History.Decrypt).output.Success? && Seq.Last(client.History.Decrypt).output.value.Plaintext.Some? && (materials.algorithmSuite.edkWrapping.DIRECT_KEY_WRAPPING? ==> Seq.Last(client.History.Decrypt).output.value.Plaintext == res.value.plaintextDataKey) && Seq.Last(client.History.Decrypt).output.value.KeyId == Some(keyArn)
    }

    predicate Requires(helper: AwsKmsEdkHelper)
      decreases helper
    {
      true
    }

    method Invoke(helper: AwsKmsEdkHelper, ghost attemptsState: seq<ActionInvoke<AwsKmsEdkHelper, Result<Materials.SealedDecryptionMaterials, Types.Error>>>) returns (res: Result<Materials.SealedDecryptionMaterials, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(helper, res, attemptsState)
      decreases Modifies
    {
      var awsKmsKey := helper.arn.ToString();
      var _ /* _v0 */ :- ValidateKmsKeyId(helper.arn.ToString());
      var kmsUnwrap := new KmsUnwrapKeyMaterial(client, awsKmsKey, grantTokens);
      var unwrapOutputRes := EdkWrapping.UnwrapEdkMaterial(helper.edk.ciphertext, materials, kmsUnwrap);
      var unwrapOutput :- unwrapOutputRes;
      var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.plaintextDataKey, unwrapOutput.symmetricSigningKey);
      return Success(result);
    }
  }
}

module RawRSAKeyring {

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened String = StandardLibrary.String

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import AtomicPrimitives

  import Keyring

  import Materials

  import opened AlgorithmSuites

  import Random

  import RSAEncryption

  import UTF8

  import opened Seq

  import MaterialWrapping

  import EdkWrapping

  import ErrorMessages
  class RawRSAKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState() &&
      (privateKeyMaterial.Some? ==>
        privateKeyMaterial.value.Modifies < Modifies - {History}) &&
      (publicKeyMaterial.Some? ==>
        publicKeyMaterial.value.Modifies < Modifies - {History}) &&
      (publicKeyMaterial.Some? ==>
        publicKeyMaterial.value.Invariant()) &&
      (privateKeyMaterial.Some? ==>
        privateKeyMaterial.value.Invariant()) &&
      (publicKey.None? ==>
        this.publicKeyMaterial.None?) &&
      (privateKey.None? ==>
        this.privateKeyMaterial.None?)
    }

    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient
    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const publicKey: Option<seq<uint8>>
    const privateKey: Option<seq<uint8>>
    const privateKeyMaterial: Option<RsaUnwrapKeyMaterial>
    const publicKeyMaterial: Option<RsaWrapKeyMaterial>
    const paddingScheme: Crypto.RSAPaddingMode

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, publicKey: Option<seq<uint8>>, privateKey: Option<seq<uint8>>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires |namespace| < UINT16_LIMIT
      requires |name| < UINT16_LIMIT
      requires cryptoPrimitives.ValidState()
      ensures this.keyNamespace == namespace
      ensures this.keyName == name
      ensures this.paddingScheme == paddingScheme
      ensures this.publicKey == publicKey
      ensures this.privateKey == privateKey
      ensures ValidState() && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies)
      decreases namespace, name, publicKey, privateKey, paddingScheme, cryptoPrimitives
    {
      this.keyNamespace := namespace;
      this.keyName := name;
      this.paddingScheme := paddingScheme;
      this.publicKey := publicKey;
      this.privateKey := privateKey;
      this.cryptoPrimitives := cryptoPrimitives;
      var localPrivateKeyMaterial := None;
      if privateKey.Some? {
        var extract := privateKey.Extract();
        SequenceIsSafeBecauseItIsInMemory(extract);
        if |extract| as uint64 > 0 {
          var unwrap := new RsaUnwrapKeyMaterial(extract, paddingScheme, cryptoPrimitives);
          localPrivateKeyMaterial := Some(unwrap);
        }
      }
      var localPublicKeyMaterial := None;
      if publicKey.Some? {
        var extract := publicKey.Extract();
        SequenceIsSafeBecauseItIsInMemory(extract);
        if |extract| as uint64 > 0 {
          var wrap := new RsaWrapKeyMaterial(extract, paddingScheme, cryptoPrimitives);
          localPublicKeyMaterial := Some(wrap);
        }
      }
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + cryptoPrimitives.Modifies + (if localPublicKeyMaterial.Some? then {localPublicKeyMaterial.value} else {}) + if localPrivateKeyMaterial.Some? then {localPrivateKeyMaterial.value} else {};
      this.publicKeyMaterial := localPublicKeyMaterial;
      this.privateKeyMaterial := localPrivateKeyMaterial;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures this.publicKeyMaterial.None? ==> output.Failure?
      ensures input.materials.plaintextDataKey.None? && output.Success? ==> output.value.materials.plaintextDataKey.Some?
      ensures true && output.Success? ==> |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1
      ensures this.publicKeyMaterial.None? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(publicKeyMaterial.Some?, Types.AwsCryptographicMaterialProvidersException(message := "A RawRSAKeyring without a public key cannot provide OnEncrypt"));
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var generateAndWrap := new RsaGenerateAndWrapKeyMaterial(publicKey.value, paddingScheme, cryptoPrimitives);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<RsaWrapInfo>(encryptionMaterials := materials, wrap := publicKeyMaterial.value, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := this.keyNamespace, keyProviderInfo := this.keyName, ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures privateKeyMaterial.None? ==> output.Failure?
      ensures input.materials.plaintextDataKey.Some? ==> output.Failure?
      decreases Modifies - {History}
    {
      :- Need(privateKeyMaterial.Some?, Types.AwsCryptographicMaterialProvidersException(message := "A RawRSAKeyring without a private key cannot provide OnEncrypt"));
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      var errors: seq<Types.Error> := [];
      SequenceIsSafeBecauseItIsInMemory(input.encryptedDataKeys);
      for i: uint64 := 0 to |input.encryptedDataKeys| as uint64
        invariant |errors| == i as nat
      {
        if ShouldDecryptEDK(input.encryptedDataKeys[i]) {
          var edk := input.encryptedDataKeys[i];
          var unwrapOutput := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, privateKeyMaterial.value);
          if unwrapOutput.Success? {
            var returnMaterials :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.value.plaintextDataKey, unwrapOutput.value.symmetricSigningKey);
            return Success(Types.OnDecryptOutput(materials := returnMaterials));
          } else {
            errors := errors + [unwrapOutput.error];
          }
        } else {
          var extractedKeyProviderId :- UTF8.Decode(input.encryptedDataKeys[i].keyProviderId).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
          errors := errors + [Types.AwsCryptographicMaterialProvidersException(message := ErrorMessages.IncorrectRawDataKeys(Base10Int2String(i as nat), "RSAKeyring", extractedKeyProviderId))];
        }
      }
      return Failure(Types.CollectionOfErrors(list := errors, message := "Raw RSA Key was unable to decrypt any encrypted data key. The list of encountered Exceptions is available via `list`."));
    }

    predicate method ShouldDecryptEDK(edk: Types.EncryptedDataKey)
      ensures edk.keyProviderInfo == this.keyName && edk.keyProviderId == this.keyNamespace && |edk.ciphertext| > 0 ==> true
      decreases edk
    {
      SequenceIsSafeBecauseItIsInMemory(edk.ciphertext);
      UTF8.ValidUTF8Seq(edk.keyProviderInfo) &&
      edk.keyProviderInfo == this.keyName &&
      edk.keyProviderId == this.keyNamespace &&
      |edk.ciphertext| as uint64 > 0
    }
  }

  datatype RsaUnwrapInfo = RsaUnwrapInfo

  datatype RsaWrapInfo = RsaWrapInfo

  class RsaGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<RsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.publicKey == publicKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        true &&
        Invariant()
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<RsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var generateBytesResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrap := new RsaWrapKeyMaterial(publicKey, paddingScheme, cryptoPrimitives);
      var wrapOutput: MaterialWrapping.WrapOutput<RsaWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), []);
      var output := MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := RsaWrapInfo());
      return Success(output);
    }
  }

  class RsaWrapKeyMaterial extends MaterialWrapping.WrapMaterial<RsaWrapInfo> {
    const publicKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (publicKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.publicKey == publicKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases publicKey, paddingScheme, cryptoPrimitives
    {
      this.publicKey := publicKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        0 < |cryptoPrimitives.History.RSAEncrypt| &&
        Seq.Last(cryptoPrimitives.History.RSAEncrypt).output.Success? &&
        ghost var RsaEncryptInput: RSAEncryptInput := Seq.Last(cryptoPrimitives.History.RSAEncrypt).input; true && ghost var RsaEncryptOutput: Result<seq<uint8>, Error> := Seq.Last(cryptoPrimitives.History.RSAEncrypt).output; RsaEncryptInput.padding == paddingScheme && RsaEncryptInput.publicKey == publicKey && RsaEncryptInput.plaintext == input.plaintextMaterial && RsaEncryptOutput.value == res.value.wrappedMaterial)
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<RsaWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var RSAEncryptOutput := cryptoPrimitives.RSAEncrypt(Crypto.RSAEncryptInput(padding := paddingScheme, publicKey := publicKey, plaintext := input.plaintextMaterial));
      var ciphertext :- RSAEncryptOutput.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(e));
      var output := MaterialWrapping.WrapOutput(wrappedMaterial := ciphertext, wrapInfo := RsaWrapInfo());
      return Success(output);
    }
  }

  class RsaUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<RsaUnwrapInfo> {
    const privateKey: seq<uint8>
    const paddingScheme: Crypto.RSAPaddingMode
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (privateKey: seq<uint8>, paddingScheme: Crypto.RSAPaddingMode, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.privateKey == privateKey && this.paddingScheme == paddingScheme && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases privateKey, paddingScheme, cryptoPrimitives
    {
      this.privateKey := privateKey;
      this.paddingScheme := paddingScheme;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        |cryptoPrimitives.History.RSADecrypt| > 0 &&
        Last(cryptoPrimitives.History.RSADecrypt).output.Success? &&
        ghost var decryptInput: RSADecryptInput := Last(cryptoPrimitives.History.RSADecrypt).input; true && ghost var decryptOutput: seq<uint8> := Last(cryptoPrimitives.History.RSADecrypt).output.value; decryptInput.padding == paddingScheme && decryptInput.privateKey == privateKey && decryptInput.cipherText == input.wrappedMaterial && decryptOutput == res.value.unwrappedMaterial
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<RsaUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      ensures res.Success? ==> |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
      decreases Modifies
    {
      var suite := input.algorithmSuite;
      var wrappedMaterial := input.wrappedMaterial;
      var aad := input.encryptionContext;
      var maybeDecryptResult := cryptoPrimitives.RSADecrypt(Crypto.RSADecryptInput(padding := paddingScheme, privateKey := privateKey, cipherText := wrappedMaterial));
      var decryptResult :- maybeDecryptResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      SequenceIsSafeBecauseItIsInMemory(decryptResult);
      :- Need(|decryptResult| as uint64 == AlgorithmSuites.GetEncryptKeyLength(suite) as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Invalid plaintext length."));
      assert |cryptoPrimitives.History.RSADecrypt| > 0;
      var output := MaterialWrapping.UnwrapOutput(unwrappedMaterial := decryptResult, unwrapInfo := RsaUnwrapInfo());
      return Success(output);
    }
  }
}

module RawAESKeyring {
  const AUTH_TAG_LEN_LEN := 4 as uint64
  const IV_LEN_LEN := 4 as uint64

  function method DeserializeEDKCiphertext(ciphertext: seq<uint8>, tagLen: uint64): (encOutput: Crypto.AESEncryptOutput)
    requires tagLen as nat <= |ciphertext|
    ensures |encOutput.authTag| == tagLen as nat
    ensures SerializeEDKCiphertext(encOutput) == ciphertext
    decreases ciphertext, tagLen
  {
    SequenceIsSafeBecauseItIsInMemory(ciphertext);
    var encryptedKeyLength: BoundedInts.uint64 := |ciphertext| as uint64 - tagLen;
    Crypto.AESEncryptOutput(cipherText := ciphertext[..encryptedKeyLength], authTag := ciphertext[encryptedKeyLength..])
  }

  function method SerializeEDKCiphertext(encOutput: Crypto.AESEncryptOutput): (ciphertext: seq<uint8>)
    decreases encOutput
  {
    encOutput.cipherText + encOutput.authTag
  }

  lemma EDKSerializeDeserialize(encOutput: Crypto.AESEncryptOutput)
    ensures HasUint64Len(encOutput.authTag) && DeserializeEDKCiphertext(SerializeEDKCiphertext(encOutput), |encOutput.authTag| as uint64) == encOutput
    decreases encOutput
  {
    SequenceIsSafeBecauseItIsInMemory(encOutput.authTag);
  }

  lemma EDKDeserializeSerialize(ciphertext: seq<uint8>, tagLen: nat)
    requires tagLen <= |ciphertext|
    ensures HasUint64Size(tagLen) && SerializeEDKCiphertext(DeserializeEDKCiphertext(ciphertext, tagLen as uint64)) == ciphertext
    decreases ciphertext, tagLen
  {
    SequenceIsSafeBecauseItIsInMemory(ciphertext);
  }

  import opened StandardLibrary

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened String = StandardLibrary.String

  import opened Actions

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Crypto = AwsCryptographyPrimitivesTypes

  import Keyring

  import Materials

  import CanonicalEncryptionContext

  import opened AlgorithmSuites

  import UTF8

  import Seq

  import MaterialWrapping

  import EdkWrapping

  import ErrorMessages

  import AtomicPrimitives

  class RawAESKeyring extends Keyring.VerifiableInterface, Types.IKeyring {
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      SequenceIsSafeBecauseItIsInMemory(wrappingKey);
      History in Modifies &&
      cryptoPrimitives.Modifies <= Modifies &&
      History !in cryptoPrimitives.Modifies &&
      cryptoPrimitives.ValidState() &&
      |wrappingKey| as uint64 == wrappingAlgorithm.keyLength as uint64
    }

    const keyNamespace: UTF8.ValidUTF8Bytes
    const keyName: UTF8.ValidUTF8Bytes
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM

    constructor (namespace: UTF8.ValidUTF8Bytes, name: UTF8.ValidUTF8Bytes, key: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires |namespace| < UINT16_LIMIT
      requires |name| < UINT16_LIMIT
      requires |key| == 16 || |key| == 24 || |key| == 32
      requires |key| == wrappingAlgorithm.keyLength as int
      requires cryptoPrimitives.ValidState()
      ensures keyNamespace == namespace
      ensures keyName == name
      ensures wrappingKey == key
      ensures this.wrappingAlgorithm == wrappingAlgorithm
      ensures this.cryptoPrimitives == cryptoPrimitives
      ensures ValidState() && fresh(History) && fresh(Modifies - cryptoPrimitives.Modifies)
      decreases namespace, name, key, wrappingAlgorithm, cryptoPrimitives
    {
      keyNamespace := namespace;
      keyName := name;
      wrappingKey := key;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      History := new Types.IKeyringCallHistory();
      Modifies := {History} + cryptoPrimitives.Modifies;
    }

    predicate OnEncryptEnsuresPublicly(input: Types.OnEncryptInput, output: Result<Types.OnEncryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) && Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.materials) &&
        Materials.ValidEncryptionMaterialsTransition(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnEncrypt'(input: Types.OnEncryptInput) returns (output: Result<Types.OnEncryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnEncryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Success? && 1 <= |cryptoPrimitives.History.GenerateRandomBytes| && Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.Success?
      ensures output.Success? ==> true && var iv: seq<uint8> := Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.value; |iv| == wrappingAlgorithm.ivLength as nat && 1 <= |cryptoPrimitives.History.AESEncrypt| && var AESEncryptInput: AESEncryptInput := Seq.Last(cryptoPrimitives.History.AESEncrypt).input; AESEncryptInput.encAlg == wrappingAlgorithm && AESEncryptInput.key == wrappingKey && AESEncryptInput.iv == iv && AESEncryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).value && |output.value.materials.encryptedDataKeys| == |input.materials.encryptedDataKeys| + 1 && var edk: EncryptedDataKey := Seq.Last(output.value.materials.encryptedDataKeys); Seq.Last(cryptoPrimitives.History.AESEncrypt).output.Success? && var AESEncryptOutput: AESEncryptOutput := Seq.Last(cryptoPrimitives.History.AESEncrypt).output.value; true && edk.keyProviderInfo == SerializeProviderInfo(iv)
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      var suite := materials.algorithmSuite;
      var wrap := new AesWrapKeyMaterial(wrappingKey, wrappingAlgorithm, cryptoPrimitives);
      var generateAndWrap := new AesGenerateAndWrapKeyMaterial(wrap);
      var wrapOutput :- EdkWrapping.WrapEdkMaterial<AesWrapInfo>(encryptionMaterials := materials, wrap := wrap, generateAndWrap := generateAndWrap);
      var symmetricSigningKeyList := if wrapOutput.symmetricSigningKey.Some? then Some([wrapOutput.symmetricSigningKey.value]) else None;
      var edk: Types.EncryptedDataKey := Types.EncryptedDataKey(keyProviderId := keyNamespace, keyProviderInfo := SerializeProviderInfo(wrapOutput.wrapInfo.iv), ciphertext := wrapOutput.wrappedMaterial);
      if wrapOutput.GenerateAndWrapEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddDataKey(materials, wrapOutput.plaintextDataKey, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      } else if wrapOutput.WrapOnlyEdkMaterialOutput? {
        var result :- Materials.EncryptionMaterialAddEncryptedDataKeys(materials, [edk], symmetricSigningKeyList);
        return Success(Types.OnEncryptOutput(materials := result));
      }
    }

    predicate OnDecryptEnsuresPublicly(input: Types.OnDecryptInput, output: Result<Types.OnDecryptOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      decreases input, output
    {
      output.Success? ==>
        true &&
        Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
    }

    method {:vcs_split_on_every_assert} OnDecrypt'(input: Types.OnDecryptInput) returns (output: Result<Types.OnDecryptOutput, Types.Error>)
      requires ValidState()
      modifies Modifies - {History}
      ensures ValidState()
      ensures OnDecryptEnsuresPublicly(input, output)
      ensures unchanged(History)
      ensures output.Success? ==> true && Materials.DecryptionMaterialsTransitionIsValid(input.materials, output.value.materials)
      ensures true && output.Success? ==> CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Success? && input.materials.plaintextDataKey.None? && output.value.materials.plaintextDataKey.Some? && 0 < |cryptoPrimitives.History.AESDecrypt| && Seq.Last(cryptoPrimitives.History.AESDecrypt).output.Success? && var AESDecryptRequest: AESDecryptInput := Seq.Last(cryptoPrimitives.History.AESDecrypt).input; AESDecryptRequest.encAlg == wrappingAlgorithm && AESDecryptRequest.key == wrappingKey && (exists edk: EncryptedDataKey {:trigger edk.ciphertext} {:trigger edk.keyProviderInfo} {:trigger edk in input.encryptedDataKeys} | edk in input.encryptedDataKeys :: ValidProviderInfo(edk.keyProviderInfo) && wrappingAlgorithm.tagLength as nat <= |edk.ciphertext| && AESDecryptRequest.iv == GetIvFromProvInfo(edk.keyProviderInfo)) && AESDecryptRequest.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).value
      ensures CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext).Failure? ==> output.Failure?
      decreases Modifies - {History}
    {
      var materials := input.materials;
      :- Need(Materials.DecryptionMaterialsWithoutPlaintextDataKey(materials), Types.AwsCryptographicMaterialProvidersException(message := "Keyring received decryption materials that already contain a plaintext data key."));
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.materials.encryptionContext);
      SequenceIsSafeBecauseItIsInMemory(wrappingKey);
      :- Need(|wrappingKey| as uint64 == wrappingAlgorithm.keyLength as uint64, Types.AwsCryptographicMaterialProvidersException(message := "The wrapping key does not match the wrapping algorithm"));
      var errors: seq<Types.Error> := [];
      SequenceIsSafeBecauseItIsInMemory(input.encryptedDataKeys);
      for i: uint64 := 0 to |input.encryptedDataKeys| as uint64
        invariant |errors| == i as nat
        invariant unchanged(History)
      {
        if ShouldDecryptEDK(input.encryptedDataKeys[i]) {
          var edk := input.encryptedDataKeys[i];
          var iv := GetIvFromProvInfo(edk.keyProviderInfo);
          var unwrap := new AesUnwrapKeyMaterial(wrappingKey, wrappingAlgorithm, iv, cryptoPrimitives);
          var unwrapOutput := EdkWrapping.UnwrapEdkMaterial(edk.ciphertext, materials, unwrap);
          if unwrapOutput.Success? {
            var result :- Materials.DecryptionMaterialsAddDataKey(materials, unwrapOutput.value.plaintextDataKey, unwrapOutput.value.symmetricSigningKey);
            var value := Types.OnDecryptOutput(materials := result);
            return Success(value);
          } else {
            errors := errors + [unwrapOutput.error];
          }
        } else {
          var extractedKeyProviderId :- UTF8.Decode(input.encryptedDataKeys[i].keyProviderId).MapFailure((e: string) => Types.AwsCryptographicMaterialProvidersException(message := e));
          errors := errors + [Types.AwsCryptographicMaterialProvidersException(message := ErrorMessages.IncorrectRawDataKeys(Base10Int2String(i as nat), "AESKeyring", extractedKeyProviderId))];
        }
      }
      return Failure(Types.CollectionOfErrors(list := errors, message := "Raw AES Keyring was unable to decrypt any encrypted data key. The list of encountered Exceptions is avaible via `list`."));
    }

    function method SerializeProviderInfo(iv: seq<uint8>): seq<uint8>
      requires |iv| == wrappingAlgorithm.ivLength as int
      decreases iv
    {
      keyName + UInt32ToSeq((wrappingAlgorithm.tagLength * 8) as uint32) + UInt32ToSeq(wrappingAlgorithm.ivLength as uint32) + iv
    }

    predicate method ShouldDecryptEDK(edk: Types.EncryptedDataKey)
      decreases edk
    {
      edk.keyProviderId == keyNamespace &&
      ValidProviderInfo(edk.keyProviderInfo)
    }

    predicate method ValidProviderInfo(info: seq<uint8>)
      decreases info
    {
      SequenceIsSafeBecauseItIsInMemory(info);
      SequenceIsSafeBecauseItIsInMemory(keyName);
      var keyname_size: uint64 := |keyName| as uint64;
      |info| as uint64 == Add4(keyname_size, AUTH_TAG_LEN_LEN as uint64, IV_LEN_LEN as uint64, wrappingAlgorithm.ivLength as uint64) &&
      info[..keyname_size] == keyName &&
      SeqToUInt32(info[keyname_size .. keyname_size + AUTH_TAG_LEN_LEN as uint64]) == 128 &&
      128 == wrappingAlgorithm.tagLength as uint32 * 8 &&
      SeqToUInt32(info[keyname_size + AUTH_TAG_LEN_LEN as uint64 .. keyname_size + AUTH_TAG_LEN_LEN as uint64 + IV_LEN_LEN as uint64]) == wrappingAlgorithm.ivLength as uint32 &&
      SeqToUInt32(info[keyname_size + AUTH_TAG_LEN_LEN as uint64 .. keyname_size + AUTH_TAG_LEN_LEN as uint64 + IV_LEN_LEN as uint64]) == 12
    }

    function method GetIvFromProvInfo(info: seq<uint8>): seq<uint8>
      requires ValidProviderInfo(info)
      decreases info
    {
      SequenceIsSafeBecauseItIsInMemory(keyName);
      info[|keyName| as uint64 + AUTH_TAG_LEN_LEN as uint64 + IV_LEN_LEN as uint64..]
    }
  }

  datatype AesUnwrapInfo = AesUnwrapInfo

  datatype AesWrapInfo = AesWrapInfo(iv: seq<uint8>)

  class AesGenerateAndWrapKeyMaterial extends MaterialWrapping.GenerateAndWrapMaterial<AesWrapInfo> {
    const wrap: AesWrapKeyMaterial

    constructor (wrap: AesWrapKeyMaterial)
      requires wrap.Invariant()
      ensures this.wrap == wrap
      ensures Invariant()
      decreases wrap
    {
      this.wrap := wrap;
      Modifies := wrap.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      Modifies == wrap.Modifies &&
      wrap.Invariant()
    }

    predicate Ensures(input: MaterialWrapping.GenerateAndWrapInput, res: Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        2 <= |wrap.cryptoPrimitives.History.GenerateRandomBytes| &&
        Seq.Last(Seq.DropLast(wrap.cryptoPrimitives.History.GenerateRandomBytes)).output.Success? &&
        ghost var plaintextMaterial: seq<uint8> := Seq.Last(Seq.DropLast(wrap.cryptoPrimitives.History.GenerateRandomBytes)).output.value; res.value.plaintextMaterial == plaintextMaterial && wrap.Ensures(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), Success(MaterialWrapping.WrapOutput(wrappedMaterial := res.value.wrappedMaterial, wrapInfo := res.value.wrapInfo)), []) && |res.value.plaintextMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat
    }

    method Invoke(input: MaterialWrapping.GenerateAndWrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.GenerateAndWrapInput, Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.GenerateAndWrapOutput<AesWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var generateBytesResult := wrap.cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite)));
      var plaintextMaterial :- generateBytesResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      ghost var oldGenerateRandomBytes := wrap.cryptoPrimitives.History.GenerateRandomBytes;
      var wrapOutput: MaterialWrapping.WrapOutput<AesWrapInfo> :- wrap.Invoke(MaterialWrapping.WrapInput(plaintextMaterial := plaintextMaterial, algorithmSuite := input.algorithmSuite, encryptionContext := input.encryptionContext, serializedEC := input.serializedEC), []);
      res := Success(MaterialWrapping.GenerateAndWrapOutput(plaintextMaterial := plaintextMaterial, wrappedMaterial := wrapOutput.wrappedMaterial, wrapInfo := wrapOutput.wrapInfo));
      wrap.cryptoPrimitives.History.GenerateRandomBytes := oldGenerateRandomBytes + [Seq.Last(wrap.cryptoPrimitives.History.GenerateRandomBytes)];
    }
  }

  class AesWrapKeyMaterial extends MaterialWrapping.WrapMaterial<AesWrapInfo> {
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (wrappingKey: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      ensures this.wrappingKey == wrappingKey && this.wrappingAlgorithm == wrappingAlgorithm && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases wrappingKey, wrappingAlgorithm, cryptoPrimitives
    {
      this.wrappingKey := wrappingKey;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies
    }

    predicate Ensures(input: MaterialWrapping.WrapInput, res: Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      true &&
      (res.Success? ==>
        Invariant() &&
        CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? &&
        0 < |cryptoPrimitives.History.GenerateRandomBytes| &&
        0 < |cryptoPrimitives.History.AESEncrypt| &&
        Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.Success? &&
        Seq.Last(cryptoPrimitives.History.AESEncrypt).output.Success? &&
        ghost var iv: seq<uint8> := Seq.Last(cryptoPrimitives.History.GenerateRandomBytes).output.value; true && ghost var AESEncryptInput: AESEncryptInput := Seq.Last(cryptoPrimitives.History.AESEncrypt).input; true && ghost var AESEncryptOutput: AESEncryptOutput := Seq.Last(cryptoPrimitives.History.AESEncrypt).output.value; |iv| == wrappingAlgorithm.ivLength as nat && AESEncryptInput.encAlg == wrappingAlgorithm && AESEncryptInput.key == wrappingKey && AESEncryptInput.iv == iv && AESEncryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value && res.value.wrappedMaterial == SerializeEDKCiphertext(AESEncryptOutput) && res.value.wrapInfo.iv == iv)
    }

    method Invoke(input: MaterialWrapping.WrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.WrapInput, Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.WrapOutput<AesWrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      var randomIvResult := cryptoPrimitives.GenerateRandomBytes(Crypto.GenerateRandomBytesInput(length := wrappingAlgorithm.ivLength));
      var iv :- randomIvResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var aesEncryptResult := cryptoPrimitives.AESEncrypt(Crypto.AESEncryptInput(encAlg := wrappingAlgorithm, iv := iv, key := wrappingKey, msg := input.plaintextMaterial, aad := aad));
      var wrappedMaterialResult :- aesEncryptResult.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      var wrappedMaterial := SerializeEDKCiphertext(wrappedMaterialResult);
      return Success(MaterialWrapping.WrapOutput(wrappedMaterial := wrappedMaterial, wrapInfo := AesWrapInfo(iv)));
    }
  }

  class AesUnwrapKeyMaterial extends MaterialWrapping.UnwrapMaterial<AesUnwrapInfo> {
    const wrappingKey: seq<uint8>
    const wrappingAlgorithm: Crypto.AES_GCM
    const iv: seq<uint8>
    const cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient

    constructor (wrappingKey: seq<uint8>, wrappingAlgorithm: Crypto.AES_GCM, iv: seq<uint8>, cryptoPrimitives: AtomicPrimitives.AtomicPrimitivesClient)
      requires cryptoPrimitives.ValidState()
      requires |iv| == wrappingAlgorithm.ivLength as nat
      ensures this.wrappingKey == wrappingKey && this.iv == iv && this.wrappingAlgorithm == wrappingAlgorithm && this.cryptoPrimitives == cryptoPrimitives
      ensures Invariant()
      decreases wrappingKey, wrappingAlgorithm, iv, cryptoPrimitives
    {
      this.wrappingKey := wrappingKey;
      this.iv := iv;
      this.wrappingAlgorithm := wrappingAlgorithm;
      this.cryptoPrimitives := cryptoPrimitives;
      Modifies := cryptoPrimitives.Modifies;
    }

    predicate Invariant()
      reads Modifies
      decreases Modifies
    {
      cryptoPrimitives.ValidState() &&
      Modifies == cryptoPrimitives.Modifies &&
      |iv| == wrappingAlgorithm.ivLength as nat
    }

    predicate Ensures(input: MaterialWrapping.UnwrapInput, res: Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>, attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>>>)
      reads Modifies
      decreases Modifies
    {
      res.Success? ==>
        Invariant() &&
        |res.value.unwrappedMaterial| == AlgorithmSuites.GetEncryptKeyLength(input.algorithmSuite) as nat &&
        CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).Success? &&
        wrappingAlgorithm.tagLength as nat <= |input.wrappedMaterial| &&
        ghost var encryptionOutput: Crypto.AESEncryptOutput := DeserializeEDKCiphertext(input.wrappedMaterial, wrappingAlgorithm.tagLength as uint64); 0 < |cryptoPrimitives.History.AESDecrypt| && Seq.Last(cryptoPrimitives.History.AESDecrypt).output.Success? && ghost var AESDecryptInput: AESDecryptInput := Seq.Last(cryptoPrimitives.History.AESDecrypt).input; AESDecryptInput.encAlg == wrappingAlgorithm && AESDecryptInput.key == wrappingKey && AESDecryptInput.cipherTxt == encryptionOutput.cipherText && AESDecryptInput.authTag == encryptionOutput.authTag && AESDecryptInput.iv == iv && AESDecryptInput.aad == CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext).value && res.value.unwrappedMaterial == Seq.Last(cryptoPrimitives.History.AESDecrypt).output.value
    }

    method Invoke(input: MaterialWrapping.UnwrapInput, ghost attemptsState: seq<ActionInvoke<MaterialWrapping.UnwrapInput, Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>>>) returns (res: Result<MaterialWrapping.UnwrapOutput<AesUnwrapInfo>, Types.Error>)
      requires Invariant()
      modifies Modifies
      ensures Invariant()
      ensures Ensures(input, res, attemptsState)
      decreases Modifies
    {
      var aad :- CanonicalEncryptionContext.EncryptionContextToAAD(input.encryptionContext);
      SequenceIsSafeBecauseItIsInMemory(input.wrappedMaterial);
      :- Need(wrappingAlgorithm.tagLength as uint64 <= |input.wrappedMaterial| as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Insufficient data to decrypt."));
      var encryptionOutput := DeserializeEDKCiphertext(input.wrappedMaterial, wrappingAlgorithm.tagLength as uint64);
      var maybePtKey := cryptoPrimitives.AESDecrypt(Crypto.AESDecryptInput(encAlg := wrappingAlgorithm, key := wrappingKey, cipherTxt := encryptionOutput.cipherText, authTag := encryptionOutput.authTag, iv := iv, aad := aad));
      var ptKey :- maybePtKey.MapFailure((e: Error) => Types.AwsCryptographyPrimitives(AwsCryptographyPrimitives := e));
      :- Need(GetEncryptKeyLength(input.algorithmSuite) as uint64 == |ptKey| as uint64, Types.AwsCryptographicMaterialProvidersException(message := "Plaintext Data Key is not the expected length"));
      return Success(MaterialWrapping.UnwrapOutput(unwrappedMaterial := ptKey, unwrapInfo := AesUnwrapInfo));
    }
  }
}

module Commitment {
  function method ValidateCommitmentPolicyOnEncrypt(algorithm: AlgorithmSuiteId, commitmentPolicy: CommitmentPolicy): (res: Outcome<Error>)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Pass?
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Pass?
    decreases algorithm, commitmentPolicy
  {
    var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm);
    if commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) && !suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnEncrypt(message := "Configuration conflict. Commitment policy requires only non-committing algorithm suites"))
    else if (commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnEncrypt(message := "Configuration conflict. Commitment policy requires only committing algorithm suites"))
    else
      Pass
  }

  function method ValidateCommitmentPolicyOnDecrypt(algorithm: AlgorithmSuiteId, commitmentPolicy: CommitmentPolicy): (res: Outcome<Error>)
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && suite.commitment.None?) ==> res.Fail?
    ensures (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && (var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm); true && !suite.commitment.None?) ==> res.Pass?
    ensures true && (commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT)) ==> res.Pass?
    decreases algorithm, commitmentPolicy
  {
    var suite: AlgorithmSuite := AlgorithmSuites.GetSuite(algorithm);
    if true && (commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) || commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT)) && suite.commitment.None? then
      Fail(InvalidAlgorithmSuiteInfoOnDecrypt(message := "Configuration conflict. Commitment policy requires only committing algorithm suites"))
    else
      Pass
  }

  import opened Wrappers

  import opened AwsCryptographyMaterialProvidersTypes

  import AlgorithmSuites
}

module Defaults {
  function method GetAlgorithmSuiteForCommitmentPolicy(commitmentPolicy: CommitmentPolicy): (output: AlgorithmSuiteId)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(FORBID_ENCRYPT_ALLOW_DECRYPT) ==> output == AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384)
    ensures commitmentPolicy == CommitmentPolicy.ESDK(REQUIRE_ENCRYPT_ALLOW_DECRYPT) || commitmentPolicy == CommitmentPolicy.ESDK(ESDKCommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) ==> output == AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384)
    ensures commitmentPolicy == CommitmentPolicy.DBE(DBECommitmentPolicy.REQUIRE_ENCRYPT_REQUIRE_DECRYPT) ==> output == AlgorithmSuiteId.DBE(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384)
    decreases commitmentPolicy
  {
    match commitmentPolicy
    case ESDK(c) =>
      (match c
      case FORBID_ENCRYPT_ALLOW_DECRYPT() =>
        AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384)
      case _ /* _v0 */ =>
        AlgorithmSuiteId.ESDK(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384))
    case DBE(_ /* _v1 */) =>
      AlgorithmSuiteId.DBE(ALG_AES_256_GCM_HKDF_SHA512_COMMIT_KEY_ECDSA_P384_SYMSIG_HMAC_SHA384)
  }

  import opened AwsCryptographyMaterialProvidersTypes
}

module {:options "/functionSyntax:4"} CMM {
  predicate method RequiredEncryptionContextKeys?(requiredEncryptionContextKeys: Option<Types.EncryptionContextKeys>, encryptionMaterials: Types.EncryptionMaterials)
    decreases requiredEncryptionContextKeys, encryptionMaterials
  {
    forall k: ValidUTF8Bytes {:trigger k in encryptionMaterials.requiredEncryptionContextKeys} {:trigger k in requiredEncryptionContextKeys.UnwrapOr([])} | k in requiredEncryptionContextKeys.UnwrapOr([]) :: 
      k in encryptionMaterials.requiredEncryptionContextKeys
  }

  predicate method EncryptionContextComplete(input: Types.DecryptMaterialsInput, decryptionMaterials: Types.DecryptionMaterials)
    decreases input, decryptionMaterials
  {
    var reproducedEncryptionContext: EncryptionContext := input.reproducedEncryptionContext.UnwrapOr(map[]);
    forall k: seq<BoundedInts.uint8> {:trigger reproducedEncryptionContext[k]} {:trigger decryptionMaterials.encryptionContext[k]} {:trigger k in decryptionMaterials.encryptionContext} {:trigger k in reproducedEncryptionContext} | k in reproducedEncryptionContext :: 
      k in decryptionMaterials.encryptionContext &&
      decryptionMaterials.encryptionContext[k] == reproducedEncryptionContext[k]
  }

  predicate method ReproducedEncryptionContext?(input: Types.DecryptMaterialsInput)
    decreases input
  {
    var reproducedEncryptionContext: EncryptionContext := input.reproducedEncryptionContext.UnwrapOr(map[]);
    forall k: seq<BoundedInts.uint8> {:trigger reproducedEncryptionContext[k]} {:trigger input.encryptionContext[k]} {:trigger k in input.encryptionContext} {:trigger k in reproducedEncryptionContext} | k in reproducedEncryptionContext && k in input.encryptionContext :: 
      input.encryptionContext[k] == reproducedEncryptionContext[k]
  }

  import opened Wrappers

  import Types = AwsCryptographyMaterialProvidersTypes

  import Materials

  trait {:termination false} VerifiableInterface extends Types.ICryptographicMaterialsManager {
    predicate GetEncryptionMaterialsEnsuresPublicly(input: Types.GetEncryptionMaterialsInput, output: Result<Types.GetEncryptionMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> output.Success? ==> Materials.EncryptionMaterialsHasPlaintextDataKey(output.value.encryptionMaterials) && RequiredEncryptionContextKeys?(input.requiredEncryptionContextKeys, output.value.encryptionMaterials)
      decreases input, output

    predicate DecryptMaterialsEnsuresPublicly(input: Types.DecryptMaterialsInput, output: Result<Types.DecryptMaterialsOutput, Types.Error>): (outcome: bool)
      ensures outcome ==> (output.Success? ==> Materials.DecryptionMaterialsWithPlaintextDataKey(output.value.decryptionMaterials)) && (output.Success? ==> ReproducedEncryptionContext?(input)) && (!ReproducedEncryptionContext?(input) ==> output.Failure?) && (output.Success? ==> EncryptionContextComplete(input, output.value.decryptionMaterials))
      decreases input, output
  }
}

module DefaultClientSupplier {

  import ComAmazonawsKmsTypes

  import Kms = Com.Amazonaws.Kms

  import opened AwsCryptographyMaterialProvidersTypes

  import opened Wrappers
  class DefaultClientSupplier extends IClientSupplier {
    predicate ValidState()
      ensures ValidState() ==> History in Modifies
    {
      true &&
      History in Modifies
    }

    constructor ()
      ensures ValidState() && fresh(History) && fresh(Modifies)
    {
      History := new IClientSupplierCallHistory();
      Modifies := {History};
    }

    predicate GetClientEnsuresPublicly(input: GetClientInput, output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      decreases input, output
    {
      true
    }

    method GetClient'(input: GetClientInput) returns (output: Result<ComAmazonawsKmsTypes.IKMSClient, Error>)
      requires true && ValidState()
      modifies Modifies - {History}
      ensures ValidState() && (output.Success? ==> output.value.ValidState() && output.value.Modifies !! Modifies && fresh(output.value) && fresh(output.value.Modifies))
      ensures GetClientEnsuresPublicly(input, output)
      ensures unchanged(History)
      decreases Modifies - {History}
    {
      var maybeClient := Kms.KMSClientForRegion(input.region);
      return maybeClient.MapFailure((e: Error) => ComAmazonawsKms(e));
    }
  }
}

module MrkAwareDiscoveryMultiKeyring {
  method MrkAwareDiscoveryMultiKeyring(regions: seq<string>, discoveryFilter: Option<Types.DiscoveryFilter>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures |regions| == 0 || (exists r: seq<char> {:trigger r in regions} | r in regions :: r == "") ==> output.Failure?
    ensures true && output.Success? ==> output.value.generatorKeyring.None? && |regions| == |output.value.childKeyrings| && forall i: int {:trigger regions[i]} {:trigger output.value.childKeyrings[i]} | 0 <= i < |regions| :: var k: Types.IKeyring := output.value.childKeyrings[i]; k is AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring && var c: AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring := k as AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring; c.region == regions[i] && (discoveryFilter.Some? ==> c.discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> c.grantTokens == grantTokens.value)
    decreases regions, discoveryFilter, clientSupplier, grantTokens
  {
    SequenceIsSafeBecauseItIsInMemory(regions);
    :- Need(|regions| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "No regions passed."));
    :- Need(Seq.IndexOfOption(regions, "").None?, Types.AwsCryptographicMaterialProvidersException(message := "Empty string is not a valid region."));
    var children: seq<AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring> := [];
    for i: uint64 := 0 to |regions| as uint64
      invariant |regions[..i]| == |children|
      invariant fresh(MultiKeyring.GatherModifies(None, children) - clientSupplier.Modifies)
      invariant forall i: int {:trigger regions[i]} {:trigger children[i]} | 0 <= i < |children| :: children[i].region == regions[i] && (discoveryFilter.Some? ==> children[i].discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
    {
      var region := regions[i];
      var client :- clientSupplier.GetClient(Types.GetClientInput(region := region));
      var keyring := new AwsKmsMrkDiscoveryKeyring.AwsKmsMrkDiscoveryKeyring(client, region, discoveryFilter, grantTokens.UnwrapOr([]));
      children := children + [keyring];
    }
    var keyring := new MultiKeyring.MultiKeyring(None(), children);
    return Success(keyring);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsMrkDiscoveryKeyring

  import opened AwsKmsUtils
}

module AwsKmsMrkAreUnique {
  function method AwsKmsMrkAreUnique(identifiers: seq<AwsKmsIdentifier>): (result: Outcome<Types.Error>)
    decreases identifiers
  {
    var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    SequenceIsSafeBecauseItIsInMemory(mrks);
    if |mrks| as uint64 == 0 then
      Pass
    else
      var mrkKeyIds: seq<seq<char>> := Seq.Map(GetKeyId, mrks); var setMrks: set<seq<char>> := ToSet(mrkKeyIds); SetIsSafeBecauseItIsInMemory(setMrks); if |mrkKeyIds| as uint64 == |setMrks| as uint64 then Pass else var duplicateMrkIds: set<seq<char>> := set x: seq<char> {:trigger multiset(mrkKeyIds)[x]} {:trigger x in mrkKeyIds} | x in mrkKeyIds && multiset(mrkKeyIds)[x] >= 1; var isDuplicate: AwsKmsIdentifier -> bool := (identifier: AwsKmsIdentifier) => GetKeyId(identifier) in duplicateMrkIds; var identifierToString: AwsKmsIdentifier -> string := (i: AwsKmsIdentifier) => i.ToString(); var duplicateIdentifiers: seq<AwsKmsIdentifier> := Seq.Filter(isDuplicate, identifiers); assert |identifiers| >= |mrkKeyIds|; assert |mrks| == |mrkKeyIds|; var duplicates: seq<string> := Seq.Map(identifierToString, duplicateIdentifiers); SequenceIsSafeBecauseItIsInMemory(duplicates); if |duplicates| as uint64 == 0 then Fail(Types.AwsCryptographicMaterialProvidersException(message := "Impossible")) else Fail(Types.AwsCryptographicMaterialProvidersException(message := "Related multi-Region keys: " + Join(duplicates, ",") + "are not allowed."))
  }

  function method GetKeyId(identifier: AwsKmsIdentifier): (result: string)
    decreases identifier
  {
    match identifier {
      case AwsKmsArnIdentifier(a) =>
        a.resource.value
      case AwsKmsRawResourceIdentifier(i) =>
        i.value
    }
  }

  lemma /*{:_inductionTrigger AwsKmsMrkAreUnique(identifiers)}*/ /*{:_inductionTrigger _default.Filter(IsMultiRegionAwsKmsIdentifier, identifiers)}*/ /*{:_induction identifiers}*/ AwsKmsMrkAreUniqueCorrect(identifiers: seq<AwsKmsIdentifier>)
    ensures |Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers)| == 0 ==> AwsKmsMrkAreUnique(identifiers).Pass?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Pass?
    ensures ghost var mrks: seq<AwsKmsIdentifier> := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers); ghost var ids: seq<string> := Seq.Map(GetKeyId, mrks); |mrks| > 0 && !Seq.HasNoDuplicates(ids) ==> AwsKmsMrkAreUnique(identifiers).Fail?
    decreases identifiers
  {
    ghost var mrks := Seq.Filter(IsMultiRegionAwsKmsIdentifier, identifiers);
    ghost var ids := Seq.Map(GetKeyId, mrks);
    if Seq.HasNoDuplicates(ids) {
      LemmaCardinalityOfSetNoDuplicates(ids);
    }
    if |ToSet(ids)| == |ids| {
      LemmaNoDuplicatesCardinalityOfSet(ids);
    }
  }

  import opened StandardLibrary

  import opened Wrappers

  import opened Seq

  import opened AwsArnParsing

  import Types = AwsCryptographyMaterialProvidersTypes

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened UInt = StandardLibrary.UInt
}

module MrkAwareStrictMultiKeyring {
  method {:vcs_split_on_every_assert} MrkAwareStrictMultiKeyring(generator: Option<string>, awsKmsKeys: Option<seq<string>>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures (generator.Some? && generator.value == "") || (awsKmsKeys.Some? && exists k: seq<char> {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k == "") ==> output.Failure?
    ensures var allStrings: seq<seq<char>> := if generator.Some? then [generator.value] + awsKmsKeys.UnwrapOr([]) else awsKmsKeys.UnwrapOr([]); var allIdentifiers: Result<seq<AwsKmsIdentifier>, string> := Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings); allIdentifiers.Failure? || (allIdentifiers.Success? && AwsKmsMrkAreUnique.AwsKmsMrkAreUnique(allIdentifiers.value).Fail?) ==> output.Failure?
    ensures true && output.Success? ==> (generator.Some? ==> output.value.generatorKeyring.Some? && output.value.generatorKeyring.value is AwsKmsMrkKeyring.AwsKmsMrkKeyring && var g: AwsKmsMrkKeyring.AwsKmsMrkKeyring := output.value.generatorKeyring.value as AwsKmsMrkKeyring.AwsKmsMrkKeyring; g.awsKmsKey == generator.value && (grantTokens.Some? ==> g.grantTokens == grantTokens.value)) && (generator.None? ==> true && output.value.generatorKeyring.None?) && (awsKmsKeys.Some? ==> |awsKmsKeys.value| == |output.value.childKeyrings| && forall index: int {:trigger awsKmsKeys.value[index]} {:trigger output.value.childKeyrings[index]} | 0 <= index < |awsKmsKeys.value| :: var childKeyring: Types.IKeyring := output.value.childKeyrings[index]; childKeyring is AwsKmsMrkKeyring.AwsKmsMrkKeyring && var awsKmsChild: AwsKmsMrkKeyring.AwsKmsMrkKeyring := childKeyring as AwsKmsMrkKeyring.AwsKmsMrkKeyring; awsKmsChild.awsKmsKey == awsKmsKeys.value[index] && (grantTokens.Some? ==> awsKmsChild.grantTokens == grantTokens.value)) && (awsKmsKeys.None? ==> true && output.value.childKeyrings == [])
    decreases generator, awsKmsKeys, clientSupplier, grantTokens
  {
    var allStrings := match generator { case Some(g) => [g] + awsKmsKeys.UnwrapOr([]) case None() => awsKmsKeys.UnwrapOr([]) };
    assert generator.Some? ==> generator.value in allStrings;
    assert awsKmsKeys.Some? ==> forall k: seq<char> {:trigger k in allStrings} {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k in allStrings;
    var allIdentifiers :- Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings).MapFailure(WrapStringToError);
    :- AwsKmsMrkAreUnique.AwsKmsMrkAreUnique(allIdentifiers);
    var generatorKeyring: Option<AwsKmsMrkKeyring.AwsKmsMrkKeyring>;
    match generator {
      case {:split false} Some(generatorIdentifier) =>
        var arn :- AwsArnParsing.IsAwsKmsIdentifierString(generatorIdentifier).MapFailure(WrapStringToError);
        var region := AwsArnParsing.GetRegion(arn);
        var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("")));
        var g := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(client, generatorIdentifier, grantTokens.UnwrapOr([]));
        generatorKeyring := Some(g);
      case {:split false} None() =>
        generatorKeyring := None();
    }
    var children: seq<AwsKmsMrkKeyring.AwsKmsMrkKeyring> := [];
    match awsKmsKeys {
      case {:split false} Some(childIdentifiers) =>
        SequenceIsSafeBecauseItIsInMemory(childIdentifiers);
        for index: uint64 := 0 to |childIdentifiers| as uint64
          invariant |awsKmsKeys.value[..index]| == |children|
          invariant fresh(MultiKeyring.GatherModifies(generatorKeyring, children) - clientSupplier.Modifies)
          invariant forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens)
        {
          var childIdentifier := childIdentifiers[index];
          var info :- AwsArnParsing.IsAwsKmsIdentifierString(childIdentifier).MapFailure(WrapStringToError);
          var region := AwsArnParsing.GetRegion(info);
          var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("")));
          var keyring := new AwsKmsMrkKeyring.AwsKmsMrkKeyring(client, childIdentifier, grantTokens.UnwrapOr([]));
          children := children + [keyring];
          assert forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens) by {
            assert forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children| - 1 :: ChildLoopInvariant(children[i], awsKmsKeys.value[i], grantTokens);
            assert ChildLoopInvariant(keyring, awsKmsKeys.value[index], grantTokens);
            assert children[|children| - 1] == keyring;
          }
        }
      case {:split false} None() =>
        children := [];
    }
    SequenceIsSafeBecauseItIsInMemory(children);
    :- Need(generatorKeyring.Some? || |children| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "generatorKeyring or child Keyrings needed to create a multi keyring"));
    var keyring := new MultiKeyring.MultiKeyring(generatorKeyring, children);
    return Success(keyring);
  }

  predicate ChildLoopInvariant(child: AwsKmsMrkKeyring.AwsKmsMrkKeyring, awsKmsKey: string, grantTokens: Option<KMS.GrantTokenList>)
    decreases child, awsKmsKey, grantTokens
  {
    child.awsKmsKey == awsKmsKey &&
    (grantTokens.Some? ==>
      child.grantTokens == grantTokens.value) &&
    child.ValidState()
  }

  import opened Wrappers

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened UInt = StandardLibrary.UInt

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsMrkKeyring

  import opened AwsKmsUtils
}

module DiscoveryMultiKeyring {
  method DiscoveryMultiKeyring(regions: seq<string>, discoveryFilter: Option<Types.DiscoveryFilter>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures |regions| == 0 || (exists r: seq<char> {:trigger r in regions} | r in regions :: r == "") ==> output.Failure?
    ensures true && output.Success? ==> output.value.generatorKeyring.None? && |regions| == |output.value.childKeyrings| && forall i: int {:trigger output.value.childKeyrings[i]} | 0 <= i < |regions| :: var k: Types.IKeyring := output.value.childKeyrings[i]; k is AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring && var c: AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring := k as AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring; (discoveryFilter.Some? ==> c.discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> c.grantTokens == grantTokens.value)
    decreases regions, discoveryFilter, clientSupplier, grantTokens
  {
    SequenceIsSafeBecauseItIsInMemory(regions);
    :- Need(|regions| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "No regions passed."));
    :- Need(Seq.IndexOfOption(regions, "").None?, Types.AwsCryptographicMaterialProvidersException(message := "Empty string is not a valid region."));
    var children: seq<AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring> := [];
    SequenceIsSafeBecauseItIsInMemory(regions);
    for i: uint64 := 0 to |regions| as uint64
      invariant |regions[..i]| == |children|
      invariant fresh(MultiKeyring.GatherModifies(None, children) - clientSupplier.Modifies)
      invariant forall i: int {:trigger children[i]} | 0 <= i < |children| :: (discoveryFilter.Some? ==> children[i].discoveryFilter == discoveryFilter) && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
    {
      var region := regions[i];
      var client :- clientSupplier.GetClient(Types.GetClientInput(region := region));
      var keyring := new AwsKmsDiscoveryKeyring.AwsKmsDiscoveryKeyring(client, discoveryFilter, grantTokens.UnwrapOr([]));
      children := children + [keyring];
    }
    var keyring := new MultiKeyring.MultiKeyring(None(), children);
    return Success(keyring);
  }

  import opened Wrappers

  import opened UInt = StandardLibrary.UInt

  import opened MemoryMath = StandardLibrary.MemoryMath

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsDiscoveryKeyring

  import opened AwsKmsUtils

  import Kms = Com.Amazonaws.Kms
}

module StrictMultiKeyring {
  method {:vcs_split_on_every_assert} StrictMultiKeyring(generator: Option<string>, awsKmsKeys: Option<seq<string>>, clientSupplier: Types.IClientSupplier, grantTokens: Option<KMS.GrantTokenList>)
      returns (output: Result<MultiKeyring.MultiKeyring, Types.Error>)
    requires clientSupplier.ValidState()
    modifies clientSupplier.Modifies
    ensures output.Success? ==> output.value.ValidState() && fresh(output.value) && fresh(output.value.History) && fresh(output.value.Modifies - clientSupplier.Modifies)
    ensures (generator.Some? && generator.value == "") || (awsKmsKeys.Some? && exists k: seq<char> {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k == "") ==> output.Failure?
    ensures var allStrings: seq<seq<char>> := if generator.Some? then [generator.value] + awsKmsKeys.UnwrapOr([]) else awsKmsKeys.UnwrapOr([]); var allIdentifiers: Result<seq<AwsKmsIdentifier>, string> := Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings); true && allIdentifiers.Failure? ==> output.Failure?
    ensures true && output.Success? ==> (generator.Some? ==> output.value.generatorKeyring.Some? && output.value.generatorKeyring.value is AwsKmsKeyring.AwsKmsKeyring && var g: AwsKmsKeyring.AwsKmsKeyring := output.value.generatorKeyring.value as AwsKmsKeyring.AwsKmsKeyring; g.awsKmsKey == generator.value && (grantTokens.Some? ==> g.grantTokens == grantTokens.value)) && (generator.None? ==> true && output.value.generatorKeyring.None?) && (awsKmsKeys.Some? ==> |awsKmsKeys.value| == |output.value.childKeyrings| && forall index: int {:trigger awsKmsKeys.value[index]} {:trigger output.value.childKeyrings[index]} | 0 <= index < |awsKmsKeys.value| :: var childKeyring: Types.IKeyring := output.value.childKeyrings[index]; childKeyring is AwsKmsKeyring.AwsKmsKeyring && var awsKmsChild: AwsKmsKeyring.AwsKmsKeyring := childKeyring as AwsKmsKeyring.AwsKmsKeyring; awsKmsChild.awsKmsKey == awsKmsKeys.value[index] && (grantTokens.Some? ==> awsKmsChild.grantTokens == grantTokens.value)) && (awsKmsKeys.None? ==> true && output.value.childKeyrings == [])
    decreases generator, awsKmsKeys, clientSupplier, grantTokens
  {
    var allStrings := match generator { case Some(g) => [g] + awsKmsKeys.UnwrapOr([]) case None() => awsKmsKeys.UnwrapOr([]) };
    assert generator.Some? ==> generator.value in allStrings;
    assert awsKmsKeys.Some? ==> forall k: seq<char> {:trigger k in allStrings} {:trigger k in awsKmsKeys.value} | k in awsKmsKeys.value :: k in allStrings;
    var allIdentifiers :- Seq.MapWithResult(AwsArnParsing.IsAwsKmsIdentifierString, allStrings).MapFailure(WrapStringToError);
    var generatorKeyring: Option<AwsKmsKeyring.AwsKmsKeyring>;
    match generator {
      case {:split false} Some(generatorIdentifier) =>
        var arn :- AwsArnParsing.IsAwsKmsIdentifierString(generatorIdentifier).MapFailure(WrapStringToError);
        var region := AwsArnParsing.GetRegion(arn);
        var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("")));
        var g := new AwsKmsKeyring.AwsKmsKeyring(client, generatorIdentifier, grantTokens.UnwrapOr([]));
        generatorKeyring := Some(g);
      case {:split false} None() =>
        generatorKeyring := None();
    }
    var children: seq<AwsKmsKeyring.AwsKmsKeyring> := [];
    match awsKmsKeys {
      case {:split false} Some(childIdentifiers) =>
        SequenceIsSafeBecauseItIsInMemory(childIdentifiers);
        for index: uint64 := 0 to |childIdentifiers| as uint64
          invariant |awsKmsKeys.value[..index]| == |children|
          invariant fresh(MultiKeyring.GatherModifies(generatorKeyring, children) - clientSupplier.Modifies)
          invariant forall i: int {:trigger awsKmsKeys.value[i]} {:trigger children[i]} | 0 <= i < |children[..index]| :: children[i].awsKmsKey == awsKmsKeys.value[i] && (grantTokens.Some? ==> children[i].grantTokens == grantTokens.value) && children[i].ValidState()
        {
          var childIdentifier := childIdentifiers[index];
          var info :- AwsArnParsing.IsAwsKmsIdentifierString(childIdentifier).MapFailure(WrapStringToError);
          var region := AwsArnParsing.GetRegion(info);
          var client :- clientSupplier.GetClient(Types.GetClientInput(region := region.UnwrapOr("")));
          var keyring := new AwsKmsKeyring.AwsKmsKeyring(client, childIdentifier, grantTokens.UnwrapOr([]));
          children := children + [keyring];
          assert |awsKmsKeys.value[..index + 1]| == |children|;
          assert fresh(MultiKeyring.GatherModifies(generatorKeyring, children) - clientSupplier.Modifies);
        }
      case {:split false} None() =>
        children := [];
    }
    SequenceIsSafeBecauseItIsInMemory(children);
    :- Need(generatorKeyring.Some? || |children| as uint64 > 0, Types.AwsCryptographicMaterialProvidersException(message := "generatorKeyring or child Keryings needed to create a multi keyring"));
    var keyring := new MultiKeyring.MultiKeyring(generatorKeyring, children);
    return Success(keyring);
  }

  import opened Wrappers

  import opened MemoryMath = StandardLibrary.MemoryMath

  import opened UInt = StandardLibrary.UInt

  import Seq

  import Types = AwsCryptographyMaterialProvidersTypes

  import KMS = Types.ComAmazonawsKmsTypes

  import MultiKeyring

  import AwsArnParsing

  import AwsKmsMrkAreUnique

  import AwsKmsKeyring

  import opened AwsKmsUtils
}

module HeaderTypes {
  predicate ESDKAlgorithmSuite?(a: MPL.AlgorithmSuiteInfo)
    decreases a
  {
    a.id.ESDK?
  }

  const MESSAGE_ID_LEN_V1 := 16 as uint64
  const MESSAGE_ID_LEN_V2 := 32 as uint64

  import MPL = AwsCryptographyMaterialProvidersTypes

  import Seq

  import EncryptionContext

  import opened SerializableTypes

  import opened UInt = StandardLibrary.UInt

  import opened Wrappers

  import opened UTF8

  import opened SerializeFunctions

  datatype MessageFormatVersion = V1 | V2 {
    function method Serialize(): (bytes: seq<uint8>)
      decreases this
    {
      match this
      case V1() =>
        [1]
      case V2() =>
        [2]
    }

    lemma LemmaSerializeCorrectValue()
      ensures match this case V1() => this.Serialize() == [1] case V2() => this.Serialize() == [2]
      decreases this
    {
    }

    static function method Get(x: seq<uint8>): (res: Result<MessageFormatVersion, string>)
      ensures res.Success? ==> x == res.value.Serialize()
      decreases x
    {
      :- Need(x == [1] || x == [2], "Unsupported Version value."); Success(match x[0 as uint32] case 1 => V1 case 2 => V2)
    }
  }

  type ESDKAlgorithmSuite = a: MPL.AlgorithmSuiteInfo
    | ESDKAlgorithmSuite?(a)
    witness *

  datatype HeaderBody = V1HeaderBody(nameonly messageType: MessageType, nameonly algorithmSuite: ESDKAlgorithmSuite, nameonly messageId: MessageId, nameonly encryptionContext: EncryptionContext.ESDKCanonicalEncryptionContext, nameonly encryptedDataKeys: ESDKEncryptedDataKeys, nameonly contentType: ContentType, nameonly headerIvLength: uint64, nameonly frameLength: uint32) | V2HeaderBody(nameonly algorithmSuite: ESDKAlgorithmSuite, nameonly messageId: MessageId, nameonly encryptionContext: EncryptionContext.ESDKCanonicalEncryptionContext, nameonly encryptedDataKeys: ESDKEncryptedDataKeys, nameonly contentType: ContentType, nameonly frameLength: uint32, nameonly suiteData: seq<uint8>)

  datatype HeaderAuth = AESMac(nameonly headerIv: seq<uint8>, nameonly headerAuthTag: seq<uint8>)

  datatype MessageType = TYPE_CUSTOMER_AED {
    function method Serialize(): (val: uint8)
      decreases this
    {
      match this
      case TYPE_CUSTOMER_AED() =>
        128
    }

    lemma LemmaSerializeCorrectValue()
      ensures this.Serialize() == 128
      decreases this
    {
    }

    static function method Get(x: uint8): (res: Result<MessageType, string>)
      ensures res.Success? ==> x == res.value.Serialize()
      decreases x
    {
      :- Need(x == 128, "Unsupported ContentType value."); Success(match x case 128 => TYPE_CUSTOMER_AED)
    }
  }

  datatype ContentType = NonFramed | Framed {
    function method Serialize(): (val: uint8)
      decreases this
    {
      match this
      case NonFramed() =>
        1
      case Framed() =>
        2
    }

    lemma LemmaSerializeCorrectValue()
      ensures this.Serialize() in {1, 2}
      decreases this
    {
    }

    static function method Get(x: uint8): (res: Result<ContentType, string>)
      ensures res.Success? ==> x == res.value.Serialize()
      decreases x
    {
      :- Need(x == 1 || x == 2, "Unsupported ContentType value."); Success(match x case 1 => NonFramed case 2 => Framed)
    }
  }

  type MessageId = x: seq<uint8>
    | |x| == MESSAGE_ID_LEN_V1 as nat || |x| == MESSAGE_ID_LEN_V2 as nat
    witness *
}

module {:options "/functionSyntax:4"} EncryptionContext {
  predicate ESDKCanonicalEncryptionContext?(pairs: seq<ESDKEncryptionContextPair>)
    decreases pairs
  {
    HasUint16Len(pairs) &&
    LinearLength(pairs) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH &&
    KeysAreUnique(pairs)
  }

  lemma {:vcs_split_on_every_assert} ESDKEncryptionContextMapImpliesESDKCanonicalEncryptionContext(encryptionContext: MPL.EncryptionContext)
    ensures IsESDKEncryptionContext(encryptionContext) ==> ESDKCanonicalEncryptionContext?(GetCanonicalLinearPairs(encryptionContext))
    decreases encryptionContext
  {
    if IsESDKEncryptionContext(encryptionContext) {
      assert HasUint16Len(GetCanonicalLinearPairs(encryptionContext));
      assert LinearLength(GetCanonicalLinearPairs(encryptionContext)) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH;
      assert KeysAreUnique(GetCanonicalLinearPairs(encryptionContext));
    }
  }

  function method GetCanonicalEncryptionContext(encryptionContext: ESDKEncryptionContext): (ret: ESDKCanonicalEncryptionContext)
    ensures |encryptionContext| == |ret|
    decreases encryptionContext
  {
    ESDKEncryptionContextMapImpliesESDKCanonicalEncryptionContext(encryptionContext);
    GetCanonicalLinearPairs(encryptionContext)
  }

  function method GetEncryptionContext(canonicalEncryptionContext: ESDKCanonicalEncryptionContext): (ret: MPL.EncryptionContext)
    ensures |canonicalEncryptionContext| == 0 ==> |ret| == 0
    decreases canonicalEncryptionContext
  {
    assert ESDKCanonicalEncryptionContext?(canonicalEncryptionContext);
    assert KeysAreUnique(canonicalEncryptionContext);
    map i: int {:trigger canonicalEncryptionContext[i]} | 0 <= i < |canonicalEncryptionContext| :: canonicalEncryptionContext[i].key := canonicalEncryptionContext[i].value
  }

  lemma {:vcs_split_on_every_assert} LemmaCardinalityOfEncryptionContextEqualsPairs(pairs: ESDKCanonicalEncryptionContext, ec: MPL.EncryptionContext)
    requires ec == GetEncryptionContext(pairs)
    ensures |ec| == |pairs|
    ensures forall k: ValidUTF8Bytes {:trigger ec[k]} {:trigger k in ec} | k in ec :: Pair(k, ec[k]) in pairs
    ensures forall p: ESDKEncryptionContextPair {:trigger p.value} {:trigger p.key} {:trigger p in pairs} | p in pairs :: p.key in ec && p.value == ec[p.key]
    decreases pairs, ec
  {
    if |pairs| == 0 {
    } else {
      ghost var front := Seq.DropLast(pairs);
      ghost var tail := Seq.Last(pairs);
      ghost var ecOfFront := GetEncryptionContext(front);
      assert pairs == front + [tail];
      assert ec.Keys == ecOfFront.Keys + {tail.key};
      assert |ecOfFront.Keys| == |ecOfFront|;
      LemmaCardinalityOfEncryptionContextEqualsPairs(front, ecOfFront);
    }
  }

  lemma {:vcs_split_on_every_assert} /*{:_inductionTrigger LinearLength(pairs2), LinearLength(pairs1)}*/ /*{:_inductionTrigger LinearLength(pairs2), KeysAreUnique(pairs1)}*/ /*{:_inductionTrigger LinearLength(pairs2), |pairs1|}*/ /*{:_inductionTrigger LinearLength(pairs1), KeysAreUnique(pairs2)}*/ /*{:_inductionTrigger LinearLength(pairs1), |pairs2|}*/ /*{:_inductionTrigger KeysAreUnique(pairs2), KeysAreUnique(pairs1)}*/ /*{:_inductionTrigger KeysAreUnique(pairs2), |pairs1|}*/ /*{:_inductionTrigger KeysAreUnique(pairs1), |pairs2|}*/ /*{:_inductionTrigger |pairs2|, |pairs1|}*/ /*{:_induction pairs1, pairs2}*/ LinearLengthOfUniquePairsIsOrderIndependent(pairs1: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>, pairs2: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    requires forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in pairs2} {:trigger p in pairs1} | p in pairs1 :: p in pairs2
    requires forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in pairs1} {:trigger p in pairs2} | p in pairs2 :: p in pairs1
    requires |pairs1| == |pairs2|
    requires KeysAreUnique(pairs1) && KeysAreUnique(pairs2)
    ensures LinearLength(pairs1) == LinearLength(pairs2)
    decreases pairs1, pairs2
  {
    if |pairs1| == 0 || |pairs2| == 0 {
      assert LinearLength(pairs1) == 0;
    } else {
      ghost var tail := Seq.Last(pairs1);
      assert tail in pairs1;
      ghost var i := Seq.IndexOf(pairs2, tail);
      ghost var pairs1WithoutTail := RemoveValue<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>(pairs1, tail);
      ghost var pairs2WithoutTail := RemoveValue<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>(pairs2, tail);
      assert pairs1WithoutTail == Seq.DropLast(pairs1);
      assert pairs2WithoutTail == pairs2[..i] + Seq.DropFirst(pairs2[i..]);
      LinearLengthOfUniquePairsIsOrderIndependent(pairs1WithoutTail, pairs2WithoutTail);
      calc {
        LinearLength(pairs1);
      ==
        LinearLength(pairs1WithoutTail + [tail]);
      ==
        {
          LinearLengthIsDistributive(pairs1WithoutTail, [tail]);
        }
        LinearLength(pairs1WithoutTail) + LinearLength([tail]);
      ==
        LinearLength(pairs2WithoutTail) + LinearLength([tail]);
      ==
        {
          assert pairs2WithoutTail == pairs2[..i] + Seq.DropFirst(pairs2[i..]);
        }
        LinearLength(pairs2[..i] + Seq.DropFirst(pairs2[i..])) + LinearLength([tail]);
      ==
        {
          LinearLengthIsDistributive(pairs2[..i], Seq.DropFirst(pairs2[i..]));
        }
        LinearLength(pairs2[..i]) + LinearLength(Seq.DropFirst(pairs2[i..])) + LinearLength([tail]);
      ==
        LinearLength(pairs2[..i]) + LinearLength([tail]) + LinearLength(Seq.DropFirst(pairs2[i..]));
      ==
        {
          LinearLengthIsDistributive([tail], Seq.DropFirst(pairs2[i..]));
        }
        LinearLength(pairs2[..i]) + LinearLength([tail] + Seq.DropFirst(pairs2[i..]));
      ==
        {
          assert pairs2[i..] == [pairs2[i]] + Seq.DropFirst(pairs2[i..]);
        }
        LinearLength(pairs2[..i]) + LinearLength(pairs2[i..]);
      ==
        {
          LinearLengthIsDistributive(pairs2[..i], pairs2[i..]);
        }
        LinearLength(pairs2[..i] + pairs2[i..]);
      ==
        {
          Seq.LemmaSplitAt(pairs2, i);
        }
        LinearLength(pairs2);
      }
    }
  }

  lemma {:vcs_split_on_every_assert} /*{:_inductionTrigger LinearLength(pairs)}*/ /*{:_inductionTrigger GetEncryptionContext(pairs)}*/ /*{:_induction pairs}*/ LemmaLengthOfPairsEqualsEncryptionContext(pairs: ESDKCanonicalEncryptionContext, ec: MPL.EncryptionContext)
    requires ec == GetEncryptionContext(pairs)
    ensures LinearLength(pairs) == Length(ec)
    decreases pairs, ec
  {
    ghost var canonicalPairs := GetCanonicalLinearPairs(ec);
    AllKeysAreInCanonicalLinearPairs(ec, canonicalPairs);
    LemmaCardinalityOfEncryptionContextEqualsPairs(pairs, ec);
    LinearLengthOfUniquePairsIsOrderIndependent(pairs, canonicalPairs);
  }

  lemma AllKeysAreInCanonicalLinearPairs(encryptionContext: MPL.EncryptionContext, pairs: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    requires pairs == GetCanonicalLinearPairs(encryptionContext)
    ensures forall k: UTF8.ValidUTF8Bytes {:trigger encryptionContext[k]} {:trigger k in encryptionContext} | k in encryptionContext :: Pair(k, encryptionContext[k]) in pairs
    ensures forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p.value} {:trigger p.key} {:trigger p in pairs} | p in pairs :: p.key in encryptionContext && p.value == encryptionContext[p.key]
    ensures KeysAreUnique(pairs)
    decreases encryptionContext, pairs
  {
    if exists p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p.value} {:trigger p.key} {:trigger p in pairs} :: p !in pairs && p.key in encryptionContext && p.value == encryptionContext[p.key] {
      ghost var p :| p !in pairs && p.key in encryptionContext && p.value == encryptionContext[p.key];
      ghost var keys := SortedSets.ComputeSetToOrderedSequence2(encryptionContext.Keys, UInt.UInt8Less);
      ghost var i :| 0 <= i < |keys| && keys[i] == p.key;
      assert pairs[i] == p;
    }
  }

  lemma {:vcs_split_on_every_assert} LemmaESDKCanonicalEncryptionContextIsESDKEncryptionContext(pairs: ESDKCanonicalEncryptionContext, ec: MPL.EncryptionContext)
    requires ec == GetEncryptionContext(pairs)
    ensures IsESDKEncryptionContext(ec)
    decreases pairs, ec
  {
    LemmaCardinalityOfEncryptionContextEqualsPairs(pairs, ec);
    LemmaLengthOfPairsEqualsEncryptionContext(pairs, ec);
    assert IsESDKEncryptionContext(ec) by {
      assert |ec| == |pairs| < UINT16_LIMIT by {
        assert HasUint16Len(pairs);
      }
      assert Length(ec) == LinearLength(pairs) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH;
      forall element: ValidUTF8Bytes | element in ec.Keys + ec.Values
        ensures HasUint16Len(element) && ValidUTF8Seq(element)
      {
        assert element in (set p: ESDKEncryptionContextPair {:trigger p.key} {:trigger p in pairs} | p in pairs :: p.key) + set p: ESDKEncryptionContextPair {:trigger p.value} {:trigger p in pairs} | p in pairs :: p.value;
      }
    }
  }

  lemma {:vcs_split_on_every_assert} SubsetOfESDKEncryptionContextIsESDKEncryptionContext(ec: MPL.EncryptionContext, subEC: MPL.EncryptionContext)
    requires IsESDKEncryptionContext(ec)
    requires subEC.Keys <= ec.Keys
    requires forall k: seq<BoundedInts.uint8> {:trigger subEC[k]} {:trigger ec[k]} {:trigger k in subEC.Keys} | k in subEC.Keys :: ec[k] == subEC[k]
    ensures IsESDKEncryptionContext(subEC)
    decreases ec, subEC
  {
    ghost var complement := Complement(ec, subEC);
    calc {
      Add(Length(complement), Length(subEC));
    ==
      Add(LinearLength(GetCanonicalLinearPairs(complement)), LinearLength(GetCanonicalLinearPairs(subEC)));
    ==
      {
        LinearLengthIsDistributive(GetCanonicalLinearPairs(complement), GetCanonicalLinearPairs(subEC));
      }
      LinearLength(GetCanonicalLinearPairs(complement) + GetCanonicalLinearPairs(subEC));
    ==
      {
        ghost var pairs1 := GetCanonicalLinearPairs(complement + subEC);
        ghost var pairs2 := GetCanonicalLinearPairs(complement) + GetCanonicalLinearPairs(subEC);
        GetCanonicalLinearPairsIsBijective(complement + subEC, pairs1);
        GetCanonicalLinearPairsIsBijective(complement, GetCanonicalLinearPairs(complement));
        GetCanonicalLinearPairsIsBijective(subEC, GetCanonicalLinearPairs(subEC));
        assert forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in pairs2} {:trigger p in pairs1} | p in pairs1 :: p in pairs2;
        assert forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in pairs1} {:trigger p in pairs2} | p in pairs2 :: p in pairs1 by {
          forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> | p in pairs2
            ensures p in pairs1
          {
            calc ==> {
              p in pairs2;
            ==>
              p in GetCanonicalLinearPairs(complement) + GetCanonicalLinearPairs(subEC);
            ==>
              {
                assert forall p': Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p' in GetCanonicalLinearPairs(complement + subEC)} {:trigger p' in GetCanonicalLinearPairs(complement)} | p' in GetCanonicalLinearPairs(complement) :: p' in GetCanonicalLinearPairs(complement + subEC);
                assert forall p': Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p' in GetCanonicalLinearPairs(complement + subEC)} {:trigger p' in GetCanonicalLinearPairs(subEC)} | p' in GetCanonicalLinearPairs(subEC) :: p' in GetCanonicalLinearPairs(complement + subEC);
              }
              p in GetCanonicalLinearPairs(complement + subEC);
            ==>
              p in pairs1;
            }
          }
        }
        LinearLengthOfUniquePairsIsOrderIndependent(pairs1, pairs2);
      }
      LinearLength(GetCanonicalLinearPairs(complement + subEC));
    ==
      Length(complement + subEC);
    ==
      {
        assert ec == complement + subEC;
      }
      Length(ec);
    }
    assert Length(subEC) <= Length(ec);
  }

  function method WriteAADSection(ec: ESDKCanonicalEncryptionContext): (ret: seq<uint8>)
    ensures if |ec| == 0 then ret == WriteUint16(|ec| as uint16) else true && var aad: seq<uint8> := WriteAAD(ec); true && ret == WriteUint16(|aad| as uint16) + aad
    decreases ec
  {
    SequenceIsSafeBecauseItIsInMemory(ec);
    if |ec| as uint64 == 0 then
      WriteUint16(0)
    else
      var aad: seq<uint8> := WriteAAD(ec); WriteUint16(|aad| as uint16) + aad
  }

  function method WriteEmptyEcOrWriteAAD(ec: ESDKCanonicalEncryptionContext): (ret: seq<uint8>)
    ensures HasUint16Len(ret)
    decreases ec
  {
    SequenceIsSafeBecauseItIsInMemory(ec);
    if |ec| as uint64 == 0 then
      []
    else
      WriteAAD(ec)
  }

  lemma WriteEmptyEcOrWriteAADIsCorrect(ec: ESDKCanonicalEncryptionContext)
    ensures WriteEmptyEcOrWriteAAD(ec) == WriteAADSection(ec)[2..]
    decreases ec
  {
  }

  function method WriteAAD(ec: ESDKCanonicalEncryptionContext): (ret: seq<uint8>)
    ensures HasUint16Len(ret)
    ensures |ec| == 0 ==> ret == WriteUint16(0)
    decreases ec
  {
    WriteUint16(|ec| as uint16) + WriteAADPairs(ec)
  }

  function WriteAADPairs(ec: ESDKCanonicalEncryptionContext): (ret: seq<uint8>)
    ensures |ec| == 0 ==> LinearLength(ec) as nat == |ret| && ret == []
    ensures |ec| != 0 ==> LinearLength(Seq.DropLast(ec)) as nat + PairLength(Seq.Last(ec)) as nat == |ret| && WriteAADPairs(Seq.DropLast(ec)) + WriteAADPair(Seq.Last(ec)) == ret
    ensures |ret| < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH as nat
    decreases ec
  {
    if |ec| == 0 then
      []
    else
      assert LinearLength(Seq.DropLast(ec)) < LinearLength(ec); WriteAADPairs(Seq.DropLast(ec)) + WriteAADPair(Seq.Last(ec))
  } by method {
    var result: seq<uint8> := [];
    SequenceIsSafeBecauseItIsInMemory(ec);
    for i: uint64 := 0 to |ec| as uint64
      invariant ESDKCanonicalEncryptionContext?(ec)
      invariant ESDKCanonicalEncryptionContext?(ec[..i])
      invariant result == WriteAADPairs(ec[..i])
    {
      result := result + WriteAADPair(ec[i]);
      ESDKCanonicalEncryptionContextCanBeSplit(ec);
      assert result == WriteAADPairs(ec[..i]) + WriteAADPair(ec[i]);
      assert Seq.DropLast(ec[..i + 1]) == ec[..i];
      assert result == WriteAADPairs(Seq.DropLast(ec[..i + 1])) + WriteAADPair(Seq.Last(ec[..i + 1]));
      assert ESDKCanonicalEncryptionContext?(ec[..i]);
      assert ESDKCanonicalEncryptionContext?(ec[..i + 1]);
      assert result == WriteAADPairs(ec[..i + 1]);
    }
    assert result == WriteAADPairs(ec[..|ec|]);
    assert ec == ec[..|ec|];
    assert result == WriteAADPairs(ec);
    return result;
  }

  function method WriteAADPair(pair: ESDKEncryptionContextPair): (ret: seq<uint8>)
    ensures PairLength(pair) as nat == |ret|
    decreases pair
  {
    WriteShortLengthSeq(pair.key) + WriteShortLengthSeq(pair.value)
  }

  function method ReadAADPair(buffer: ReadableBuffer): (res: ReadCorrect<ESDKEncryptionContextPair>)
    ensures CorrectlyRead(buffer, res, WriteAADPair)
    ensures res.Success? ==> res.value.tail.start >= buffer.start && PairLength(res.value.data) == res.value.tail.start - buffer.start
    decreases buffer
  {
    var SuccessfulRead(key: Uint8Seq16, keyEnd: ReadableBuffer) :- ReadShortLengthSeq(buffer); :- Need(ValidUTF8Seq(key), Error("Invalid Encryption Context key")); var SuccessfulRead(value: Uint8Seq16, tail: ReadableBuffer) :- ReadShortLengthSeq(keyEnd); :- Need(ValidUTF8Seq(value), Error("Invalid Encryption Context value")); var pair: ESDKEncryptionContextPair := Pair(key, value); assert CorrectlyReadRange(buffer, tail, WriteAADPair(pair)) by {
    reveal CorrectlyReadRange();
  } assert PairLength(pair) == tail.start - buffer.start by {
    reveal CorrectlyReadRange();
  } Success(SuccessfulRead(pair, tail))
  }

  function method {:tailrecursion} {:vcs_split_on_every_assert} ReadAADPairs(buffer: ReadableBuffer, accumulator: ESDKCanonicalEncryptionContext, keys: set<UTF8.ValidUTF8Bytes>, count: uint16, nextPair: ReadableBuffer): (res: ReadCorrect<ESDKCanonicalEncryptionContext>)
    requires 0 <= |accumulator| <= count as nat < UINT16_LIMIT
    requires CorrectlyReadRange(buffer, nextPair, WriteAADPairs(accumulator))
    requires KeysToSet(accumulator) == keys
    ensures res.Success? ==> count as nat == |res.value.data|
    ensures CorrectlyRead(buffer, res, WriteAADPairs)
    decreases count as int - |accumulator|
  {
    if count > |accumulator| as uint16 then
      var SuccessfulRead(pair: ESDKEncryptionContextPair, newPos: ReadableBuffer) :- ReadAADPair(nextPair); :- Need(pair.key !in keys, Error("Duplicate Encryption Context key value.")); :- Need(newPos.start >= buffer.start && newPos.start - buffer.start < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH, Error("Encryption Context exceeds maximum length.")); var nextAcc: seq<ESDKEncryptionContextPair> := accumulator + [pair]; assert KeysToSet(nextAcc) == keys + KeysToSet([pair]) by {
    reveal KeysToSet();
  } var nextKeys: set<UTF8.ValidUTF8Bytes> := keys + KeysToSet([pair]); assert LinearLength(nextAcc) == LinearLength(accumulator) + PairLength(pair); assert KeysAreUnique(nextAcc) by {
    reveal KeysToSet();
  } assert ESDKCanonicalEncryptionContext?(nextAcc) by {
    assert LinearLength(accumulator) as nat == |WriteAADPairs(accumulator)|;
    assert nextPair.start as nat == buffer.start as nat + |WriteAADPairs(accumulator)| by {
      reveal CorrectlyReadRange();
    }
    assert LinearLength(accumulator) == nextPair.start - buffer.start;
  } CorrectlyReadByteRange(buffer, nextPair, WriteAADPairs(accumulator)); AppendToCorrectlyReadByteRange(buffer, nextPair, newPos, WriteAADPair(pair)); ReadAADPairs(buffer, nextAcc, nextKeys, count, newPos)
    else
      assert CorrectlyRead(buffer, Success(SuccessfulRead(accumulator, nextPair)), WriteAADPairs); Success(SuccessfulRead(accumulator, nextPair))
  }

  function method ReadAAD(buffer: ReadableBuffer): (res: ReadCorrect<ESDKCanonicalEncryptionContext>)
    ensures CorrectlyRead(buffer, res, WriteAAD)
    decreases buffer
  {
    reveal CorrectlyReadRange();
    var SuccessfulRead(count: uint16, ecPos: ReadableBuffer) :- ReadUInt16(buffer); if count == 0 then var edks: ESDKCanonicalEncryptionContext := []; assert CorrectlyRead(buffer, Success(SuccessfulRead(edks, ecPos)), WriteAAD); Success(SuccessfulRead(edks, ecPos)) else var accumulator: seq<ESDKEncryptionContextPair> := []; var keys: set<UTF8.ValidUTF8Bytes> := KeysToSet(accumulator); var SuccessfulRead(pairs: ESDKCanonicalEncryptionContext, tail: ReadableBuffer) :- ReadAADPairs(ecPos, accumulator, keys, count, ecPos); Success(SuccessfulRead(pairs, tail))
  }

  opaque function method {:vcs_split_on_every_assert} ReadAADSection(buffer: ReadableBuffer): (res: ReadCorrect<ESDKCanonicalEncryptionContext>)
    ensures if IsExpandedAADSection(buffer) then CorrectlyRead(buffer, res, WriteExpandedAADSection) else CorrectlyRead(buffer, res, WriteAADSection)
    decreases buffer
  {
    var length: SuccessfulRead<uint16> :- ReadUInt16(buffer); CorrectlyReadByteRange(buffer, length.tail, WriteUint16(length.data)); if length.data == 0 then var empty: ESDKCanonicalEncryptionContext := []; assert CorrectlyReadRange(buffer, length.tail, WriteAADSection(empty)); assert !IsExpandedAADSection(buffer); assert CorrectlyReadRange(buffer, length.tail, WriteAADSection(empty)); Success(SuccessfulRead(empty, length.tail)) else SequenceIsSafeBecauseItIsInMemory(length.tail.bytes); :- Need(Add(length.tail.start, length.data as uint64) <= |length.tail.bytes| as uint64, MoreNeeded(Add(length.tail.start, length.data as uint64))); var verifyCount: SuccessfulRead<uint16> :- ReadUInt16(length.tail); AppendToCorrectlyReadByteRange(buffer, length.tail, verifyCount.tail, WriteUint16(verifyCount.data)); if length.data == 2 then :- Need(verifyCount.data == 0, Error("Encryption Context pairs count can not exceed byte length")); var empty: ESDKCanonicalEncryptionContext := []; assert IsExpandedAADSection(buffer) by {
    reveal CorrectlyReadRange();
    reveal ReadUInt16();
  } Success(SuccessfulRead(empty, verifyCount.tail)) else :- Need(0 < verifyCount.data, Error("Encryption Context byte length exceeds pairs count.")); var aad: SuccessfulRead<ESDKCanonicalEncryptionContext> :- ReadAAD(length.tail); :- Need(aad.tail.start >= length.tail.start && aad.tail.start - length.tail.start == length.data as uint64, Error("AAD Length did not match stored length.")); assert !IsExpandedAADSection(buffer); AppendToCorrectlyReadByteRange(buffer, length.tail, aad.tail, WriteAAD(aad.data)); assert |WriteAAD(aad.data)| as uint16 == length.data; assert WriteAADSection(aad.data) == WriteUint16(|WriteAAD(aad.data)| as uint16) + WriteAAD(aad.data); CorrectlyReadByteRange(buffer, aad.tail, WriteAADSection(aad.data)); Success(aad)
  }

  opaque function method KeysToSet<K(==), V(==)>(pairs: Linear<K, V>): set<K>
    decreases pairs
  {
    set p: Pair<K, V> {:trigger p.key} {:trigger p in pairs} | p in pairs :: p.key
  }

  predicate IsExpandedAADSection(buffer: ReadableBuffer)
    decreases buffer
  {
    reveal CorrectlyReadRange();
    reveal ReadUInt16();
    buffer.start as nat + 2 <= |buffer.bytes| &&
    ghost var sectionLength: SuccessfulRead<uint16> := ReadUInt16(buffer).value; sectionLength.data == 2 && sectionLength.tail.start as nat + 2 <= |buffer.bytes| && ReadUInt16(sectionLength.tail).value.data == 0
  }

  function WriteExpandedAADSection(ec: ESDKCanonicalEncryptionContext): (ret: seq<uint8>)
    ensures if |ec| == 0 then ret == [0, 2, 0, 0] else true && ghost var aad: seq<uint8> := WriteAAD(ec); true && ret == UInt16ToSeq(|aad| as uint16) + aad
    decreases ec
  {
    ghost var aad: seq<uint8> := WriteAAD(ec);
    UInt16ToSeq(|aad| as uint16) + aad
  }

  lemma ReadAADPairIsComplete(data: ESDKEncryptionContextPair, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<ESDKEncryptionContextPair>)
    requires WriteAADPair(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadAADPair(buffer)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    assert bytes == WriteShortLengthSeq(data.key) + WriteShortLengthSeq(data.value);
    assert bytes[..|WriteShortLengthSeq(data.key)|] == WriteShortLengthSeq(data.key);
    ghost var key := ReadShortLengthSeqIsComplete(data.key, WriteShortLengthSeq(data.key), buffer);
    assert key.data == data.key;
    ghost var value := ReadShortLengthSeqIsComplete(data.value, WriteShortLengthSeq(data.value), key.tail);
    assert value.data == data.value;
    return ReadAADPair(buffer).value;
  }

  lemma ESDKCanonicalEncryptionContextCanBeSplit(data: ESDKCanonicalEncryptionContext)
    ensures (forall accumulator: seq<ESDKEncryptionContextPair> {:trigger ESDKCanonicalEncryptionContext?(accumulator)} | accumulator <= data :: ESDKCanonicalEncryptionContext?(accumulator)) && forall accumulator: seq<ESDKEncryptionContextPair> {:trigger |accumulator|} | accumulator <= data :: ESDKCanonicalEncryptionContext?(data[|accumulator|..])
    decreases data
  {
    forall accumulator: seq<ESDKEncryptionContextPair> | accumulator <= data
      ensures ESDKCanonicalEncryptionContext?(accumulator) && ESDKCanonicalEncryptionContext?(data[|accumulator|..])
    {
      assert |accumulator| <= |data|;
      assert |data[|accumulator|..]| <= |data|;
      assert KeysAreUnique(accumulator);
      assert KeysAreUnique(data[|accumulator|..]);
      assert data == accumulator + data[|accumulator|..];
      LinearLengthIsDistributive(accumulator, data[|accumulator|..]);
      assert LinearLength(data) == LinearLength(accumulator) + LinearLength(data[|accumulator|..]);
    }
  }

  lemma {:vcs_split_on_every_assert} /*{:_inductionTrigger WriteAADPairs(a) + WriteAADPairs(b)}*/ /*{:_inductionTrigger WriteAADPairs(a + b)}*/ /*{:_inductionTrigger ESDKCanonicalEncryptionContext?(a + b)}*/ /*{:_induction a, b}*/ WriteAADPairsIsDistributive(a: ESDKCanonicalEncryptionContext, b: ESDKCanonicalEncryptionContext)
    requires ESDKCanonicalEncryptionContext?(a + b)
    ensures WriteAADPairs(a + b) == WriteAADPairs(a) + WriteAADPairs(b)
    decreases a, b
  {
    if b == [] {
      assert a + b == a;
    } else {
      calc {
        WriteAADPairs(a + b);
      ==
        if |a + b| == 0 then [] else WriteAADPairs(Seq.DropLast(a + b)) + WriteAADPair(Seq.Last(a + b));
      ==
        {
          assert |a + b| > 0;
        }
        WriteAADPairs(Seq.DropLast(a + b)) + WriteAADPair(Seq.Last(a + b));
      ==
        {
          assert Seq.Last(a + b) == Seq.Last(b) && Seq.DropLast(a + b) == a + Seq.DropLast(b);
        }
        WriteAADPairs(a + Seq.DropLast(b)) + WriteAADPair(Seq.Last(b));
      ==
        {
          WriteAADPairsIsDistributive(a, Seq.DropLast(b));
        }
        WriteAADPairs(a) + WriteAADPairs(Seq.DropLast(b)) + WriteAADPair(Seq.Last(b));
      ==
        WriteAADPairs(a) + (WriteAADPairs(Seq.DropLast(b)) + WriteAADPair(Seq.Last(b)));
      ==
        {
          assert WriteAADPairs(Seq.DropLast(b)) + WriteAADPair(Seq.Last(b)) == WriteAADPairs(b);
        }
        WriteAADPairs(a) + WriteAADPairs(b);
      }
    }
  }

  lemma {:vcs_split_on_every_assert} ReadAADPairsIsComplete(data: ESDKCanonicalEncryptionContext, accumulator: ESDKCanonicalEncryptionContext, keys: set<UTF8.ValidUTF8Bytes>, bytes: seq<uint8>, buffer: ReadableBuffer, accumulatorPairsRead: ReadableBuffer)
      returns (ret: SuccessfulRead<ESDKCanonicalEncryptionContext>)
    requires accumulator <= data
    requires KeysToSet(accumulator) == keys
    requires HasUint16Len(data)
    requires WriteAADPairs(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes) && CorrectlyReadRange(buffer, accumulatorPairsRead, WriteAADPairs(accumulator))
    ensures ret.data == data && Success(ret) == ReadAADPairs(buffer, accumulator, keys, |data| as uint16, accumulatorPairsRead)
    decreases |data| - |accumulator|
  {
    if data == accumulator {
      ret := ReadAADPairs(buffer, accumulator, keys, |data| as uint16, accumulatorPairsRead).value;
    } else {
      assert accumulator < data;
      assert CorrectlyReadableByteRange?(accumulatorPairsRead, WriteAADPair(data[|accumulator|])) by {
        ESDKCanonicalEncryptionContextCanBeSplit(data);
        ghost var nextAccumulator := data[..|accumulator| + 1];
        assert ESDKCanonicalEncryptionContext?(nextAccumulator);
        assert ESDKCanonicalEncryptionContext?(data[|nextAccumulator|..]);
        calc {
          bytes;
        ==
          WriteAADPairs(data);
        ==
          {
            LemmaSplitAtInclusive(data, |accumulator| + 1);
          }
          WriteAADPairs(nextAccumulator + data[|nextAccumulator|..]);
        ==
          {
            WriteAADPairsIsDistributive(nextAccumulator, data[|nextAccumulator|..]);
          }
          WriteAADPairs(nextAccumulator) + WriteAADPairs(data[|nextAccumulator|..]);
        ==
          {
            assert WriteAADPairs(Seq.DropLast(nextAccumulator)) + WriteAADPair(Seq.Last(nextAccumulator)) == WriteAADPairs(nextAccumulator);
          }
          WriteAADPairs(Seq.DropLast(nextAccumulator)) + WriteAADPair(Seq.Last(nextAccumulator)) + WriteAADPairs(data[|nextAccumulator|..]);
        ==
          {
            assert Seq.DropLast(nextAccumulator) == accumulator && WriteAADPairs(Seq.DropLast(nextAccumulator)) == WriteAADPairs(accumulator);
          }
          WriteAADPairs(accumulator) + WriteAADPair(Seq.Last(nextAccumulator)) + WriteAADPairs(data[|nextAccumulator|..]);
        ==
          {
            assert Seq.Last(nextAccumulator) == data[|accumulator|];
          }
          WriteAADPairs(accumulator) + WriteAADPair(data[|accumulator|]) + WriteAADPairs(data[|nextAccumulator|..]);
        }
        CorrectlyReadByteRange(buffer, accumulatorPairsRead, WriteAADPairs(accumulator));
        AdvanceCorrectlyReadableByteRange?(buffer, bytes, accumulatorPairsRead, WriteAADPair(data[|accumulator|]));
      }
      ghost var pair := ReadAADPairIsComplete(data[|accumulator|], WriteAADPair(data[|accumulator|]), accumulatorPairsRead);
      assert KeysToSet(accumulator + [pair.data]) == keys + KeysToSet([pair.data]) && pair.data.key !in keys && accumulator + [pair.data] <= data by {
        reveal KeysToSet();
        assert pair.data == data[|accumulator|];
        assert pair.data.key !in keys;
        assert pair.data in data;
        assert accumulator + [data[|accumulator|]] + data[|accumulator| + 1..] == data;
        assert accumulator + [data[|accumulator|]] + data[|accumulator| + 1..] == data;
        assert accumulator + [data[|accumulator|]] <= data;
      }
      assert ESDKCanonicalEncryptionContext?(accumulator + [pair.data]) by {
        assert accumulator + [pair.data] <= data by {
          assert accumulator < data;
          assert pair.data == data[|accumulator|];
        }
        assert LinearLength(accumulator + [pair.data]) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH by {
          assert LinearLength(data) < ESDK_CANONICAL_ENCRYPTION_CONTEXT_MAX_LENGTH;
          calc {
            LinearLength(data);
          ==
            {
              assert data == accumulator + [pair.data] + data[|accumulator + [pair.data]|..];
            }
            LinearLength(accumulator + [pair.data] + data[|accumulator + [pair.data]|..]);
          ==
            {
              LinearLengthIsDistributive(accumulator + [pair.data], data[|accumulator + [pair.data]|..]);
            }
            LinearLength(accumulator + [pair.data]) + LinearLength(data[|accumulator + [pair.data]|..]);
          }
        }
        assert HasUint16Len(accumulator + [pair.data]) by {
          assert HasUint16Len(data);
          assert accumulator + [pair.data] <= data;
        }
      }
      assert CorrectlyReadRange(buffer, pair.tail, WriteAADPairs(accumulator + [pair.data])) by {
        assert WriteAADPairs(accumulator + [pair.data]) == WriteAADPairs(accumulator) + WriteAADPair(pair.data);
        CorrectlyReadByteRange(buffer, accumulatorPairsRead, WriteAADPairs(accumulator));
        AppendToCorrectlyReadByteRange(buffer, accumulatorPairsRead, pair.tail, WriteAADPair(pair.data));
      }
      ret := ReadAADPairsIsComplete(data, accumulator + [pair.data], keys + KeysToSet([pair.data]), bytes, buffer, pair.tail);
      assert Success(ret) == ReadAADPairs(buffer, accumulator, keys, |data| as uint16, accumulatorPairsRead) by {
        reveal CorrectlyReadRange();
        assert ret.data == data;
      }
    }
  }

  lemma {:vcs_split_on_every_assert} ReadAADIsComplete(data: ESDKCanonicalEncryptionContext, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<ESDKCanonicalEncryptionContext>)
    requires WriteAAD(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadAAD(buffer)
    decreases data, bytes, buffer
  {
    assert WriteUint16(|data| as uint16) + WriteAADPairs(data) == bytes;
    assert bytes[|WriteUint16(|data| as uint16)|..] == WriteAADPairs(data);
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, buffer, WriteUint16(|data| as uint16));
    ghost var count := ReadUInt16IsComplete(|data| as uint16, WriteUint16(|data| as uint16), buffer);
    assert count.data as nat == |data|;
    ghost var accumulator: ESDKCanonicalEncryptionContext := [];
    CorrectlyReadByteRange(buffer, count.tail, WriteUint16(count.data));
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, count.tail, WriteAADPairs(data));
    assert CorrectlyReadRange(count.tail, count.tail, WriteAADPairs(accumulator)) by {
      assert count.tail.bytes[count.tail.start .. count.tail.start] == WriteAADPairs(accumulator);
    }
    ghost var pairs := ReadAADPairsIsComplete(data, accumulator, KeysToSet(accumulator), WriteAADPairs(data), count.tail, count.tail);
    assert pairs.data == data;
    return ReadAAD(buffer).value;
  }

  lemma {:vcs_split_on_every_assert} ReadAADSectionIsComplete(data: ESDKCanonicalEncryptionContext, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<ESDKCanonicalEncryptionContext>)
    requires WriteAADSection(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadAADSection(buffer)
    decreases data, bytes, buffer
  {
    assert 2 <= |bytes|;
    if 0 == |data| {
      assert WriteAADSection(data) == WriteUint16(0);
      ghost var _ /* _v0 */ := ReadUInt16IsComplete(0, bytes, buffer);
      reveal ReadAADSection();
      ret := ReadAADSection(buffer).value;
    } else {
      assert WriteUint16(|WriteAAD(data)| as uint16) + WriteAAD(data) == bytes;
      assert 0 < |data|;
      AdvanceCorrectlyReadableByteRange?(buffer, bytes, buffer, WriteUint16(|WriteAAD(data)| as uint16));
      ghost var length := ReadUInt16IsComplete(|WriteAAD(data)| as uint16, WriteUint16(|WriteAAD(data)| as uint16), buffer);
      CorrectlyReadByteRange(buffer, length.tail, WriteUint16(length.data));
      AdvanceCorrectlyReadableByteRange?(buffer, bytes, length.tail, WriteAAD(data));
      assert length.data == |WriteAAD(data)| as uint16;
      assert length.tail.start as nat + length.data as nat <= |length.tail.bytes|;
      assert !IsExpandedAADSection(buffer);
      ghost var aad := ReadAADIsComplete(data, WriteAAD(data), length.tail);
      reveal ReadAADSection();
      reveal CorrectlyReadRange();
      ret := ReadAADSection(buffer).value;
      assert aad.data == data;
      assert ret.data == aad.data;
    }
  }

  lemma LemmaSplitAtInclusive<T>(xs: seq<T>, pos: nat)
    requires pos <= |xs|
    ensures xs[..pos] + xs[pos..] == xs
    decreases xs, pos
  {
  }

  function RemoveValue<K, V>(xs: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>, value: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>): (ys: Linear<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>)
    ensures KeysAreUnique(xs) ==> KeysAreUnique(ys)
    ensures forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in xs} {:trigger p in ys} | p in ys :: p in xs
    ensures forall p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes> {:trigger p in ys} {:trigger p in xs} | p in xs && p != value :: p in ys
    decreases xs, value
  {
    if value !in xs then
      xs
    else
      ghost var i: nat := Seq.IndexOf(xs, value); assert xs == xs[..i] + [value] + xs[i + 1..]; xs[..i] + xs[i + 1..]
  }

  function Complement<X, Y>(universal: map<X, Y>, subset: map<X, Y>): (complement: map<X, Y>)
    requires subset.Keys <= universal.Keys
    requires forall k: X {:trigger subset[k]} {:trigger universal[k]} {:trigger k in subset.Keys} | k in subset.Keys :: universal[k] == subset[k]
    ensures complement + subset == universal
    decreases universal, subset
  {
    map k: X {:trigger universal[k]} {:trigger k in subset} {:trigger k in universal.Keys} | k in universal.Keys && k !in subset :: k := universal[k]
  }

  import Seq

  import StandardLibrary

  import opened SerializableTypes

  import MPL = AwsCryptographyMaterialProvidersTypes

  import opened UInt = StandardLibrary.UInt

  import opened Wrappers

  import opened UTF8

  import opened SerializeFunctions

  import opened MemoryMath = StandardLibrary.MemoryMath

  type ESDKEncryptionContextPair = p: Pair<UTF8.ValidUTF8Bytes, UTF8.ValidUTF8Bytes>
    | HasUint16Len(p.key) && ValidUTF8Seq(p.key) && HasUint16Len(p.value) && ValidUTF8Seq(p.value)
    witness *

  type ESDKCanonicalEncryptionContext = pairs: seq<ESDKEncryptionContextPair>
    | ESDKCanonicalEncryptionContext?(pairs)
    witness *
}

module {:options "/functionSyntax:4"} SerializeFunctions {
  predicate CorrectlyRead<T>(buffer: ReadableBuffer, res: ReadCorrect<T>, inversionFunction: T -> seq<uint8>)
    decreases buffer, res
  {
    res.Success? ==>
      CorrectlyReadRange(buffer, res.value.tail, inversionFunction(res.value.data))
  }

  opaque predicate CorrectlyReadRange(buffer: ReadableBuffer, tail: ReadableBuffer, readRange: seq<uint8>)
    decreases buffer, tail, readRange
  {
    buffer.bytes == tail.bytes &&
    buffer.start as nat <= tail.start as nat <= |buffer.bytes| &&
    buffer.bytes[buffer.start..] == tail.bytes[buffer.start..] &&
    readRange <= buffer.bytes[buffer.start..] &&
    tail.start as nat == buffer.start as nat + |readRange|
  }

  lemma CorrectlyReadByteRange(buffer: ReadableBuffer, tail: ReadableBuffer, readRange: seq<uint8>)
    requires CorrectlyReadRange(buffer, tail, readRange)
    ensures buffer.start as nat <= tail.start as nat <= |buffer.bytes|
    ensures CorrectlyReadRange(buffer, tail, buffer.bytes[buffer.start .. tail.start])
    ensures buffer.bytes[buffer.start .. tail.start] == readRange
    decreases buffer, tail, readRange
  {
    reveal CorrectlyReadRange();
  }

  lemma AppendToCorrectlyReadByteRange(buffer: ReadableBuffer, verifiedTail: ReadableBuffer, tail: ReadableBuffer, readRange: seq<uint8>)
    requires buffer.start as nat <= verifiedTail.start as nat <= |buffer.bytes|
    requires CorrectlyReadRange(buffer, verifiedTail, buffer.bytes[buffer.start .. verifiedTail.start])
    requires CorrectlyReadRange(verifiedTail, tail, readRange)
    ensures buffer.start as nat <= tail.start as nat <= |buffer.bytes|
    ensures CorrectlyReadRange(buffer, tail, buffer.bytes[buffer.start .. tail.start])
    ensures buffer.bytes[buffer.start .. tail.start] == buffer.bytes[buffer.start .. verifiedTail.start] + readRange
    decreases buffer, verifiedTail, tail, readRange
  {
    reveal CorrectlyReadRange();
    CorrectlyReadByteRange(verifiedTail, tail, readRange);
  }

  function method Write(data: seq<uint8>): (res: seq<uint8>)
    ensures data == res
    decreases data
  {
    data
  }

  opaque function method Read(buffer: ReadableBuffer, length: uint64): (res: ReadBinaryCorrect<seq<uint8>>)
    ensures true && buffer.start as nat + length as nat <= |buffer.bytes| <==> res.Success? && |res.value.data| == length as nat
    ensures true && |buffer.bytes| < buffer.start as nat + length as nat <==> res.Failure? && res.error.MoreNeeded? && res.error.pos == Add(buffer.start, length)
    ensures CorrectlyRead(buffer, res, Write)
    decreases buffer, length
  {
    reveal CorrectlyReadRange();
    var end: uint64 := Add(buffer.start, length);
    SequenceIsSafeBecauseItIsInMemory(buffer.bytes);
    :- Need(|buffer.bytes| as uint64 >= end, MoreNeeded(end)); Success(SuccessfulRead(buffer.bytes[buffer.start .. end], buffer.(start := end)))
  }

  function method WriteUint16(number: uint16): (ret: seq<uint8>)
    decreases number
  {
    Write(UInt16ToSeq(number))
  }

  opaque function method ReadUInt16(buffer: ReadableBuffer): (res: ReadBinaryCorrect<uint16>)
    ensures buffer.start as nat + 2 <= |buffer.bytes| <==> res.Success?
    ensures CorrectlyRead(buffer, res, WriteUint16)
    decreases buffer
  {
    var SuccessfulRead(uint16Bytes: seq<uint8>, tail: ReadableBuffer) :- Read(buffer, 2); Success(SuccessfulRead(SeqToUInt16(uint16Bytes), tail))
  }

  function method WriteUint32(number: uint32): (ret: seq<uint8>)
    decreases number
  {
    Write(UInt32ToSeq(number))
  }

  opaque function method ReadUInt32(buffer: ReadableBuffer): (res: ReadBinaryCorrect<uint32>)
    ensures buffer.start as nat + 4 <= |buffer.bytes| <==> res.Success?
    ensures CorrectlyRead(buffer, res, WriteUint32)
    decreases buffer
  {
    var SuccessfulRead(uint32Bytes: seq<uint8>, tail: ReadableBuffer) :- Read(buffer, 4); Success(SuccessfulRead(SeqToUInt32(uint32Bytes), tail))
  }

  function method WriteUint64(number: uint64): (ret: seq<uint8>)
    decreases number
  {
    Write(UInt64ToSeq(number))
  }

  opaque function method ReadUInt64(buffer: ReadableBuffer): (res: ReadBinaryCorrect<uint64>)
    ensures buffer.start as nat + 8 <= |buffer.bytes| <==> res.Success?
    ensures CorrectlyRead(buffer, res, UInt64ToSeq)
    decreases buffer
  {
    var SuccessfulRead(uint64Bytes: seq<uint8>, tail: ReadableBuffer) :- Read(buffer, 8); Success(SuccessfulRead(SeqToUInt64(uint64Bytes), tail))
  }

  function method WriteShortLengthSeq(d: Uint8Seq16): (res: seq<uint8>)
    decreases d
  {
    WriteUint16(|d| as uint16) + Write(d)
  }

  opaque function method ReadShortLengthSeq(buffer: ReadableBuffer): (res: ReadCorrect<Uint8Seq16>)
    ensures CorrectlyRead(buffer, res, WriteShortLengthSeq)
    ensures res.Success? ==> ReadUInt16(buffer).Success? && |res.value.data| == ReadUInt16(buffer).value.data as nat
    decreases buffer
  {
    var length: SuccessfulRead<uint16> :- ReadUInt16(buffer); var d: SuccessfulRead<Uint8Seq16> :- Read(length.tail, length.data as uint64); assert CorrectlyReadRange(buffer, d.tail, WriteShortLengthSeq(d.data)) by {
    reveal CorrectlyReadRange();
  } Success(d)
  }

  function method WriteUint32Seq(d: Uint8Seq32): (res: seq<uint8>)
    decreases d
  {
    WriteUint32(|d| as uint32) + Write(d)
  }

  opaque function method ReadUint32Seq(buffer: ReadableBuffer): (res: ReadCorrect<Uint8Seq32>)
    ensures CorrectlyRead(buffer, res, WriteUint32Seq)
    ensures res.Success? ==> ReadUInt32(buffer).Success? && |res.value.data| == ReadUInt32(buffer).value.data as nat
    decreases buffer
  {
    var length: SuccessfulRead<uint32> :- ReadUInt32(buffer); var d: SuccessfulRead<Uint8Seq32> :- Read(length.tail, length.data as uint64); assert CorrectlyReadRange(buffer, d.tail, WriteUint32Seq(d.data)) by {
    reveal CorrectlyReadRange();
  } Success(d)
  }

  function method WriteUint64Seq(d: Uint8Seq64): (res: seq<uint8>)
    decreases d
  {
    WriteUint64(|d| as uint64) + Write(d)
  }

  opaque function method ReadUint64Seq(buffer: ReadableBuffer): (res: ReadCorrect<Uint8Seq64>)
    ensures CorrectlyRead(buffer, res, WriteUint64Seq)
    ensures res.Success? ==> ReadUInt64(buffer).Success? && |res.value.data| == ReadUInt64(buffer).value.data as nat
    decreases buffer
  {
    var length: SuccessfulRead<uint64> :- ReadUInt64(buffer); var d: SuccessfulRead<Uint8Seq64> :- Read(length.tail, length.data); assert CorrectlyReadRange(buffer, d.tail, WriteUint64Seq(d.data)) by {
    reveal CorrectlyReadRange();
  } Success(d)
  }

  predicate CorrectlyReadableByteRange?(buffer: ReadableBuffer, bytes: seq<uint8>)
    ensures CorrectlyReadableByteRange?(buffer, bytes) ==> buffer.start as nat <= buffer.start as nat + |bytes| <= |buffer.bytes| && CorrectlyReadRange(buffer, buffer, buffer.bytes[buffer.start .. buffer.start])
    decreases buffer, bytes
  {
    reveal CorrectlyReadRange();
    SequenceIsSafeBecauseItIsInMemory(bytes);
    CorrectlyReadRange(buffer, MoveStart(buffer, |bytes|), bytes)
  }

  function MoveStart(buffer: ReadableBuffer, length: nat): (ret: ReadableBuffer)
    decreases buffer, length
  {
    ValueIsSafeBecauseItIsInMemory(buffer.start as nat + length);
    buffer.(start := (buffer.start as nat + length) as uint64)
  }

  lemma AdvanceCorrectlyReadableByteRange?(buffer: ReadableBuffer, bytes: seq<uint8>, verifiedTail: ReadableBuffer, readRange?: seq<uint8>)
    requires CorrectlyReadableByteRange?(buffer, bytes)
    requires buffer.start as nat <= verifiedTail.start as nat <= |buffer.bytes|
    requires CorrectlyReadRange(buffer, verifiedTail, buffer.bytes[buffer.start .. verifiedTail.start])
    requires buffer.bytes[buffer.start .. verifiedTail.start] + readRange? <= bytes
    ensures CorrectlyReadableByteRange?(verifiedTail, readRange?)
    decreases buffer, bytes, verifiedTail, readRange?
  {
    reveal CorrectlyReadRange();
  }

  lemma ReadIsComplete(data: seq<uint8>, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<seq<uint8>>)
    requires Write(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == Read(buffer, |bytes| as uint64)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    ret := Read(buffer, |Write(data)| as uint64).value;
    CorrectlyReadByteRange(buffer, ret.tail, bytes);
  }

  lemma ReadUInt16IsComplete(data: uint16, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<uint16>)
    requires WriteUint16(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadUInt16(buffer)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    ret := ReadUInt16(buffer).value;
    CorrectlyReadByteRange(buffer, ret.tail, bytes);
  }

  lemma ReadUInt32IsComplete(data: uint32, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<uint32>)
    requires WriteUint32(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadUInt32(buffer)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    ret := ReadUInt32(buffer).value;
    CorrectlyReadByteRange(buffer, ret.tail, bytes);
  }

  lemma ReadUInt64IsComplete(data: uint64, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<uint64>)
    requires WriteUint64(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadUInt64(buffer)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    ret := ReadUInt64(buffer).value;
    CorrectlyReadByteRange(buffer, ret.tail, bytes);
  }

  lemma ReadShortLengthSeqIsComplete(data: Uint8Seq16, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<Uint8Seq16>)
    requires WriteShortLengthSeq(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadShortLengthSeq(buffer)
    decreases data, bytes, buffer
  {
    assert bytes == WriteUint16(|data| as uint16) + Write(data);
    assert bytes[..|WriteUint16(|data| as uint16)|] == WriteUint16(|data| as uint16);
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, buffer, WriteUint16(|data| as uint16));
    ghost var continuation := ReadUInt16IsComplete(|data| as uint16, WriteUint16(|data| as uint16), buffer);
    CorrectlyReadByteRange(buffer, continuation.tail, WriteUint16(continuation.data));
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, continuation.tail, Write(data));
    ghost var tail := ReadIsComplete(data, Write(data), continuation.tail);
    assert tail.data == data;
    reveal ReadShortLengthSeq();
    ret := ReadShortLengthSeq(buffer).value;
  }

  lemma ReadUint32SeqIsComplete(data: Uint8Seq32, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<Uint8Seq32>)
    requires WriteUint32Seq(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ret.data == data && Success(ret) == ReadUint32Seq(buffer)
    decreases data, bytes, buffer
  {
    assert bytes == WriteUint32(|data| as uint32) + Write(data);
    assert bytes[..|WriteUint32(|data| as uint32)|] == WriteUint32(|data| as uint32);
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, buffer, WriteUint32(|data| as uint32));
    ghost var continuation := ReadUInt32IsComplete(|data| as uint32, WriteUint32(|data| as uint32), buffer);
    CorrectlyReadByteRange(buffer, continuation.tail, WriteUint32(continuation.data));
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, continuation.tail, Write(data));
    ghost var tail := ReadIsComplete(data, Write(data), continuation.tail);
    assert tail.data == data;
    reveal ReadUint32Seq();
    ret := ReadUint32Seq(buffer).value;
  }

  lemma ReadUint64SeqIsComplete(data: Uint8Seq64, bytes: seq<uint8>, buffer: ReadableBuffer)
      returns (ret: SuccessfulRead<Uint8Seq64>)
    requires WriteUint64Seq(data) == bytes && CorrectlyReadableByteRange?(buffer, bytes)
    ensures ReadUint64Seq(buffer).Success? && ReadUint64Seq(buffer).value.data == data && ReadUint64Seq(buffer).value.tail.start as nat == buffer.start as nat + |bytes|
    ensures ret.data == data && Success(ret) == ReadUint64Seq(buffer)
    decreases data, bytes, buffer
  {
    reveal CorrectlyReadRange();
    assert bytes == WriteUint64(|data| as uint64) + Write(data);
    assert bytes[..|WriteUint64(|data| as uint64)|] == WriteUint64(|data| as uint64);
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, buffer, WriteUint64(|data| as uint64));
    ghost var continuation := ReadUInt64IsComplete(|data| as uint64, WriteUint64(|data| as uint64), buffer);
    CorrectlyReadByteRange(buffer, continuation.tail, WriteUint64(continuation.data));
    AdvanceCorrectlyReadableByteRange?(buffer, bytes, continuation.tail, Write(data));
    ghost var tail := ReadIsComplete(data, Write(data), continuation.tail);
    assert tail.data == data;
    reveal ReadUint64Seq();
    ret := ReadUint64Seq(buffer).value;
  }

  import Seq

  import opened UInt = StandardLibrary.UInt

  import opened Wrappers

  import opened UTF8

  import opened MemoryMath = StandardLibrary.MemoryMath

  datatype ReadProblems = MoreNeeded(pos: uint64) | Error(message: string)

  type MoreNeeded = p: ReadProblems
    | p.MoreNeeded?
    witness *

  datatype ReadableBuffer = ReadableBuffer(bytes: seq<uint8>, start: uint64)

  datatype SuccessfulRead<T> = SuccessfulRead(data: T, tail: ReadableBuffer)

  type ReadResult<T, E> = Result<SuccessfulRead<T>, E>

  type ReadCorrect<T> = ReadResult<T, ReadProblems>

  type ReadBinaryCorrect<T> = ReadResult<T, MoreNeeded>
}


